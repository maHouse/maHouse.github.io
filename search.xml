<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[一键清理]]></title>
      <url>/2017/07/07/%E4%B8%80%E9%94%AE%E6%B8%85%E7%90%86/</url>
      <content type="html"><![CDATA[<p>我是不愿意在自己的电脑上装个电脑管家、360卫士或者金山毒霸什么玩意的东西来清理我的电脑的，前两天在网上浏览到一个好玩的东西，你只要设置一下，花你几分钟的时间就能自己搞个清理器，不要钱还没有绑定的插件，效果还不错！<br>这个家伙长什么样子呢？</p>
<p><strong>如图：</strong></p>
<p><img src="image/clean.png" alt=""></p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1.这个样子你直接点击就能进行清理工作了；</p>
<p>2.这个文件的格式是.bat，这是必须改成这个样子；</p>
<p>3.编辑的时候把如下代码粘贴进text文档就行了：</p>
<pre><code>@echo off     
echo 正在清除系统垃圾文件，请稍等......     
del /f /s /q %systemdrive%\*.tmp     
del /f /s /q %systemdrive%\*._mp     
del /f /s /q %systemdrive%\*.log     
del /f /s /q %systemdrive%\*.gid     
del /f /s /q %systemdrive%\*.chk     
del /f /s /q %systemdrive%\*.old     
del /f /s /q %systemdrive%\recycled\*.*     
del /f /s /q %windir%\*.bak     
del /f /s /q %windir%\prefetch\*.*     
rd /s /q %windir%\temp &amp; md %windir%\temp     
del /f /q %userprofile%\COOKIES s\*.*     
del /f /q %userprofile%\recent\*.*     
del /f /s /q &quot;%userprofile%\Local Settings\Temporary Internet Files\*.*&quot;     
del /f /s /q &quot;%userprofile%\Local Settings\Temp\*.*&quot;     
del /f /s /q &quot;%userprofile%\recent\*.*&quot;     
sfc /purgecache &apos;清理系统盘无用文件     
defrag %systemdrive% -b &apos;优化预读信息     
echo 清除系统LJ完成！     
echo. &amp; pause  
</code></pre><p>把上面的粘到txt文档后，修改改为.bat就能用了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[通过设置hosts文件来翻墙]]></title>
      <url>/2017/07/06/hosts%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>下面我们就分几个步骤来说，文章以win10系统为例，其他系统类似。</p>
<h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p>首先你到网上找到个hosts文件，这个文件要找到个最新的版本，直接在百度上搜索去吧！找到后就下载下来；</p>
<h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p>在我的电脑里，打开文件的顺序如下： C盘/windows/system32/drivers/etc/hosts，把你下载的hosts文件拷贝到这里，替换掉系统原来的hosts文件。执行的时候可能会具备管理者权限才行。</p>
<h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><p>配置好后，，windows+r,进入命令面板，，输入ipconfig/flushdns,按enter键执行即可，这个是为了改变DNS指向</p>
<h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p>完事后，就把网给拔掉，重新连接网络</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>完事后关闭chrome再打开，这一切的前提是别忘了你得下载个Google浏览器，其他的事项应该就木有了吧！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[类和模块]]></title>
      <url>/2017/07/01/%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="这一节我们的主题是：类和模块"><a href="#这一节我们的主题是：类和模块" class="headerlink" title="这一节我们的主题是：类和模块"></a>这一节我们的主题是：类和模块</h1><p><strong>JavaScript的对象是一个属性的集合体，相互之间没有任何的联系。然而有些时候对象与对象之间的属性相同的时候，为了不重复写代码，我们要定义一个类，这个类里面的属性和方法对于他的成员或者实例都是共享的。下面就是对类的知识的介绍。</strong></p>
<h4 id="1、类和原型"><a href="#1、类和原型" class="headerlink" title="1、类和原型"></a>1、类和原型</h4><p>在JavaScript中，类的实现是基于原型继承机制的，所有的实例对象都是从同一个原型对象上继承属性，因此原型对象是类的核心。如果定义一个原型对象，然后通过inherit()函数创建一个继承自它的对象，这样就定义了一个JavaScript类。</p>
<p>例子中给一个表示“值的范围”的类定义了原型对象，还定义了一个工厂函数用以创建并初始化类的实例。</p>
<p>for example 1：</p>
<pre><code>//range.js:实现一个能表示值的范围的类

//这个工厂方法返回一个新的&quot;范围对象&quot;
function range(from,to) {
    //使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象
    //原型对象作为函数的一个属性存储，并定义所有&quot;范围对象&quot;所共享的方法
    var r = inherit(range.methods);

    //存储新的‘范围对象’的起始位置和结束位置（状态）
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    r.from = from;
    r.to = to;

    //返回这个新创建的对象
    return r;
}


//原型对象定义方法，这些方法为每个范围对象所继承
range.methods = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) {
        return this.from &lt;= x &amp;&amp; x &lt;=this.to;
    },


    //对于范围内的每个整数都调用一次f
    //这个方法只可用作数字范围
    foreach:function (f) {
        for(var x = Math.ceil(this.from);x &lt;= this.to;x++) f(x);
    },

    //返回表示这个范围的字符串
    tostring:function () {
        return&quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;
    }
};

//这里是使用‘范围对象’的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true,2在这个范围内
r.foreach(console.log);//输出1 2 3 
console.log(r);//输出(1...3)
</code></pre><p>解读：这段代码定义了一个工厂方法range(),用来创建新的范围对象。我们注意到，这里给range()函数定义了一个属性range.methods,用以快捷的存放定义类的原型对象。把对象挂在了函数上，这个方法不是惯用的方法。再者，注意range()函数给每个范围对象都定义了from和to属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在range.methods中定义的那些可共享、可继承的方法都用到了from和to属性，而且使用了this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类的方法都可以通过this的这种基本用法来读取对象的属性。</p>
<h3 id="2、类和构造函数"><a href="#2、类和构造函数" class="headerlink" title="2、类和构造函数"></a>2、类和构造函数</h3><h4 id="①、例子展示"><a href="#①、例子展示" class="headerlink" title="①、例子展示"></a>①、例子展示</h4><p>例子1中展示了定义类的其中一种方法，但是并不常用。说到了类也就有原型，而这种方法却没有用到构造函数。定义构造函数，它会初始化新创建的对象，调用构造函数的一个重要特征就是，构造函数的prototype属性被用于新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承于同一个相同的对象，属于同一个类的成员。下面我们就对例子1做了个修改，使用构造函数来代替工厂函数：</p>
<p>使用构造函数来定义“范围类”</p>
<p>for example 2：<br>    //range2.js:表示值的范围的类的另一种实现</p>
<pre><code>//这是一个构造函数，用以初始化新创建的“范围对象”
//注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from,to) {
    //存储‘范围对象‘的起始位置和结束位置
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}

//所有对象的’范围对象‘都继承自这个对象
//注意的是属性的名字必须是prototype
Range.prototype = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to;},
    //对于范围内的每个整数都调用一次f
    //这个方法只可用于数字范围
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    },
    //返回表示这个范围的字符串
    tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;}
};

//这里是使用’范围对象‘的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true，2在这个范围内
r.foreach(console.log);//输出1 2 3
console.log(r);//输出（1...3）
</code></pre><p>解读：ok，上面看到了两种方式来定义类，我们要知道一个编程约定：定义构造函数既是定义类，并且类名首字母要大写，而普通函数和方法是首字母小写。构造函数是使用关键字new来实现的，不必使用inherit()来创建对象。例子2中原型是Range.prototype,这是一个强制的命名，而例子1中是个随意的命名。对于Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。两者的相同之处是对于范围方法的定义和调用方式。</p>
<h4 id="②、构造函数和类的标识"><a href="#②、构造函数和类的标识" class="headerlink" title="②、构造函数和类的标识"></a>②、构造函数和类的标识</h4><p>原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的实例。初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的prototype属性指向同一个原型对象，那么这两个构造函数创建的实例属于同一个类。</p>
<p>构造函数是类的外在表现形式。构造函数的名字通常用作类名，我们通常用instanceOf运算符来检测对象是否属于某个类时会用到构造函数。假设有个对象r，我们想知道r是否是Range对象，我们可以这么做：</p>
<pre><code>r instanceOf Range //如果r继承自Range.prototype,则返回true
</code></pre><p>实际上，instanceOf不会检查r是否是由Range()构造函数初始化来的</p>
<h4 id="③、constructor属性"><a href="#③、constructor属性" class="headerlink" title="③、constructor属性"></a>③、constructor属性</h4>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[函数基础知识学习]]></title>
      <url>/2017/06/29/function/</url>
      <content type="html"><![CDATA[<h1 id="我们的主题是什么？"><a href="#我们的主题是什么？" class="headerlink" title="我们的主题是什么？"></a>我们的主题是什么？</h1><p>函数是一种特殊的对象，有自己的属性和方法，而这些个属性和方法是什么我们必须知道，什么样子是函数，函数的用处有哪些，这些是我们必须明确知晓的。</p>
<h2 id="一、函数的结构"><a href="#一、函数的结构" class="headerlink" title="一、函数的结构"></a>一、函数的结构</h2><p>函数体的组成部分必须包括：关键字function、函数名、一对圆括号、一对花括号、参数；</p>
<p>函数的声明方式有：函数语句式和函数定义式：</p>
<p>for example 1：</p>
<pre><code>① function  funcName() { //代码块} funcName();
② var f = function() {//代码块}  f();
</code></pre><p>注意第二种是把函数赋值给了一个函数，这里有和变量的声明一样的问题，就是声明提前的现象。</p>
<p>参数有形参和实参两种形式，形参是函数定义的时候出现的，而实参是函数调用的时候出现的，形参类似于局部变量，实参是一种类数组对象，名称为arguments，通过下标就能访问实参元素。</p>
<p>我们需要知道的是形参和实参的数量如果不相等的时候，若形参数量多于实参则属于undefined，如果实参多的话则会被自动省略掉。当然前面也说了实参列表是个类数组对象，我们可以用arguments来表达一个实参列表，这里就能用arguments来表示任意数量的实参个数了。</p>
<p>函数从被定义开始到调用为止，定义是一次完事，而调用的话则可以被调用任意次数。定义已经说完，就说调用。</p>
<h2 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h2><p>函数的调用有4中方式：函数调用、方法调用、构造函数调用和用call()和apply()的间接调用。</p>
<h3 id="1、函数调用"><a href="#1、函数调用" class="headerlink" title="1、函数调用"></a>1、函数调用</h3><p>这是最普通的调用了，解释器到达结尾返回undefined，碰到return语句，返回其值，没有值的话返回undefined。</p>
<p>注意的是，在非严格模式中，this返回的是全局对象不然就是undefined。</p>
<h3 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h3><p>函数作为对象的一个方法被调用，与函数调用的最大区别就是this值的不同，方法调用的this值的上下文是函数所处的对象。</p>
<p>当然，如果想要在函数调用中的this值是外部函数，则必须在外部函数的函数体内使用 <strong>var self = this</strong>，这样的话，就能达到this值就是外部函数了。</p>
<h3 id="3、构造函数调用"><a href="#3、构造函数调用" class="headerlink" title="3、构造函数调用"></a>3、构造函数调用</h3><p>构造函数必须用到new关键字，构造函数初始化了一个对象，这个对象的属性继承于prototype属性，而且this值指向的就是这个初始化了的对象。</p>
<p>构造函数调用允许省略实参列表和圆括号。</p>
<h3 id="4、间接调用"><a href="#4、间接调用" class="headerlink" title="4、间接调用"></a>4、间接调用</h3><p>用call()和apply()来达到某个对象使用某个函数作为方法的目的，这两种方法里的第一个实参的this值是这个使用函数的对象。无论哪个对象都可以使用本身所不具备的函数作为方法。call()的后面的参数是实参列表，但是apply()方法的后面就是个数组形式的实参列表了。</p>
<p>下面就说说作为一个整体的函数的情况吧，函数可以赋值给一个值，可以作为参数传给另外一个参数。</p>
<h2 id="三、函数的整体使用"><a href="#三、函数的整体使用" class="headerlink" title="三、函数的整体使用"></a>三、函数的整体使用</h2><h3 id="1、嵌套函数"><a href="#1、嵌套函数" class="headerlink" title="1、嵌套函数"></a>1、嵌套函数</h3><p>这里就有个作用域规则的事情，任何变量都能在他的函数体内发生作用，因为函数体是嵌套的，所以就有了嵌套的作用域，就有了作用域链，虽然外部函数不能访问到内部函数，但是可以把内部函数作为返回值返回出来。这里就会涉及到一个叫做闭包的技术，意思就是函数体通过作用域链关联起来（外部函数和嵌套函数是有关系的），函数体内的变量可以保存在作用域内。</p>
<h3 id="2、作为命名空间的函数"><a href="#2、作为命名空间的函数" class="headerlink" title="2、作为命名空间的函数"></a>2、作为命名空间的函数</h3><p>变量有全局变量，有局部变量。而我们不想让全局变量来污染全局作用域，那就必须用个函数来包括起来整个其他函数。方式有2：</p>
<p>for example 2：</p>
<pre><code>function func() {
    //模块代码
    //所有变量均为局部变量，不污染全局命名空间
}
func();//必须得调用
</code></pre><p>再有一种方式：</p>
<pre><code>(function(){

//代码块}())//立即调用，这是个定义表达式
</code></pre><h2 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h2><p>这个就是运用一些有一定含义的关键字来编写程序，比如可以用reduce()来计算数组合成一个数字的运算，而不用采取遍历计算的方式，等等吧。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数组基础知识]]></title>
      <url>/2017/06/23/Array/</url>
      <content type="html"><![CDATA[<h1 id="我们得知道这节的主题是什么："><a href="#我们得知道这节的主题是什么：" class="headerlink" title="我们得知道这节的主题是什么："></a>我们得知道这节的主题是什么：</h1><p><strong>一是数组是什么，长什么样子，我们看到了就能一眼认出来这个是不是数组；</strong></p>
<p><strong>二我们怎么创建数组，讲解的是数组的声明方式；</strong></p>
<p><strong>三是我们须知数组的一些属性和方法，因为数组不是你想怎么来就怎么来的，你必须按一定的套路走才是可行的；</strong></p>
<p><strong>四是我们要知道数组与对象和字符串的关系，因为是近亲所以有更多有意思的事情。</strong></p>
<p><strong>好了接下来一一说。</strong></p>
<h3 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h3><p><strong>数组是一系列值（元素）的有序集合体。</strong>从这里我们来解读一下。</p>
<p>①数组既然是个集合体，那么就有一个范围，来表示这就是一个数组单元，数组的开始和结束标识符就是”[]”,双引号里面的中括号就是一个数组的最基本的构成；</p>
<p>for example1：</p>
<pre><code>var a = [];
var b = [,1,2,7,true,&apos;ww&apos;,{x:1},1];
</code></pre><p>②数组里面的元素是什么，可以使任意数据类型的值的杂合，当然有时候杂合的东西的不容易操作。比如例子1里面的b数组就是个各种数据类型都有的杂合体，JSON无疑就是个数组里面加对象；</p>
<p>③有序，数组里面的元素是有顺序的，顺序是从整数0开始排序的（也就是每个数组的元素都有个索引值，这个索引值就是从0开始的），因此数组b中的两个元素数字1，他们的索引是不一样的，明显的是第一个索引值小，第二个大。</p>
<p>现在我们知道了数组的长相，能辨认数组了，那么接下来我们就看看怎么声明一个数组：</p>
<h3 id="二、数组的声明"><a href="#二、数组的声明" class="headerlink" title="二、数组的声明"></a>二、数组的声明</h3><p>声明数组的方式总的来说有两种：</p>
<p>①仿照对象的声明，通过数组直接量的形式，例子就是例子1；</p>
<p>②就是用个关键字new 来声明：</p>
<p>for example2：</p>
<pre><code>var a = new Array(1,2,3,true,&apos;test&apos;);
</code></pre><p>综合老看推荐的是使用数组直接量的方式来声明一个数组。</p>
<p>这里我们在稍微的说点，稀松数组就是数组里存在一个空的元素，而多维数组就是几个数组的嵌套了，因为数组的元素不是固定的，所以可以有这效果。</p>
<h3 id="三、数组的属性和方法"><a href="#三、数组的属性和方法" class="headerlink" title="三、数组的属性和方法"></a>三、数组的属性和方法</h3><p>数组知识的重点，就是这个数组的属性和方法，再有个重点就是数组与对象和字符串的关系。这次我们就先谈谈这个，分增、删、改、查4个方面来说。</p>
<h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>增的意思是数组的元素增多了，这个增多可以是原来数组的值的增加，也可以是形成了一个新的数组，这就意味着数组的length是变大了。好！开始介绍方法。</p>
<p>①、先来个不改变原来数组的:concat(),他的意思是把两个数组的元素给拼接起来,或者就是把元素添加到数组的元素中去：<br>for example4：</p>
<pre><code>var d = [1,3];
var dd = d.concat(&apos;1&apos;,2,4);//不改变原来的数组[1,3,&apos;1&apos;,2,4]
var ddd = d.concat([1,3,5],[4,7]);//[1,3,1,3,5,4,7]
</code></pre><p>②、通过索引为数组增加值，变化的是原来的数组：</p>
<p>for example3：</p>
<pre><code>var c = [];
c[0] = 1;//c = [0]
c[1] = 2;//c = [0,2]
c[3] = &apos;test&apos;;//c = [0,2,&apos;test&apos;]
</code></pre><p>③、push(),改变了原来的数组，意思是往原来的数组的末尾加一个或多个元素,这个和pop()组成了类似于栈的先进后出的感觉：</p>
<p>for example4：</p>
<pre><code>var pushes = [&apos;hello&apos;,&apos;2&apos;,22];
    pushes.push(11,77);//这样既可[&apos;hello&apos;,&apos;2&apos;,22,11,77]
</code></pre><p>④、unshift(),类似于push()，不过unshift()是把元素添加到了原数组元素的第一个位置：</p>
<p>for example4：</p>
<pre><code>var unshifted = [&apos;hello&apos;,&apos;2&apos;,22];
    unshifted.unshift(11,77);//这样既可[11,77,&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>⑤、splice(),这个比较特殊，因为他能增加也能减少，同样的是他改变的也是原来的数组,splice()方法里有三个参数，第一个为必填的，后两个为可选的，第一个参数是数组的索引值，是个整数，第二个意思是从第一个索引值的位置开始要去掉几个元素,这个值可以为负值，最后一个参数意思是去掉了参数，我们用什么来填补，是我们要填补的元素,返回的值是删除元素组成的数组：</p>
<p>for example5：</p>
<pre><code>var s = [&apos;hello&apos;,&apos;2&apos;,22,11,77];
    s.splice(0,3);//返回[&apos;hello&apos;,&apos;2&apos;,22]
    s.splice(0,3，&apos;world&apos;,33);//返回[&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>以上就是增，下面说说删。</p>
<h4 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h4><p>因为说过了增，删的部分大部分是对应的，所以我们就把那些不对应的讲解一下：</p>
<p>①、delete，这是个运算符，他删除的是元素的值，至于数组的length是不变的，去掉的是数组的元素值，去不掉的是数组的属性。</p>
<p>for example6：</p>
<pre><code>var del = [1,2,3];
delete del[2];//在原数组中就没有了元素3，但是数组的length仍旧是3
</code></pre><p>②、pop(),对比push()去吧！</p>
<p>③、shift(),对比unshift()去吧！</p>
<p>④、splice()</p>
<h4 id="3-改和查"><a href="#3-改和查" class="headerlink" title="3.改和查"></a>3.改和查</h4><p>把改和查放在一起，因为我们会感觉到他们是一体的。</p>
<p>①、slice(),能接收两个参数，第一个参数是必须的，为整数值，第二个参数为可选的，为整数值，都可为负值，不改变原有的数组,截取的值包前不包后：</p>
<p>for example7：</p>
<pre><code>var sl = [1,2,3];
sl.slice(0,1);//返回[1]
</code></pre><p>②、reverse(),把数组的元素值给倒过来排序，改变了原来的数组元素的排序：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3];
revers.reverse();//返回[3,2,1]
</code></pre><p>③、sort(),把数组的元素按英文字母的顺序进行排序，也就是ASC11的顺序，这个可以接受一个比较函数，进行更好运算：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3,10];
revers.sort();//返回[1,10,2,3]
revers.sort(function(x,y) {
        return x-y;
    });//返回的就是按数字大小比较后的顺序的数组了
</code></pre><p>对一个字符串数组执行不区分大小写的字符表排序，比较函数首先将参数转化为小写字符串，再开始比较：</p>
<p>for example8：</p>
<pre><code>var a = [&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;];
a.sort();//返回[&apos;Bug&apos;,&apos;Dog&apos;,&apos;ant&apos;,&apos;cat&apos;]
a.sort(function(x,y) {
        var a = x.toLowerCase();
        var b = y.toLowerCase();
        if (a &lt; b) return -1;
        if (a &gt; b) return 1;
        return 0;
    });//返回[&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;]
</code></pre><p>这里我们再简单的说说例子7和例子8中，比较函数的工作原理，我们传进去的是两个参数，所以这个比较函数每次的比较是两个两个进行比较的，每次比较后就进行一次两个元素位置的调换，而如果前(n-1)个元素没有排好序的话（说的就是最后一个元素前的元素如果已经排好序，那就直接进行第n-1个元素与最后一个元素的比较就可以了），正常情况下，我们是要用前面n-1个元素来与第n个元素进行比较的。如果想自己看看操作的话，就用chrome自己打个断点，自己看看他的工作流程。</p>
<p>④、遍历：for循环和forEach(),都是遍历数组内的每个元素，不同的是前者有个break可以跳出，后者想要终止的话，则必须把forEach()放到try()块中,里面传进去的是个函数：</p>
<p>for example8：</p>
<pre><code>function foreach(a,f,t) {
    try {a.forEach(f,t);}
    catch(e) {
        if (e === foreach.break) return;
        else throw e;
    }
}
foreach.break = new Error(&quot;StopIteration&quot;);
</code></pre><p>⑤、映射，这里就是用map()，就是数学函数里映射，一对一，里面包括一个函数：</p>
<p>for example9：</p>
<pre><code>var a = [1,3,4];
b = a.map(function(x) {
return x*x;});//返回的就是[1,9,16],返回的是新的数组，不修改原来的数组
</code></pre><p>⑥、过滤，就是用某个条件作为筛选，用到的是filter(),这个方法会过滤掉undefined和null，他返回的总是稠密数组不会是稀疏数组：</p>
<p>for example10：</p>
<pre><code>var a = [5,4,3,2,1];
smallValues = a.filter(function(x) { return x &lt; 3;});
other = a.filter(function(x) { return x%2 == 0;});//参数可以多个

a = a.filter(function(x) { return x !== undefined &amp;&amp; x !== null;});//过滤掉undefined和null元素
</code></pre><p>⑦、every()和some()，这里返回的是个boolean值：</p>
<p>for example11：</p>
<pre><code>var a = [1,2,3,4,5];
a.every(function(x) {return x &lt; 10;});//返回的就是true
a.every(function(x) { return x % 2 == 0;});//返回false
</code></pre><p>而如果用some()来代替every()的话，就全是true了，因为some()意思是存在而every()是全部的意思。</p>
<p>⑧、reduce()和reduceRight()，他们的意思就是通过某个函数把数组的元素整合为单个值，需要传进去两个参数，不过以数值和对象为主，前者是从低索引开始后者从高索引开始：</p>
<p>for example 12：</p>
<pre><code>var a = [1,2,3,4,5];
var sum = a.reduce(function(x,y) {
    return x+y;},0);//0是初始值，可以不要，返回15
var max = a.reduce(function(x,y) {
    return (x &gt; y) ? x :y;});//求最大值
var product = a.reduce(function(x,y) {
    return x * y;},1);//乘积
</code></pre><p>下面说说对象的形式吧！</p>
<p>for example 13:</p>
<pre><code>var objects = [{x:1},{y:2},{z:3}];
var merged = objects.reduce(union);//返回{x:1,y:2,z:3}，是对象的集合

var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
var leftUnion = objects.reduce(union);//返回{x:1,a:1,y:2,z:3}
var rightUnion = objects.reduceRight(union);//返回{x:1,y:2,z:3,a:3}
</code></pre><p>⑨、indexOf()和lastIndexOf()，里面填写的是元素，返回的是这个元素的位置的索引，如果元素重复，返回的是第一个元素的位置的索引值，这两个方法方向相反，如果没有的话就返回-1,有两个参数，第二个参数可选，意思是要从哪个索引开始：</p>
<p>for example 14:</p>
<pre><code>var a = [0,1,2,1,0];
a.indexOf(1);//1
a.indexOf(3);//-1，因为没有这个值
a.lastIndexOf(1);//3
</code></pre><p>for example 15:</p>
<pre><code>//在数组中查找所有出现的x,并返回一个匹配数组索引的数组
function findAll(a,x) {
    var results = [],
        len = a.length,
        pos = 0;
    while(pos &lt; len) {
        pos = a.indexOf(x,pos);
        if (pos === -1) break;
        results.push(pos);
        pos +=1;
    }
    return results;
}
</code></pre><h3 id="四、数组的亲密关系"><a href="#四、数组的亲密关系" class="headerlink" title="四、数组的亲密关系"></a>四、数组的亲密关系</h3><p>数组的亲密关系牵扯到两个：一是字符串；二是对象，无论哪个都可以有数组的一些特性，如:自动更新length、设置length来获取一段数组、从Array.prototype来继承有用的方法、其类属性为Array：</p>
<h4 id="1-与字符串的关系"><a href="#1-与字符串的关系" class="headerlink" title="1.与字符串的关系"></a>1.与字符串的关系</h4><p>①、join()和split()这是一对，前者把数组元素以某种方式拼接起来并输出一个字符串，后者是把字符串以某个元素为分界线分为数组，不再举例子；</p>
<p>②、toString()和toLocalString(),与join()类似，把数组元素转化为字符串，后者是以本地化分隔符连接元素生成字符串；</p>
<p>③、说说继承Array.prototype的方法：</p>
<p>for example 16:</p>
<pre><code>var s = &quot;JavaScript&quot;;
Array.prototype.join.call(s,&quot; &quot;);//&quot;J a v a S c r i p t&quot;,继承了join()方法
Array.prototype.filter.call(s,function(x) {
        return x.match(/[^aeiou]/);}).join(&quot;&quot;);//筛选掉了元音字母，&quot;JvScrpt&quot;
</code></pre><p>切记，字符串不能改变的，他们是只读的，对于那些push()、sort()、reverse()、splice()这些方法是不能使用的。</p>
<h4 id="2-类数组对象"><a href="#2-类数组对象" class="headerlink" title="2.类数组对象"></a>2.类数组对象</h4><p>这个我们还是能经常碰到的，譬如用document.getElementsByName()这个方法时得到的就是个类数组。</p>
<p>for example 17：</p>
<pre><code>var a = {&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3};//类数组对象
Array.prototype.join.call(a,&apos;+&apos;);//&apos;a+b+c&apos;
Array.prototype.slice.call(a,0);//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],真正的数组副本
Array.prototype.map.call(a,function(x) {
        return x.toUpperCase();});//[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]
</code></pre><h3 id="五、其他：数组类型"><a href="#五、其他：数组类型" class="headerlink" title="五、其他：数组类型"></a>五、其他：数组类型</h3><p>判断是不是数组我们用两个方式：</p>
<h4 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1.Array.isArray()"></a>1.Array.isArray()</h4><pre><code>Array.isArray([]);//true
Array.isArray({});//false
</code></pre><h4 id="2-instanceOf运算符"><a href="#2-instanceOf运算符" class="headerlink" title="2.instanceOf运算符"></a>2.instanceOf运算符</h4><pre><code>[] instanceOf Array;//true
({}) instanceOf Array;//false
</code></pre><h1 id="告一段落，下次看函数"><a href="#告一段落，下次看函数" class="headerlink" title="告一段落，下次看函数"></a>告一段落，下次看函数</h1>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[语句]]></title>
      <url>/2017/05/26/%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>一、表达式语句</strong></p>
<p>表达式语句常见的就是两类：赋值语句和函数调用，声明语句有var声明和function声明。</p>
<p><strong>二、条件语句</strong></p>
<p>条件语句两种if语句和switch语句，这里就说说switch语句：</p>
<pre><code>switch(n){
case ①;
//代码块
break；
case ②；
//代码块
break;
default;
//代码块
break;
}
</code></pre><p>传进来参数与①、②、③进行匹配，如果n与某个值恒等时，就执行相应的代码块。</p>
<p><strong>三、use strict（严格模式）与非严格模式的比较</strong></p>
<p>use strict语句的目的是说明脚本或者函数体的后续代码将会解析为严格代码。如果放在顶层了，那么就是严格代码。</p>
<p>use strict和普通语句的区别：</p>
<p>1.不包含任何语言的关键字，对于JavaScript解释器来说，它只是一条没有副作用的表达式语句，什么也没有做。</p>
<p>2.use strict只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。并不一定是出现在首行。</p>
<p>严格模式与非严格模式的区别</p>
<p>1.严格模式中禁止使用with语句；</p>
<p>2.所有的变量都要先声明；</p>
<p>3.严格模式中，调用的函数中的一个this值是undefined，非严格模式中调用的函数中的this值总是全局对象；</p>
<p>4.严格模式中，通过call（）或者apply（）来调用函数时，其中的this值就是通过call（）或者apply()传入的第一个参数（非严格模式中，null和undefined值被全局对象和转换为对象的非对象所代替）；</p>
<p>5.严格模式中，给只读属性赋值和给不可扩展的对象创建新成员时，会抛出一个类型错误的异常，在非中仅仅是操作失败；</p>
<p>6.严格模式中，函数的arguments对象拥有传入函数值的静态副本，非中arguments的数组和函数都是指向同一个值的引用；</p>
<p>7.严格模式中，当delete运算符后跟随非法的标识符（变量、函数、函数参数）时，会抛出语法错误，非严格模式中，delete什么也没有做，返回false；</p>
<p>8.严格模式中，在一个函数直接量中定义两个或多个同名属性将产生一个语法错误；</p>
<p>9.严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误，非中不会报错；</p>
<p>10.严格模式中，标识符eval和arguments当作关键字，它们的值是不能更改的。不能赋值、声明为变量、用作函数名、用作函数参数或者用作catch块的标识符；</p>
<p>11.严格模式中限制了对调用栈的检测能力，arguments.caller和arguments.callee都会抛出一个类型错误异常。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[部分运算符]]></title>
      <url>/2017/05/25/%E9%83%A8%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p><strong>1.in运算符</strong></p>
<p>in运算符左右有两个位置，左边的位置放的是字符串或者可以转化为字符串的值，右边的是对象，如：数组、对象。<br><img src="/image/in.jpg" alt=""></p>
<p>一般情况是字符串匹配的是对象，字符串的内容是属性名；是数字的时候匹配的是数组，数字是索引。</p>
<p><strong>2.instanceof运算符</strong></p>
<p>这个运算符是区分对象的类的，这里多提一点，区分对象的类的方法还有通过class特性和constructor属性，这两种方式，instanceof和in运算符类似，有两个操作数，不同的是①的位置是个对象，②的位置是个对象的类。<br><img src="/image/instanceof.jpg" alt=""></p>
<p>这个操作的返回值是个布尔值，如果①是②的实例化对象，则返回值是true，不是的话则返回值是false。这个寻找过程是：在原型链中找到①这个对象，再在①的原型链中找②.prototype,如果有的话就返回true，否则的话返回false。</p>
<p><strong>3.typeof运算符</strong></p>
<p>typeof运算符是我们经常用到的，我们用它来区分原始值和对象，typeof后面跟的可以是任意值。typeof是个一元运算符，我们要注意到和instanceof的不同。</p>
<p>使用形式有两种方式：  </p>
<pre><code>typeof &apos;hello world&apos;;//这里用到的是字符串
</code></pre><p> OR </p>
<pre><code>typeof (&apos;hello world&apos;);
</code></pre><p><strong>注意：</strong>typeof将函数区别对待，返回值页特殊。</p>
<p><strong>4.三元运算符</strong></p>
<p><img src="/image/three.jpg" alt=""></p>
<p>三元运算符有3个操作数，①的返回值是个布尔值，如果返回的是true，则执行②，并得出返回值，如果是false则执行③，这个比用if语句更加简洁。</p>
<p>最后说eval(),里面放进去的是字符串，返回的是一个值，因为只有字符串才会被编译（parse），其他的值放进去只会被原封不动地返回来，它是动态的，实际中运用之处微乎极微，可以考虑不使用。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[变量声明及作用域]]></title>
      <url>/2017/05/22/variable-key/</url>
      <content type="html"><![CDATA[<p>变量声明有两种方式一是用<strong>var</strong>关键词再有就是用<strong>function</strong>关键词，声明使代码具有了语义。</p>
<p>var关键词声明变量在函数体内是局部变量在函数体外是全局变量，不用var声明变量无论在函数体内还是函数体外都是全局变量，后种方式声明的变量是可以用运算符delete删除掉声明的变量的，var关键词声明的变量不能被删除掉。</p>
<p>作用域就是变量能发生作用的范围，JavaScript不像C那样：变量在声明它们的代码块之外是不可见的，C是块级作用域。而JavaScript的作用域是全局作用域和局部作用域，变量在声明他们的函数体内及函数体的嵌套函数体内都是可见的。</p>
<p>变量在未声明之前是可以使用的，变量的生命提前使得变量的声明提前到函数体的顶部。</p>
<p>下面说说作用域链，作用域链从把变量的声明当作对象的属性看待说起，作用域链就是个查找的过程了。在《JavaScript权威指南》里的原话放在这里，当定义一个函数时，它实际上保存一个<strong>作用域链</strong>，当调用这个函数时，他创建一个新的对象来存储他的<strong>局部变量</strong>，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。对于嵌套函数来说，事情变得更加有趣，每次<strong>调用外部函数</strong>时，<strong>内部函数又会重新定义一遍</strong>。因为每次<strong>调用外部函数的时候，作用域链都是不同的</strong>。内部函数在每次定义的时候都有微妙差别—在每次调用外部函数，内部函数的代码都是相同的，而关联这段代码的作用域不相同。</p>
<p>调用外部函数的时候，内部函数重新定义，这是由于作用域链的不同。大致理解了它的原理。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[对象]]></title>
      <url>/2017/05/21/object/</url>
      <content type="html"><![CDATA[<h2 id="一、综合概述"><a href="#一、综合概述" class="headerlink" title="一、综合概述"></a><strong>一、综合概述</strong></h2><p><strong>1.全局对象：</strong></p>
<p>全局属性：undefined、NaN、infinity</p>
<p>全局函数：isNaN()、parseInt()、eval()</p>
<p>全局对象：Math、JSON</p>
<p>构造函数：Date（）、RegExp()、String（）、Object（）、Array（）</p>
<p><strong>2.包装对象</strong></p>
<p>JavaScript里有些原始值如：字符串、数字、布尔值，它们是有自己的属性和方法的，那么它们不是对象，属性和方法又从何而来呢？</p>
<p>那我们就先从说对象说起，对象是一系列属性名和属性值的集合体。对象要引用属性值就用”.”加上属性名来引用；对象里的方法是用函数表示的，引用的时候用o.m()来表示。</p>
<p>不同的是，原始值里的字符串、数字和布尔值的属性和方法是不能被定义新的值的，而对象里面是能改变的。</p>
<p>在例子中：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;
s.indexOf(&apos;t&apos;) = 0;
</code></pre><p>在上面的例子中s是字符串，但是具有自己的属性和方法，它的实现方式是在s引用自己的属性和方法时，就会通过new String(s)创建一个临时对象，这个对象会继承s的特点。这个临时对象在用到的时候会被创建出来，一旦不用就会被销毁。</p>
<p>例如：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;//这里是设置的新的属性值
var t = s.len;
console.log(t);//undefined
</code></pre><p>在s.len = 4;使用完后，这个属性就被销毁了，不会在往下传递了，所以打印的结果是undefined；不是length哟！代码测试如果用下面的代码：</p>
<pre><code>var s = &apos;test&apos;;
s.length = 4;
var t = s.length;
console.log(t);//这个结果就是4了
</code></pre><p>可以运用构造函数来显示的创建包装对象，</p>
<pre><code>var s = &apos;test&apos;,n = 1,b = true;
var S = new String(s);
var N = new Number(n);
var B = new Boolean(b);
</code></pre><p>如果我们用’ == ‘来判断s与S、n与N、b与B的话，结果是true；如果用’ === ‘恒等式来判断的话，就不是这个结果了。</p>
<p>JavaScript中的值的类型会根据需要字型转变，无论进行什么运算，共同的值类型是每个单独的值都能转换过去的，转换的又隐式转换和显式转换</p>
<p>for example： </p>
<pre><code>&apos;5&apos; * &apos;6*;//30,//改变就是从字符串变化到了数字类型

 30 + &apos;object&apos;;//这里就只能转变为字符串了
</code></pre><p>parseInt() =&gt;意思是把值转换为16进制的，目前就是这么多了！不足的话就再加补充。</p>
<h2 id="二、对象的创建"><a href="#二、对象的创建" class="headerlink" title="二、对象的创建"></a>二、对象的创建</h2><p>ES5中创建对象有3中方式，对象直接量、new关键字和Object.create()，这3种方式。</p>
<p>for example：</p>
<p>①对象直接量，就是直接表示出对象里面的属性和方法：</p>
<pre><code>var o = {x:1,y:2,z:function (){alert(1);}
</code></pre><p>②new关键字，就是创建一个新的对象的意思：</p>
<pre><code>var o = new Object();
o.x = 1;
o.y = 2;
</code></pre><p>③第三种方式利用到了继承的性质，Object.create(<em>,</em>);这里面有两个参数，前面的是必须填写的，意思是某个对象继承了那个对象，当然也可以填写null，后面的第二个参数是个可选的参数：</p>
<pre><code>var o1 = Object.create({x:1,y:2});//o1继承了{x:1,y:2}的属性

var o2 = Object.create(null);
</code></pre><p>在o1的情况中涉及到了继承，一会说。</p>
<p>通过原型继承创建一个新对象</p>
<pre><code>//inherit()返回一个继承原型对象p的属性的新对象
function inherit(p){
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);//如果存在就是用它
    var t = typeof p;
    if (t !== &apos;object&apos; &amp;&amp; t !== &apos;function&apos;) throw TypeError();
    function f(){};
    f.prototype = p;
    return new f();
}
</code></pre><h2 id="三、属性的查询和设置"><a href="#三、属性的查询和设置" class="headerlink" title="三、属性的查询和设置"></a>三、属性的查询和设置</h2><p>我们要查询对象的属性时有两种方式：</p>
<p>1.是通过”.”:例如，o.name或者o.m(),来寻找属性或者方法；</p>
<p>2.通过[]来寻找或者设置：例如，o.[‘name’]，这里就要知道对象有时候也称为关联数组、散列或者字典；</p>
<p><strong>注意：</strong>JavaScript里面我们是不能通过第一种方式来改变属性名字的，因为我们不能改变一个标识符，不过我们能改变数据类型里的数据，而后一种方式就是数据类型里的字符串，是可以改变的。</p>
<p>既然谈到了属性那么我们得知道JavaScript的对象里面属性有自有属性和继承属性两种，继承属性则意味着这个属性不是自己独有的，是属于另外一个对象的，自己不过是使用了而已。</p>
<p>这里就先捋清原型、原型链、继承、类、对象之间的关系，其中原型和类再加上可扩展性是对象的3个属性。</p>
<p>我们先把一类东西，比如人给抽象出来，把人所具有的一般特征用属性和方法表示出来，意思就是一类人，对象的类属性用toString()返回的是一个字符串，表示的意思对象的类型信息。</p>
<p>原型与继承相关，这里就有涉及到了原型链，我们在查询对象o的属性时首先是到<br>对象的自有属性里查询，如果没有的话就到对象的原型里查询，再没有的话就到对象原型的原型里查询，一直到null为止，这么看来就有了一个链条的感觉。</p>
<p>如果是给属性赋值的话，失败的话，可能是属性为可读的但不可写，成功的话，就会有不同的答案了，要么创建一个属性，要么在原始对象中设置属性，例外的是如果o的属性是继承于属性x，而x属性是一个具有setter方法的accessor属性的话，就会有o直接调用setter方法，不会创建创建属性了，这个不会改变原型链。</p>
<p><strong>再谈谈setter和getter方法。</strong></p>
<p>对象是由属性名、属性值和一组特性组成，ES5中，属性值可以由一个或两个方法来代替，这两个方法就是getter方法和setter方法，由getter方法和setter方法定义的属性就是存取器属性（accessor property），不同于数据属性，存取器属性不具有可写性，要么是可读性要么是读/写性，也就是说如果只有setter方法的话，会返回的值是undefined。</p>
<p><strong>注意：定义存取器最简单的方法是采用对象的直接量语法的一种扩展写法</strong></p>
<p>形式：</p>
<pre><code>var o = {
    data_prop = value,
    get accessor_prop(){},//返回，这里是以逗号结尾的 
    set accessor_prop(value){}//设置
}
</code></pre><p>可用的地方是，我们可以传入一个值，然后返回一个不同的新值，这里就是数据双向绑定的最根本的开始喽！</p>
<p>权威指南上有个例子，在这里展示一下：2D笛卡尔点坐标</p>
<pre><code>var p = {
    //x,y均为普通的可读写的数据属性
    x：1.0，
    y:1.0,
    //r为可读写的存储器属性，它有setter和getter
    //函数体结束后不要忘了带上逗号
    get r(){
        return Math.sqrt(this.x*this.x + this.y*this.y);},
    set r(newValue){
        var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
        this.x *= ratio;
        this.y *= ratio;
    },
    //theta是只读存取器属性，只有getter方法
    get theta() { return Math.atan2(this.y,this.x);}
}
</code></pre><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1.属性访问错误</strong></p>
<p>同理既然是错误就是我们不想要的系统报错，两种方式：对象存在属性不在或者就是对象本身就不在</p>
<p><strong>2.删除属性</strong></p>
<p>只能删除自有属性，继承属性不能被删除，而delete运算符其实是断掉了属性与宿主的关系，对于属性中的属性则没有操作到，就是不是真正的删掉了属性，这个时候可能因为内存泄漏的原因，我们需要遍历属性中的属性，并删去</p>
<p>大家可以试试这个例子：</p>
<pre><code>var a = {p:{x:1}};
b = a.p;
delete a.p;
console.log(b.x);//结果依旧是1
//如果delete a.p.x来替代a.p的话，结果就是undefined了
</code></pre><p><strong>3.检测属性</strong></p>
<p>检测属性就用in运算符、hasOwnProperty()、propertyIsEnumerable(),这3种方式，in运算符返回的是布尔值，中间的大哥判断的是某个对象是否具有<strong>自有属性</strong>，最后的大哥是个加强版，自有属性还得可枚举性为真，这三者的返回值都是布尔值</p>
<p>for example：</p>
<pre><code>var o = { x:1 }
&apos;x&apos; in o;  //true
&apos;y&apos; in o;  //false
&apos;toString&apos; in o;//true,o继承toString属性
//看看用中间的大哥来检测的结果是什么
o.hasOwnProperty(&apos;x&apos;);//true,是自有属性
o.hasOwnProperty(&apos;y&apos;);//false,没有这个属性
o.hasOwnProperty(&apos;toString&apos;);//false,这个属性是继承得来的，不是自有的

//看看最后大哥的返回值及原因吧

var o = inherit({ y:2 });
o.x = 1;
o.propertyIsEnumerable(&apos;x&apos;);//true,o有一个可枚举的自有属性x
o.propertyIsEnumerable(&apos;y&apos;);//false,o的y属性是继承过来的
</code></pre><p>除此之外还可以通过非恒等式( !== )来判断一个属性值是不是undefined</p>
<pre><code>o.x !== undefined;//true
o.y !== undefined;//false
</code></pre><p>in运算符能区分不存在的属性和存在但值为undefined的属性</p>
<p><strong>4.可枚举性</strong></p>
<p>枚举属性，我们用到的是for/in，它可以枚举遍历对象中的自有属性和继承属性，但对象继承的内置方法不可枚举，添加的属性除非你转化为不可枚举，其他都是可枚举的。</p>
<p>for example:<br>    var o = {x:1,y:2,z:3};//3个可枚举的自有属性<br>    o.propertyIsEnumerable(‘toString’);//false,不可枚举<br>    for(p in o)<br>    console.log(p);</p>
<p>过滤的方法介绍：</p>
<pre><code>for(p in o) {
    if (!o.hasOwnProperty(p)) continue;//hasOwnProperty()是自有属性的检测，不是自有属性，那就是跳过继承的属性了
}

for(p in o) {
    if(typeof o[p] === &apos;function&apos;) continue;} //跳过方法，用的是数据类型的判断
</code></pre><p>用来枚举属性的对象的工具函数</p>
<p>for example：</p>
<p><strong>①.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，则覆盖o中的属性
 这个函数并不处理getter和setter以及复制属性*/

function extend(o,p) {
    for (prop in p) {   //遍历p中的所有属性
        o[prop] = p[prop]; //将属性添加到o中
    }
    return o;
}
</code></pre><p><strong>②.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，o中的属性则不会受到影响
 这个函数并不处理getter和setter以及复制属性*/

function merge(o,p) {
    for(prop in p) {  //遍历p中的所有属性
        if (o.hasOwnProperty[prop]) continue;//筛选掉p中已经存在的属性
        o[prop] = p[prop];将属性添加至o中
    }
    return o;
}
</code></pre><p><strong>③.</strong></p>
<pre><code>/*如果o中的属性和p中的属性没有同名的，则从o中删除这个属性
返回o*/

function restrict(o,p) {
    for(prop in o) {//遍历o中的所有属性
        if(!(prop in p)) delete o[prop];//如果在p中不存在，则删除它，这个删除还是遍历性的删除
    }
    return o;
}
</code></pre><p><strong>④.</strong></p>
<pre><code>/*如果o中的属性和p中的属性有同名的，则从o中删除这个属性
返回o*/

function subtract(o,p) {
    for (prop in p) {//遍历p中的所有属性
        delete o[prop];//把它删掉
    }
    return o;
}
</code></pre><p><strong>⑤.</strong></p>
<pre><code>/*返回一个数组，这个数组包含的是o中可枚举的自有属性的名字*/

function keys(o) {
    if(typeof o !== &apos;object&apos;) throw TypeError();//参数必须是对象
    var result = [];//将要返回的数组
    for (var prop in o) {//遍历所有的可枚举的属性
        if(o.hasOwnProperty(prop))//判断是否是自有属性
        result.push(prop);//将属性名添加到数组中
    }
    return result;//返回这个数组
}
</code></pre><p><strong>5.属性的特性</strong></p>
<p>一个属性包括1个名字和4个特性，数据属性这四个特性是：值(value)、可写性(writable)、可枚举性(enumerable)和可配置性(configurable)。而存取器属性不具有值和可写性的属性，具备的是读取(get)、写入(set)、可枚举性和可配置性。</p>
<p><strong>6.对象的三个属性</strong></p>
<p>每一个对象都有与之相关的原型(property)、类(class)和可扩展性(extensible)。</p>
<p><strong>①原型属性</strong></p>
<p>原型是用来实现继承属性的，原型也是个对象，在实例创建之初就已经设置好了</p>
<p>for example:</p>
<pre><code>var p = {x:1};//定义一个原型对象
var o = Object.create(p);//使用这个原型创建一个对象
p.isPropertyOf(o);//true，o继承p
Object.prototype.isPropertyOf(o);//true，p继承Object.prototype
</code></pre><p><strong>②类属性</strong></p>
<p>对象的类属性是一个字符串，用以表示对象的类型信息，我们只能通过间接的方式来查询它，默认的就是toString()方法，并返回字符串值。</p>
<p>for example：</p>
<pre><code>function classof(o) {
    if (o === null) return &apos;Null&apos;;
    if (o === undefined) return &apos;Undefined&apos;;
    return Object.prototype.toString.call(0).slice(8,-1);
}
</code></pre><p>classof函数可以传入任何参数，数字、字符串乃至布尔值都可以直接调用toString()方法。内置构造函数创建的对象和宿主对象都具有有意义的类属性，通过对象直接量和Object.create创建的对象的类属性是‘Object’，自定义的构造函数创建的对象也是如此，对于自定义的类来说，没办法通过类属性来区分对象的类。</p>
<p>for example：</p>
<pre><code>classof(null);
classof(1);
classof(&quot;&quot;);
classof(true);
classof([]);
classof(new Date());
function f() {};
classof(new f());//Object,这个是一定了
</code></pre><p><strong>③可扩展性</strong></p>
<p><strong>7.序列化对象</strong></p>
<p>对象序列化是指将对象的状态转化为字符串，也可以将字符串还原为对象，ES5提供了内置函数JSON.stringfy()和JSON.parse()来实现。</p>
<p>for example：</p>
<pre><code>var o = {x：1，y:{z:[false,null,&apos;&apos;]}};
s = JSON.stringfy(o);//o就成为了字符串
p = JSON.parse(s);//p是o的深拷贝
</code></pre><p><strong>8.对象方法</strong></p>
<p><strong>①toString()方法</strong></p>
<p>Array.toString()、Date.toString()等等，</p>
<pre><code>var s = {x:1,y:2}.toString();
</code></pre><p><strong>②toLocalString()方法</strong></p>
<p><strong>③toJSON</strong></p>
<p><strong>④valueOf()方法</strong></p>
<p>与toString()方法类似，但往往当JavaScript需要将对象转化为某种原始值而非字符串时才会用它，尤其是转换为数字的时候。</p>
<p>这一部分的知识就先到这里了，下一组是数组</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的数据类型]]></title>
      <url>/2017/05/18/JS-data-type/</url>
      <content type="html"><![CDATA[<p>JavaScript的数据是放在内存中的，而我们也知道数字、字符串等在内存中的存储方式、所占存储空间是不同的，分类就诞生了。JavaScript中的数据类型分为：基础数据类型（原始数据类型）、对象类型。</p>
<p>原始数据类型：<strong>数字（number）</strong>、<strong>字符串（string）</strong>、<strong>布尔值（Boolean）</strong>、<strong>null</strong>和<strong>undefined</strong>。</p>
<p>对象类型：<strong>Math（数字）</strong>、<strong>Date（日期）</strong>、<strong>Array（数组）</strong>、<strong>Function（函数）</strong>、<strong>RegExp（正则表达式）</strong>，这几种基础数据类型，先说第一个number吧！</p>
<h2 id="1-数字（number）"><a href="#1-数字（number）" class="headerlink" title="1.数字（number）"></a>1.数字（number）</h2><p>没啥意思，这个表示的就是数字，而数字中又分为整型和浮点型，就是整数和小数或分数。不好意思的是，JavaScript中没有具体的再区分它们两个，而是就用浮点型表示数字：1 == 1.0，这个是成立的。</p>
<p>运算符：+（加）、-（减）、*（乘）、/（除）、%（取余），运算也就是这个几个或者是几个的复合运算。</p>
<p>JavaScript数字的几个概念</p>
<p>无穷大（infinity），一个忒大的数字，出现了溢出（overflow），上溢出；</p>
<p>负无穷（-infinity），一个忒小的数字，出现了下溢出（underflow）；</p>
<p>除此之外，还有个中特别的存在就是非数字（not-a-number既NaN)，NaN是非数字的意思，情况有几种：无穷大除以无穷大、负数开平方、非数字或者不能获得数字的运算符进行了运算，这几种情况都是出现NaN。</p>
<p>NaN是个孤独的游魂，他没有伙伴，我们只能证明一个值不是NaN，而不能证明一个值是NaN，表达式是：</p>
<p> x != NaN,不能写作 x == NaN(后者是个错误的存在)。</p>
<p>上面的仅仅是数字的相关知识，还有Math对象对于数字的操作运算，这个下次再做分析。</p>
<h2 id="2-字符串（string）"><a href="#2-字符串（string）" class="headerlink" title="2.字符串（string）"></a>2.字符串（string）</h2><p>字符串就是个有次数的不可改变的16位值的序列，字符串的表现形式就是把值放到单引号’’或者双引号””里面，或者是个空值也可以。</p>
<p>因为JavaScript是用UTF-16编码的Unicode字符集，所以JavaScript的所有字符都是16位的。次序就是在字符串中相同字符也是有不同的索引的，不可改变就从字符串的所有方法看吧！</p>
<p>方法一是获取相关值</p>
<p>s.charAt();//用数字获取相关位置的值，因此里面填的是数字</p>
<p>s.substring(a,b);//两个数字，包前不包后</p>
<p>s.slice(a,b)；//同上</p>
<p>s.indexOf();//里面的字符串值，出现的就是这个字符的首次出现的位置的索引</p>
<p>s.lastIndexOf();//方法类似于上面</p>
<p>s.split();//以什么作为分割点</p>
<p>s.replace();//两个字符，前面的用后面的值来代替</p>
<p>s.toUpperCase();//变为大写</p>
<p>下面就用代码来实现一下，证实一下原字符串是不是不可改变的：</p>
<pre><code>var s = &quot;hello world&quot;;

console.log(s.indexOf(&apos;o&apos;));
console.log(s.lastIndexOf(&apos;o&apos;));
console.log(s.charAt(2));
console.log(s.toUpperCase());
console.log(s.substring(0,3));//同样是包前不包后
console.log(s.slice(2));//包前不包后，因为2后面没有结尾意思就是到最后
console.log(s.replace(&apos;w&apos;,&apos;W&apos;));
console.log(s.split(&apos;v&apos;));//这个就是字符串里没有的话，可以说是没有用的
console.log(s.split(&apos; &apos;));
</code></pre><h2 id="3-布尔值（boolean）"><a href="#3-布尔值（boolean）" class="headerlink" title="3.布尔值（boolean）"></a>3.布尔值（boolean）</h2><p>布尔值代表的意思是真或假、开或关、是或否，多用于控制结构的比较语句中，这个类型只有两个值：true、false。</p>
<p>JavaScript中的任意值都能转换成布尔值，下面的这些值能转换成false：undefined、null、0、-0、””(空字符串)、NaN，所有其他值包括对象（数组）则被转换成true。</p>
<p>用个例子：声明个变量o,<strong>if(o ！== null)</strong>再有一个<strong>if(o)</strong>,前个例子是证明变量o是不是null值，不是的话会执行下去，后一个变量是意思是为真（o不是false、null和undefined）的时候会执行下去。</p>
<p>关于布尔值的在有的话就是运算符的运用了！AND（&amp;&amp;）、OR（||）、非（NOT既！）。</p>
<h2 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a>4.null和undefined</h2><p>null就是程序级别的，不是系统报错报出来的，是我们可以写出来的，我们可以写作参数的；undefined是系统报错的，我们不期望遇到，遇到的原因大概有三：</p>
<p>①我们声明了变量，但是没有给变量赋值</p>
<p>如：    </p>
<pre><code>var a;

console.log(a);//这里打印出来的就是undefined
</code></pre><p>②参数的形式参数的引用了却没有实参</p>
<p>如：</p>
<pre><code> function a (b,c,d){

    console.log(b + c);

    console.log(d);//这里打印出来的就是undefined
  }

a(1,0);
</code></pre><p>好玩的是如果console.log(b + c + d);这里打印出来的值是NaN，你想想一个数字加undefined，结果就是NaN。</p>
<p>③再有一个现象就是对象里，我们有3个值，你非要找第四个值，那是没有了，只会报出undefined。</p>
<p>为了避免出现undefined的现象，我们一定要注意几个原因，声明变量的时候，</p>
<p>如：newHtml = “”;//不要只声明了不初始化值。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo中域名的配置]]></title>
      <url>/2017/05/16/my-domain/</url>
      <content type="html"><![CDATA[<p>这个时候，你的.io的github网站是可以使用的了，接下来就是怎么使用自己的域名去搞定一切了！OK,我们开始吧！</p>
<p><a href="http://www.szhot.com/" target="_blank" rel="external">http://www.szhot.com/</a>我的是在万维网申请的，在万维网你要做几件事：</p>
<p>1.申请一个域名，花多少钱，就看你自己个了！这一步就是给自己的网站起了个名字。</p>
<p>2.购买一个虚拟主机，花多少钱看你自己，有了名字但没有IP地址，就是服务器端没有你的空间，这一步就是在服务器端有个你的位置。</p>
<p>3.OK！为了顺利完成工作，你还要做：</p>
<p>①</p>
<p><img src="/image/www.png" alt=""></p>
<p>切记这三部分是必须完成的，光标点亮后才能进行下一步的工作；</p>
<p>②身份证正反面复印件，必须在一面上，还要有你的签名，按要求做吧；</p>
<p>③</p>
<p><img src="/image/kwww2.jpg" alt=""></p>
<p>这里还有一步关键，在你的E:\blog\source里，就是你的文件路径里配置个CNAME文件，没有后缀，在里面写上你的域名（不加www的域名）。这个下面就要用到了。</p>
<p><strong>按这个步骤进行操作</strong>圈子里的我们改成这个样子的，不要会错了意！！！</p>
<p>把这个搞好后就开始进行在dnspod上的修改，选择dnspod的原因是稳定！<a href="https://www.dnspod.cn/" target="_blank" rel="external">https://www.dnspod.cn/</a></p>
<p>修改的地方在哪里呢？请看：</p>
<p><img src="/image/www3.png" alt=""></p>
<p>在域名解析里，这个域名是我添加进来了，你要添加进来，点击进来</p>
<p><img src="/image/www4.png" alt=""></p>
<p>圈子里的是你照搬的，这个是github的IP地址，不用的话是找不到你的网页的。<br>而最下面的主机记录:www,记录类型:CNAME,记录值是你的github网址，OK了！<br>一切准备就绪！千万记得，hexo g和hexo d命令，把你的修改给布置到页面上来！</p>
<p>欢迎大家来践踏我的博文<a href="mashuaiqi.com">mashuaiqi.com</a>，，，，欢迎！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[markdownpad快捷键分享]]></title>
      <url>/2017/05/15/markdownpad/</url>
      <content type="html"><![CDATA[<p>Markdownpad是你编写博客的利器，使用的时候你可以用鼠标去为句子或者词语加粗、加链接、加图片等，但是快捷键的魅力之处就是一个词—快，快的不要不要的。</p>
<p><strong>Ctrl + I ： 斜体</strong></p>
<p><strong>Ctrl + B ： 粗体</strong></p>
<p><strong>Ctrl + G ： 图片</strong></p>
<p><strong>Ctrl + Q ： 引用</strong></p>
<p><strong>Ctrl + 1 ： 标题 1</strong></p>
<p><strong>Ctrl + 2 ： 标题 2</strong></p>
<p><strong>Ctrl + 3 ： 标题 3</strong></p>
<p><strong>Ctrl + K ： 代码块</strong></p>
<p><strong>Ctrl + L ： 超链接</strong></p>
<p><strong>Ctrl + T ： 时间戳</strong></p>
<p><strong>Ctrl + U ： 无序列表</strong></p>
<p><strong>Ctrl + R ： 水平标尺</strong></p>
<p><strong>F4 ： 启用水平布局</strong></p>
<p><strong>F5 ： 启用实时预览</strong></p>
<p><strong>F6 ： 在浏览器中预览</strong></p>
<p><strong>Ctrl + Shift + O ： 有序列表</strong></p>
<p>Ok！大家如果有更好的好玩的工具，分享给我哟！谢谢你们了！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript 诞生记]]></title>
      <url>/2017/05/13/javascript-txt/</url>
      <content type="html"><![CDATA[<p><strong>十八世纪英国文学家约翰逊博士对JavaScript说过一句很好的话，它的优秀之处并非原创，它的原创之处并不优秀。</strong></p>
<p>多么牛叉的一句话啊！那为什么这么说呢？我们看看JavaScript是怎么诞生的。</p>
<p>1994年，网景公司发布了第一个比较成熟的网络浏览器，但它仅仅支持浏览文件，就是你只能看，不能进行页面之间的互动，多么尴尬啊！Netscape需要一种网页脚本语言，使得网页之间通过浏览器进行互动。</p>
<p>那到底选择哪种语言呢？公司众说纷纭，选择现有的语言，如：Scheme、Python等，有现有的代码和程序员；不然的话，就发明一种更好的新语言。</p>
<p>这个时候公司招聘进来一个哥们–Brendan  Eich，他对函数式编程很感兴趣，公司招聘他的目的就是研究将Scheme作为网页脚本语言的可能性。这个时候Java是很火爆的，网景管理层也煞是迷恋。后来，网景公司有个决定，这个将要诞生的网页脚本语言必须与Java足够相似，使得非专业者也能很快上手。</p>
<p>既然有了要求就开始做个筛选吧！Java是面向对象编程的，而已经存在的语言，如：Perl、Python、Tcl、Scheme，它们是非面向对象的，因此他们自然就被排除在外了。作为简化版的Java语言的设计师—Brendan  Eich反而对Java不感冒。</p>
<p>这兄弟就开始一顿乱搞了，七拼八凑的，10天就把JavaScript给造出来了。</p>
<p>他的设计思路是：</p>
<ol>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Java的数据类型和内存管理；</strong></li>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Self语言，使用基于原型（prototype）的继承机制，对象就随之出现；</strong></li>
</ol>
<p>综上知：<strong>JavaScript = 简化的函数式编程 + 面向对象编程</strong>，这是多么愉快的决定啊！把Java作为JavaScript的设计原型，这是公司的决定，在既圆了公司管理层的决定，又有自己的决定在里面，这个东西本来就是一种迎合公司和自己的杂合物。</p>
<p>在结束的时候回味一下约翰逊博士的话，应该能有所体悟吧！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象方法]]></title>
      <url>/2017/04/27/oop/</url>
      <content type="html"><![CDATA[<h2 id="一、-面向对象方法出现的原因"><a href="#一、-面向对象方法出现的原因" class="headerlink" title="一、 面向对象方法出现的原因"></a>一、 面向对象方法出现的原因</h2><p>传统软件工程方法的确给软件产业带来了巨大进步，但它仅在中小规模软件开发中获得了好成绩，在大型的软件开发中很少取得成功。因此，后来面向对象技术得到了开发者的青睐。</p>
<h2 id="二、-面向对象方法的4个要点"><a href="#二、-面向对象方法的4个要点" class="headerlink" title="二、 面向对象方法的4个要点"></a>二、 面向对象方法的4个要点</h2><p><strong>1.</strong>树立对象意识，客观世界是有各种对象组成的，复杂的对象由简单的对象组成。因此，面向对象的软件系统是由对象组成的，软件中的任何元素都是对象，复杂的对象由简单的对象组成。与传统方法的区别是用对象分解代替了其功能分解。</p>
<p><strong>2.</strong>把所有对象划分为各种对象类，每个类都定义了一组数据和方法。数据用于表示数据的静态属性，乃对象的静态属性，每当建立一个对象类的实例时，就按照对象类中对数据的定义，生成一组专用的数据。例如，荧光屏上不同位置显示的半径各不相同的圆，虽然都是Circle类的对象，但都有自己的专属数据，以便记录各自的圆心位置、半径等。</p>
<p>类中定义的方法，是允许施加于该类对象上的操作，是该类所有对象共享的，并不需要为每个对象都复制操作的代码。因为过程是一样的或是类似的，我们把操作的流程（操作）给定义下来，就是一条流水线生产多种产品了。</p>
<p><strong>3.</strong>按照子类与父类的关系，把若干对象类组成一个系统，下层的类与上层类的特性相同，这就是一种继承现象。同时也得晓得底层的类能屏蔽高层类的同名特性。</p>
<p><strong>4.</strong>对象彼此之间仅能通过传递信息相互联系。这里也与传统方法的数据有本质的区别，它不是被动的等待外界世界对它施加操作，相反的是，它是进行操作的主体，不能直接从外部世界修改它的私有数据，所有的私有数据都是封装在对象类中，这就是封装性。</p>
<h2 id="三、-面向对象方法的优点"><a href="#三、-面向对象方法的优点" class="headerlink" title="三、 面向对象方法的优点"></a>三、 面向对象方法的优点</h2><p><strong>1.</strong>符合人类的思维特点</p>
<p>抽象为一般的特点，然后再说一个个个例的不同之处。例如，我们说动物，我们会把具有某些相似特征的生物划分为动物，ok！有了动物，那么我们还要更加细化，则在根据某些特征抽象出来，比如把人从动物里就可以抽象出来。</p>
<p><strong>2.</strong>稳定性好</p>
<p>功能发生改变，在传统方法里，因为功能分析和功能分解，如果功能需求发生改变，改变的是整个软件结构，这个量很大的。相反，在面向对象方法里，仅仅通过修改局部方法就可以，不必修改全部。</p>
<p><strong>3.</strong>可重用性好</p>
<p>可以用旧的零件做新的产品，重复使用一个对象类，创建新的实例或者在对象类里增加数据和方法，都是不影响原来的使用。</p>
<p><strong>4.</strong>容易开发大型的软件</p>
<p>原因就是，把大的软件产品分解为许多相互独立的小个体，技术难度降低、开发管理更容易。</p>
<p><strong>5.</strong>可维护性好</p>
<p>面向对象方法开发的软件稳定性好、易于修改、容易理解更加易于测试，总体就突出了它的可维护性好的特点。</p>
<h2 id="四、-面向对象的概念介绍"><a href="#四、-面向对象的概念介绍" class="headerlink" title="四、 面向对象的概念介绍"></a>四、 面向对象的概念介绍</h2><p><strong>1.</strong>说说对象的特点</p>
<p>①以数据为中心。因为数据是对象数据结构的一部分，是它的状态。</p>
<p>②本质上具有并行性。不同对象各自独立处理自身数据，彼此通过发送消息传递信息完成通信。因此，具有并行工作的属性。</p>
<p>③模块独立性好。模块与对象的关系，对象本身就是面向对象的软件的基本模块，模块讲究的内聚性和耦合性在对象上能充分体现出来。因为对象的数据和属性是在一个对象类里面的，操作也是在这里面的，作为一个基本的模块单元，它的内聚性很高。也因为这个原因，对象之间的关联很小，它们之间的耦合性很宽松。</p>
<p><strong>2.</strong>其他的相关概念</p>
<p>①类（class）</p>
<p>古语讲，物以类聚，这个“类”说的也是某些特点的在一起，抽象出来了一群人。类是支持继承的抽象数据类型，而对象是类的实例。</p>
<p>②实例（instance）</p>
<p>实例就是类的个体化</p>
<p>③消息（message）</p>
<p>把消息传递进去就有个不同的实例</p>
<p>④方法（method）</p>
<p>对象所能执行的操作，能做什么事情</p>
<p>⑤属性（attribute）</p>
<p>类中定义圆的大小、半径、颜色就是对象的属性，就是对象的特点</p>
<p>⑥封装（encapsulation）</p>
<p>字面上说就是把一个事物包起来，使外界不知道该事物的具体内容，面向对象方法中，把表示对象状态的数据和对数据的操作放到对象内部，只把接口提供出来。因此，它有个清晰的边界，外界是看不到内部的；再有就是有确定的接口，这些接口就是对象能接受的消息，只能向对象发送消息使用它；受保护的内部实现。</p>
<p>⑦继承（inheritance）</p>
<p>广义地说，继承就是直接使用已有的性质和特征，而不必重复定义他们。一个类可以有自己的父类和子类，这就一定具有继承的特性，一个类直接继承其父类的全部描述（数据和操作）。</p>
<p>OK！基本知识就到此了，不充足的会再补充。。。。。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[模块]]></title>
      <url>/2017/04/27/module-1/</url>
      <content type="html"><![CDATA[<p>在开发阶段里总体设计的过程中，我们必须明确系统是“怎么做事情”的了。在软件的设计过程中有些原理和概念是我们必须遵循的，这就是与<strong>模块</strong>有关的知识了！</p>
<h1 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1.模块化"></a>1.模块化</h1><p>先说个有意思的规律：C(x) 定义问题X的复杂程度，函数E(x)定义解决X问题所需要的工作量。对于问题P1和P2，如果</p>
<pre><code>C(P1) &gt; C(P2)
</code></pre><p> 显然       </p>
<pre><code>E(P1) &gt; E(P2)
</code></pre><p>根据人类解决问题的一般经验，一个有意思的规律就是</p>
<pre><code>C(P1+P2) &gt; C(P1)+C(P2)
</code></pre><p>因此也就有了</p>
<pre><code>E(P1+P2) &gt; E(P1)+E(P2)
</code></pre><p>结论是什么呢？就是把复杂的问题给分解成容易解决的小问题，那么大问题就迎刃而解，这是模块化的根据。</p>
<p>这就有个有意思的问题了，无限的分割软件，最后开发软件的工作量确实小的很多了。但模块间的接口的设计就在增多，你去脑洞吧，一个在减少工作量，一个在增加工作量，那模块量多少才是合适？（既是设计模块和模块接口的工作量合适，成本也合适），这个问题再说了！</p>
<h1 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2.抽象"></a>2.抽象</h1><p>抽象是现实世界的事物、状态、过程等相似方面的集中和概括，暂时忽略他们之间的差异，模块就是把抽象出来的某个层次用一定的方式描述出来。因为抽象是一层一层的，因此模块也是有其特点的。</p>
<h1 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3.逐步求精"></a>3.逐步求精</h1><p>人类认知过程中遵循个Miller法则：一个人在任何时候都只能把注意力集中到[5 9]个知识块上。</p>
<p>因此，在抽象的过程中，有了不同的层次，不同的模块，那么就有了模块的不断地精化。</p>
<h1 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4.信息隐藏和局部化"></a>4.信息隐藏和局部化</h1><p>这里隐藏的不是有关模块的所有信息，而是模块之间还要交换那些为了完成系统功能而必须交换的信息，当然是仅仅交换这些信息。模块本身就体现了这一特质。</p>
<h1 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5.模块独立"></a>5.模块独立</h1><p>模块的独立是模块化、抽象、信息隐藏和局部化的直接结果。既容易开发又容易测试是模块独立的好处，然而模块之间还是要通信的，那评价模块独立的标准又是是什么呢？<strong>内聚</strong> 和<strong>耦合</strong>。</p>
<p><strong>内聚</strong></p>
<p>内聚说的是一个模块内的事情，从一个最底层的模块说会更容易理解，既然“大家伙”（模块内的各个元素）都是一个“团队”（模块）了，那么我们就要力向一处使（做好一件事情），也就是说模块里的兄弟姐妹们都是与这件事情极其相关的。所以说内聚就是说模块内的元素关系密切，不然放一块干嘛！同理就是模块的设计时，尽量做到模块内的元素关系密切，这才符合模块间的信息隐藏和局部化。</p>
<p><strong>耦合</strong></p>
<p>有了内聚做参考就知道了既然能做同一件事或者相关事情的元素都放到一块去了（成为了一个模块），那么模块之间的关系就是松散的耦合关系喽！因为模块之间不可能做到一点关系都没有，是吧？做到松散耦合就OK了！</p>
<p>好了！以上就是关于模块的理论知识，以后在碰到关于模块的问题时不至于会一脸懵逼吧，，，</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[软件工程方法学（番外篇）]]></title>
      <url>/2017/04/27/module-knowlage1/</url>
      <content type="html"><![CDATA[<p>本篇的主题讲述的是<a href="module-1.md"><strong>模块</strong></a>和<a href="oop.md"><strong>面向对象方法学</strong></a>，这篇番外篇讲的就是“主人公”的生活大环境，内容是下面3方面，“主人公”出现在软件工程的哪个位置、出现的原因、解决了什么问题，主要是这几个方面。</p>
<p>在计算机系统发展历史中，开发软件的错误方法和观念导致了软件危机的出现。为了计算机系统的进一步发展，就逐步发展和完善了软件工程学科。</p>
<p>软件工程方法是软件工程的技术方面的内容，软件工程使用的最广泛的是：<strong>传统方法</strong>和<strong>面向对象方法</strong>。</p>
<p><strong>一、传统方法</strong></p>
<p>又叫做生命周期方法学或者结构化范型，它是把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务。OK！你看到了生命周期，它的意思是一个软件从定义、开发、使用和维护，直到被废弃，经历的漫长时期，就类似于一个人的出生、婴儿、童年、青年、中年和老年，直到死亡的漫长期限。</p>
<p>它的阶段有哪些呢？</p>
<p><img src="/image/tra.jpg" alt=""></p>
<p>看到了<a href="module-1.md"><strong>模块</strong></a>思想开始应用的阶段（开发阶段里的总体设计）了吧！当然既然是思想，可以用到的地方必然很多了，在模块化专章里我们具体的讲讲关于它的知识。</p>
<p><strong>二、面向对象方法</strong></p>
<p>对于面向对象方法学，这次就说一个方程就行了：</p>
<h1 id="OO-objects-classes-inheritance-communication-with-messages"><a href="#OO-objects-classes-inheritance-communication-with-messages" class="headerlink" title="OO = objects + classes + inheritance + communication with messages"></a>OO = objects + classes + inheritance + communication with messages</h1><p>意思就是：面向对象就是既使用对象又使用类和继承等机制，而且对象之间仅能通过传递消息实现彼此通信。</p>
<p>OK！下次细细讲解模块化和面向对象方法。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[个人简历]]></title>
      <url>/2017/04/26/resume/</url>
      <content type="html"><![CDATA[<p><strong>姓名：</strong>马帅旗       </p>
<p><strong>籍贯：</strong>河南商丘 </p>
<p><strong>职业：</strong>人生工程师</p>
<p><strong>技能：</strong>精通HTML、CSS、JS 等</p>
<p><strong>座右铭：</strong>爱计算机的工商管理专业兄弟！没事咱们也可以一起聊聊马刺或者一起来个长途骑行！  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[sublime设置自己的浏览器方法]]></title>
      <url>/2017/04/26/sublime/</url>
      <content type="html"><![CDATA[<p>sublime 中，有个默认的浏览器，就是你鼠标右键点击后出现的，我的是sublime Text 3 </p>
<p><img src="/image/s.png" alt=""></p>
<p>这里的红色部分的Open in brower 就是你的默认浏览器，我的事默认浏览器是IE，当然我想在Chrome里看看效果，并调试一下，怎么设置呢？</p>
<p>点击深绿色的Preferences栏</p>
<p><img src="/image/s2.png" alt=""></p>
<p>看到了Key Bindings 点进去进到如下界面：</p>
<p><img src="/image/s3.png" alt=""></p>
<p>你的是没有红色部分及下面的内容的，这里就是我自己设置的了，你就直接把我的代码放进去就可以了，你能 <strong>随意改</strong> 的是 keys这里的快捷键，再有就是application里的内容，你是要必须改的，换成你的浏览器位置的路径</p>
<p><img src="/image/s4.png" alt=""></p>
<p><strong>注意：</strong>这里的斜杠是怎么写的一定要注意</p>
<p>你要用的代码：<br>//chorme</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f6&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Users\\asus\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>},<br>//Firefox</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f7&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>}</p>
<p>到了这一步了，你可能会说，我怎么获得我的浏览器的位置呢，ok！在你的桌面上<strong>把鼠标悬浮到你要设置的浏览器上，并点击右键</strong>，会有# <strong>打开文件所在的位置</strong> #这个命令，点击进去，会到这个页面</p>
<p><img src="/image/s5.png" alt=""></p>
<p>找到了，点击上面红色的路径，粘贴到application里去，记得加上后面的chrome.exe，这样就设置好了，以后用的时候直接用快捷键就行了</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建博客（二）]]></title>
      <url>/2017/04/26/hexo2/</url>
      <content type="html"><![CDATA[<p>上次说到会用网址访问页面，细想了一下，你只要能按我发的那个链接走的话就能很好的出现效果，下面就说说一些必要的注意事项。</p>
<p>1.下载Markdownpad,<a href="http://markdownpad.com/" target="_blank" rel="external">http://markdownpad.com/</a>，这里在windows10里会有个小问题，需要配置个什么小玩意，你自己去搞定啦！</p>
<p>再有就是下载个Notepad++，<a href="https://notepad-plus-plus.org/" target="_blank" rel="external">https://notepad-plus-plus.org/</a>，目的是避免以后你编辑的东西会因为字符集的问题而不能正常使用</p>
<p>2.下载完成后，就按链接里前辈的路子走吧！以下几个命令是常用的，它们执行后的样子是啥样的</p>
<p><strong>hexo g</strong> ##目的是把你修改的东西变成静态文件，每次修改后都要在Git里执行一次这个命令，成功的样子是</p>
<p><img src="/image/12.png" alt=""></p>
<p><strong>hexo s</strong> ##启动服务器，当你想在把东西放到网页上前检查一下的时候用</p>
<p><img src="/image/13.png" alt=""></p>
<p>localhost:4000在这个时候使用，要执行其他的命令就要用Ctrl+C快捷键停止这一步</p>
<p><strong>hexo d</strong> ##把文件部署到github,这一步有意思的东西多，部署成功的标志是，命令执行完后，成功标志</p>
<p><img src="/image/14.png" alt=""></p>
<p>其他的均属未成功，解决方案：重新登录github网站，能进去的话，就把你所遇到的问题粘贴到网上搜索答案，不能进去的话，一个方法就是等到能进去的时候在执行这个命令。</p>
<p>3.主题的配置，当你把Hexo下载完后，是一个默认的主题，后面的主题，你就可以自己去选择了，你可以选择和前辈一样的主题，也可以自己寻找实验，找到更适合你的，安装方法就是去看主题制作者的Readme里面有详细的步骤</p>
<p><strong>注：</strong>有什么不会的我们可以共同讨论，这个主题就先到这里了</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客（一）]]></title>
      <url>/2017/04/23/myblog/</url>
      <content type="html"><![CDATA[<p><strong>你目前看到的这个博客就是我才搭建好的属于我自己的简易窝棚，搭建过程中虽然是看着前辈的流程走的，但不得不说我还是踩了很多坑的，好了接下来我向大家说说我的踩坑经历吧！</strong>你也可以参考其他前辈的过程，不过，记住一定要以一个的过程为主，我参考的是<a href="http://tengj.top/2016/02/22/hexo1/" target="_blank" rel="external">http://tengj.top/2016/02/22/hexo1/</a></p>
<ol>
<li>先下载必备的东西Git，通过它把文件托管到本地和github上，必须下载，<a href="https://git-scm.com" title="下载地址" target="_blank" rel="external">https://git-scm.com</a>。<br><img src="/image/g.png" alt="">,右下角的这个位置，注意：电脑系统版本</li>
<li>下载Nodejs去，同样是官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>，<img src="/image/g2.png" alt="最好是最新版本的"></li>
<li>工具已经准备完成，下面就开始操刀吧！</li>
</ol>
<p><strong>首先</strong>，安装Hexo，这里安装的时候可以在nodejs里安装，也可以在Git里安装：</p>
<p>nodejs里：<strong>npm install -g hexo</strong> 或者<strong>npm install hexo-cli -g</strong></p>
<p><img src="/image/nodejs.png" alt=""><br>检测安装成功与否，用<strong>hexo -v</strong> ,出现版本号说明成功</p>
<p>Git里的执行命令是一样的，注意：应该在Git Bash Here里执行同样命令</p>
<p><strong>第二步</strong>，在你建立的blog文件夹下，点击右键出现如下<img src="/image/git.png" alt=""> </p>
<p>执行命令 <strong>hexo init</strong> 自动在目标文件夹建立网站所需要的所有文件。</p>
<p>然后执行<strong>npm install</strong> 安装依赖包<br><strong>第三步</strong>，这一步就是验证以上的操作效果如何了，先执行<strong>hexo g</strong>,这是用于生成静态文件，再执行<strong>hexo s</strong>，这是启动服务器，<img src="img/dis.png" alt="">,执行之后就按图片去看看默认的效果吧！<img src="/image/re.png" alt="">,出现这个效果就完成了初步目的</p>
<p>最后，我们应该知道我们访问的东西是用localhost:4000访问得到的，下一步我们就用域名来获得这个页面，明天见！</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
