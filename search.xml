<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Web浏览器中的JavaScript]]></title>
      <url>/2017/07/18/client-JavaScript/</url>
      <content type="html"><![CDATA[<p>前一部分介绍了JavaScript语言核心，这一部分转向Web浏览器中JavaScript的实现。web浏览器是如何呈现页面的呢？一些呈现静态信息的页面叫做文档(加入JavaScript会有动态的效果但是信息本身是静态的，不过页面可以动态的载入信息)。下面会说到JavaScript代码是如何在HTML文档中嵌入并执行的，还会介绍兼容性、可访问性和安全性等问题。</p>
<h3 id="一、客户端JavaScript"><a href="#一、客户端JavaScript" class="headerlink" title="一、客户端JavaScript"></a>一、客户端JavaScript</h3><p>Window对象是所有客户端JavaScript特性和API的主要接入点。Window对象定义了一些属性，指代Location对象的location属性，Location对象指定当前显示在窗口里载入新的URL。</p>
<pre><code>//设置location属性，从而跳转到新的web页面
window.location = &quot;http://www.oreilly.com/&quot;;
</code></pre><p>Window对象还定义了一些方法，比如alert()方法，还有setTimeout()，可以注册一个函数，在给定的一段时间后触发一个回调：</p>
<pre><code>//等待两秒，然后说 hello
setTimeout(function() {alert(&quot;hello JavaScript!&quot;);},2000);
</code></pre><p>客户端JavaScript中，Window对象也是全局对象，Window对象处于作用域的顶端，它的属性和方法实际上是全局变量和全局函数。Window对象有一个引用自身属性叫做window。</p>
<p>Window对象有一个最重要的属性是document，它引用Document对象，后者表示显示在窗口中的文档。Document对象有一些重要方法，比如getElementById(),可以基于元素id属性的值返回单一的文档元素：</p>
<pre><code>//查找 id = &quot;timestamp&quot;的元素
var timestamp = document.getElementById(&quot;timestamp&quot;);
</code></pre><p>getElementById()返回的Element对象有其他重要的属性和方法，比如允许脚本获取它的内容，设置属性值等：</p>
<pre><code>//如果元素为空，往里面插入当前的日期和时间
if(timestamp.firstChild == null)
    timestamp.appendChild(document.createTextNode(new Date().toString()));
</code></pre><p>每个Element对象都有style和className属性，允许脚本指定文档元素的CSS样式，或者修改应用元素上的CSS类名。设置这些CSS相关属性会改变文档元素的呈现：</p>
<pre><code>//显示修改目标元素的呈现
timestamp.style.backgroundColor = &quot;yellow&quot;;

//或者只改变类，让样式表指定具体内容
timestamp.className = &quot;highlight&quot;;
</code></pre><p>事件处理程序可以让JavaScript代码修改窗口、文档和组成文档的元素的行为。事件处理程序的属性名是以单词“on”开始的：</p>
<pre><code>//当用户单机timestamp元素时，更新它的内容
timestamp.onclick = function () {this .innerHTML = new Date().toString();}

//显示内容的简单客户端JavaScript：
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
.reveal*{display:none;}
.reveal *.handle{display:block;}&lt;!...除了这个handle的元素...&gt;
&lt;/style&gt;

&lt;script&gt;
window.onload = function() {
    var elements = document.getElementsByName(&quot;reveal&quot;);
    for (var i = 0;i &lt; elements.length;i++) {
        var elt = elements[i];
        var title = elt.getElementsByName(&quot;handle&quot;)[0];
        addRevealHandler(title,elt);
        function addRevealHandler(title,elt) {
            title.onclick = function () {
                if(elt.className == &quot;reveal&quot;)
                    elt.calssName = &quot;ravealed&quot;;
                else if (elt.className == &quot;revealed&quot;)
                    elt.className = &quot;reveal&quot;;
            }
        }
    }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;reveal&quot;&gt;
&lt;h1 class=&quot;handle&quot;&gt; Click Here to Reveal Hidden Text&lt;/h1&gt;
&lt;p&gt;This paragraph is hidden.It appears when you click on the title.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="1、web文档里的JavaScript"><a href="#1、web文档里的JavaScript" class="headerlink" title="1、web文档里的JavaScript"></a>1、web文档里的JavaScript</h4><p>用户的体验不应该依赖于JavaScript，但它却可以增强用户体验，通过如下的方式来实现：</p>
<p>》创建动画和其他视觉效果，巧妙的引导和帮助用户进行页面导航。</p>
<p>》对表格的列进行分组，让用户更容易找到所需要的。</p>
<p>》隐藏某些内容，当用户“深入”到内容里时，在逐渐展示详细信息。</p>
<p>Web浏览器是简单操作系统的概念，这样就可以把Web应用定义为用JavaScript访问更多浏览器提供的高级服务(比如网络、图像和数据存储)的页面。高级服务里最有名的是XMLHttpRequest对象，后者可以对HTTP请求编程来启用网络。Web应用使用这个服务从服务器获取新信息，而不用重新载入页面，达到局部刷新的效果。</p>
<h3 id="二、在HTML里嵌入JavaScript"><a href="#二、在HTML里嵌入JavaScript" class="headerlink" title="二、在HTML里嵌入JavaScript"></a>二、在HTML里嵌入JavaScript</h3><p>嵌入到HTML文档里共有4种方式：</p>
<p>《 内联，放置在<code>&lt;script&gt;&lt;/script&gt;</code>之间。</p>
<p>《 放置在由<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</p>
<p>《放置在HTML事件处理程序中，该事件处理程序由onclick或者onmouseover这样的HTML属性值指定。</p>
<p>《放在一个URL里，这个URL使用特殊的“javascript”协议。</p>
<p>嵌入到HTML文档里方法总共是这几种，但是我们常用的是第二种，达到了表现形式与行为的分离的目的。</p>
<pre><code>//这是个简单的JavaScript数字时钟程序
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;
Digital Clock
&lt;/title&gt;
&lt;script&gt;
//定义一个函数用以显示当前的时间
function displayTime() {
    var elt = document.getElementById(&quot;clock&quot;);
    var now = new Date();
    elt.innerHTML = now.toLocaleTimeString();
    setTimeout(displayTime,1000);
}
window.onload = displayTime;
&lt;/script&gt;
&lt;style&gt;
#clock {
    font:bold 24pt sans;
    background:#ddf;
    padding:10px;
    border:solid black 2px;
    border-radius:10px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Digital Clock&lt;/h1&gt;
&lt;span id=&quot;clock&quot;&gt;&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>其他的引入方式这里不再做介绍，下面我们仅仅说一下外部文件中的脚本：</p>
<pre><code>&lt;script src=&quot;../../scripts/util.js&quot;&gt;&lt;/script&gt;//相对路径
</code></pre><h3 id="三、JavaScript程序的执行"><a href="#三、JavaScript程序的执行" class="headerlink" title="三、JavaScript程序的执行"></a>三、JavaScript程序的执行</h3><p>JavaScript程序的执行有2个阶段：</p>
<p>第一阶段，载入文档内容，并执行<code>&lt;script&gt;</code>元素里的代码(包括内联的和外部脚本)。脚本通常会按它们在文档中出现的顺序执行。所有脚本里的JavaScript代码都是从上到下，按照它在条件、循环以及其他控制语句中的出现顺序执行。这个阶段是JavaScript代码自己的执行阶段，不参与与HTML文档的互动工作。</p>
<p>当文档载入完成，并且所有的脚本执行完成后，JavaScript就进入它的第二阶段。这个阶段是异步的，而且由事件驱动。在事件驱动阶段，Web浏览器调用事件处理程序函数(第一阶段里执行的脚本指定的HTML事件处理程序)，来响应异步发生的事件。这个阶段就是JavaScript代码与HTML文档的互动，不过这里面由事件驱动罢了！</p>
<p>事件驱动阶段发生的第一个事件是load事件，这是说明文档加载完成。因为JavaScript代码的执行是单线程的，所以这两个阶段的执行在同一个时间内只能执行一个操作。同样只有当JavaScript代码执行完成之后，文档才能继续下去。</p>
<p>JavaScript代码有个快速生成内容的方式就是通过document.write()来实现：</p>
<pre><code>//载入时生成文档内容
&lt;h1&gt;Table of Factorials&lt;/h1&gt;
&lt;script&gt;
function factorial(n) {
    if(n &lt;= 1) return n;
    else return n*fatorial(n-1);
}
document.write(&apos;&lt;table&gt;&apos;);
document.write(&apos;&lt;tr&gt;&lt;th&gt;n&lt;/th&gt;&lt;th&gt;n!&lt;/th&gt;&lt;/tr&gt;&apos;);
for(var i = 1;i &lt;= 10;i++) {
    document.write(&apos;&lt;tr&gt;&lt;td&gt;&apos; + i + &apos;&lt;/td&gt;&lt;td&gt;&apos; + fatorial(i) + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
document.write(&apos;&lt;/table&gt;&apos;);
document.write(&apos;Generated at&apos; + new Date());//输出时间戳
&lt;/script&gt;
</code></pre><p>当脚本把文本传递给document.write()时，这个文本被添加到文档输入流中，HTML会创建一个文本节点插入到这个文本节点之后，我们不推荐这么使用。脚本的执行只在默认的情况下是同步和阻塞的。要有所改变我们可以当文本加载完成之后执行代码，也可以在文档加载之前尽快执行代码。前者就是defer的使用意义，后者就是async的使用意义，但是这两者的共同使用则是采用async属性。这两者就是JavaScript代码的同步、异步和延迟。不同的是延迟脚本的执行同样是按顺序走的，而异步脚本则可能是无序执行的。</p>
<p>动态创建脚本并把它插入到文档中来实现脚本的异步载入和执行，通过loadasync()函数来实现这个工作。</p>
<pre><code>//异步载入并执行脚本
function loadasync() {
    var head = document.getElementsByName(&apos;head&apos;)[0];//找到&lt;head&gt;元素
    var s = document.createElement(&apos;script&apos;);//创建一个&lt;script&gt;元素
    s.src = url;//设置其src属性
    head.appendChild(s);//将script元素插入到head标签中
}
</code></pre><p>注意：这个loadasync()函数会动态的载入脚本成为正在执行的JavaScript程序的一部分，不是通过web页面内联包含也不是来自页面的静态引用。</p>
<h3 id="1、事件的驱动JavaScript"><a href="#1、事件的驱动JavaScript" class="headerlink" title="1、事件的驱动JavaScript"></a>1、事件的驱动JavaScript</h3><p>事件都有名字比如click、change、load、mouseover、keypress或者readystatechange，指示发生的事件的通用类型。事件还有目标，就是对象，意思是哪个对象发生了什么事情，所以当我们谈到事件的时候，必须同时包含事件类型（名字）和目标（对象）：比如一个单击事件发生在HTMLButtonElement对象上，或者一个readystatechange事件发生在XMLHttpRequest对象上。</p>
<p>如果想要程序响应一个事件，写一个函数，叫做“事件处理程序”、“事件监听器”或者“回调”。然后注册这个函数，这样当事件发生时就会调用它。可以如下写代码：</p>
<pre><code>window.onload = function () {...};
document.getElementById(&quot;button1&quot;).onclick = function () {..};
function handleResponse() {...}
request.onreadystatechange = handleRequest;
</code></pre><p>对于大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击(IE里面事件信息被储存在全局event对象里)。</p>
<p>有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”，例如用户在<code>&lt;button&gt;</code>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样任何注册在容器元素上的单击事件都会调用。</p>
<p>大部分可以成为事件目标的对象都有一个叫做addEventListener()的方法，允许注册多个监听器：</p>
<pre><code>window.addEventListaner(&quot;load&quot;,function () {...},false);
request.addEventListener(&quot;readystatechange&quot;,function () {...},false);
</code></pre><p>这个函数的第一个参数是事件的名称，不好意思的是在IE中，IE8之前的版本中只能运用一个相似的办法，用attachEvent():</p>
<pre><code>window.attachEvent(&quot;onload&quot;,function () {...});
</code></pre><p>setTimeout()函数叫做“回调逻辑”不是“事件处理程序”，但它和setInterval()都是异步的。</p>
<pre><code>//当文档载入完成时调用一个函数
//注册函数f，当文档载入完成时执行这个函数f
//如果文档已经载入完成，尽快已异步方式执行它
function onLoad(f) {
    if(onLoad.loaded)//如果文档已经载入完成
        window.setTimeout(f,0);//将f放入异步队列，并尽快执行它
    else if(window.addEventListener)//注册事件的标准方法
        window.addEventListener(&quot;loade&quot;,f,false);
    else if(window.attachEvent)//IE8以及更早的IE版本浏览器注册事件的方法
        window.attachEvent(&quot;onload&quot;,f);
}
//给onLoad设置一个标志，用来指示文档是否完成
onLoad.loaded = false;
//注册一个函数，当文档载入完成时设置这个标志
onLoad(function () {onLoad.loaded = true;});
</code></pre><h3 id="四、兼容性和互用性"><a href="#四、兼容性和互用性" class="headerlink" title="四、兼容性和互用性"></a>四、兼容性和互用性</h3><p>客户端JavaScript兼容性和交互性的问题可以归纳为3类：</p>
<h4 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h4><p>Web平台在进化当中，什么标准都在进化</p>
<h4 id="未实现"><a href="#未实现" class="headerlink" title="未实现"></a>未实现</h4><p>没有实现，是浏览器开发商没有实现某个特性，比如<code>&lt;canvas&gt;</code>元素，IE8就不支持，而其他浏览器就已经实现了</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>每个浏览器都有bug</p>
<h4 id="解决兼容性问题的办法"><a href="#解决兼容性问题的办法" class="headerlink" title="解决兼容性问题的办法"></a>解决兼容性问题的办法</h4><p>1、</p>
<p>处理兼容性问题的方法之一是使用类库，比如jQuery，因为它们定义了新的客户端API并兼容所有浏览器。jQuery中事件处理程序的注册是使用bind()方法来完成的，如果用jQuery来做开发，就不用考虑addEventListener()和attachEvent()之间的兼容性。</p>
<p>2、功能测试</p>
<p>就是用某种方法测试你要使用的功能在某个浏览上是不是可用，不可用的话就不用，或者改用其它通用的方法。</p>
<pre><code>if(element.addEventListener) {//在使用这个W3C方法之前首先检测它是否可用
    element.addEventListener(&quot;keydown&quot;,handler,false);
    element.addEventListener(&quot;keypress&quot;,handler,false);
}
else if(element.attachEvent) {//在使用该IE方法之前首先检测它
    element.attachEvent(&quot;keydown&quot;,handler);
    element.attachEvent(&quot;keypress&quot;,handler);
}
else {//否则，选择普遍支持的技术
    element.onkeydown = element.onkeypress = handler;
}
</code></pre><p>3、怪异模式和标准模式</p>
<p>标准模式是符合W3Cschool的，怪异模式不属于</p>
<p>4、浏览器测试</p>
<p>5、IE的条件注释</p>
<p>很多的不兼容性都是针对IE浏览器的，我们可以用一种不怎么规范的方式来处理不兼容性问题。<br>例如：</p>
<pre><code>&lt;!--[if IE 6]&gt;
This content is actually inside an HTML comment.
It will only be displayed in IE6.
&lt;![endif]--&gt;

&lt;!--[if ite IE7]&gt;
This content will only be displayed by IE 5,6 and 7 and earlier.
Ite stands for &quot;less than or equal&quot;. You can also use &quot;It&quot;,&quot;gt&quot;,and &quot;gte&quot;.
&lt;![endif]--]&gt;

&lt;!--[if !IE]&gt;&lt;--&gt;
This is normal HTML content,but IE will not display it
because of the comment above and the comment below.
&lt;!--&gt;&lt;![endif]--&gt;

This is normal content,displayed by all browsers.
</code></pre><p>由于这个类库只有IE需要，因此有理由在页面里使用条件注释引用它，这样其他浏览器就不会载入它：</p>
<pre><code>&lt;!--[if IE]&lt;script src=&quot;excanvas.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;
</code></pre><h3 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h3><p>Web浏览器中包含JavaScript解释器，一旦载入Web页面，就可以让任意的JavaScript代码在计算机里执行，不过这里存在着安全隐患，浏览器厂商在下面两个方面进行着权衡和博弈：</p>
<p>定义强大的客户端API，启用强大的Web应用；</p>
<p>阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间。</p>
<p>下面会涉及到JavaScript的安全限制和安全问题，这个是要意识到的。</p>
<h4 id="1、JavaScript不能做什么"><a href="#1、JavaScript不能做什么" class="headerlink" title="1、JavaScript不能做什么"></a>1、JavaScript不能做什么</h4><p>客户端JavaScript没有权限来写入或删除客户计算机上的任意文件或列出任意目录，就意味着JavaScript程序不能删除数据或植入病毒。类似的，客户端JavaScript没有任何通用的网络能力。客户端JavaScript程序可以对HTTP协议编程，并且HTML5也有一个附属标准WebSockets，定义了一个类套接字的API，用于和指定的服务器通信。但是这些API都不允许对于范围更广的网络进行直接访问。通用的Internet客户端和服务器不能同时使用客户端JavaScript来写。</p>
<h4 id="2、同源策略"><a href="#2、同源策略" class="headerlink" title="2、同源策略"></a>2、同源策略</h4><p>同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<code>&lt;iframe&gt;</code>元素或者打开其他浏览器窗口的时候，这一策略通常会发挥作用。具体来说，脚本只能读取和所属文档来源相同的窗口和文档的属性。</p>
<p>文档的来源包含协议、主机，以及载入文档的URL端口。从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用http:协议载入的文档和使用https:协议载入的文档具有不同的来源，即使它们来自于同一个服务器。</p>
<p>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，这个很重要。假设一个来自于主机A的脚本被包含到宿主B的一个Web页面中。这个脚本的来源是主机B，并且可以完整的访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自于主机B的另一个文档，脚本对这个文档的内容也具有完全访问的权限。但是，如果脚本打开第三个窗口并载入一个来自于主机C的文档，同源策略就会阻止访问这个文档。</p>
<p>限制恶意脚本侵入文档，同源策略做的很好了，但是某些时候同源策略就显得过于严格了。下面就是3中不严格的同源策略。</p>
<h4 id="第一个就是主域名相同而子域名不同的情况。"><a href="#第一个就是主域名相同而子域名不同的情况。" class="headerlink" title="第一个就是主域名相同而子域名不同的情况。"></a>第一个就是主域名相同而子域名不同的情况。</h4><p>例如，来自于home.example.com的文档里的脚本想要合法的读取从developer.example.com载入的文档的属性，或者来自于orders.example.com的脚本可能要读取catalog.example.com上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的domain属性。</p>
<p>默认的情况下，属性domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须是具有有效的域前缀或它本身。因此，一个domain属性的初始值是字符串“home.example.com”就可以把它设置为“example.com”，但是不能设置为“home.example”或者“example.com”。另外，domain值中必须有一个点，不能把它设置为“com”或其他顶级域名。</p>
<p>这样文档就有了同源性，可以互相读取属性，切记这是主域名相同的情况下。</p>
<h4 id="第二个跨域资源共享"><a href="#第二个跨域资源共享" class="headerlink" title="第二个跨域资源共享"></a>第二个跨域资源共享</h4><p>请求头和新的Access-Control-Allow-Origin响应头来扩展HTTP。它允许服务器用头信息显示地列出源，或者使用通配符来匹配所有的源并允许由任何地址请求文件，这样XMLHttpRequest就不会被同源策略所限制了。</p>
<h4 id="第三种叫做跨文档消息"><a href="#第三种叫做跨文档消息" class="headerlink" title="第三种叫做跨文档消息"></a>第三种叫做跨文档消息</h4><p>允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用Window对象上的postMessage()方法，可以异步传递信息事件到窗口的文档里。</p>
<h3 id="3、跨站脚本"><a href="#3、跨站脚本" class="headerlink" title="3、跨站脚本"></a>3、跨站脚本</h3><p>跨站脚本(Cross-site scripting)或者叫做XSS，这个术语表示一类安全问题，也就是攻击者向目标Web站点注入HTML标签或者脚本。防止XSS攻击是服务器Web开发者的一项基本工作。然而，客户端JavaScript开发者必须意识到或者预防跨站脚本。</p>
<p>来看个例子，它是如何使用JavaScript通过用户的名字来向用户问好：</p>
<pre><code>&lt;script&gt;
var name = decodeURICompnent(window.location.search.substring(1)) || &quot;&quot;;
document.write(&quot;Hello&quot; + name);
&lt;/script&gt;
</code></pre><p>这两行脚本使用window.location.search来获得获得它们自己的URL中以“？”<br>开始的部分。它使用document.write()来向文档添加动态生成的内容。</p>
<p>来防止XSS攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签。可以通过添加如下一行代码来移除<code>&lt;script&gt;</code>标签两边的尖括号。</p>
<pre><code>name = name.replace(/&lt;/g,&quot;&amp;lt;&quot;).replace(/&gt;/g,&quot;&amp;gt;&quot;);
</code></pre><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>就是不让开客户端使用者使用客户端浏览器</p>
<h3 id="客户端框架"><a href="#客户端框架" class="headerlink" title="客户端框架"></a>客户端框架</h3><p>jQuery框架之外还有Prototype类库(专门针对DOM和Ajax实现的一套实用工具)、Dojo(是一个大型的框架包含众多的UI组件集合、包管理系统、数据抽象层等)、YUI(Yahoo开发的，和Dojo一样很庞大，包括语言工具、DOM工具、UI组件，目前YUI2和YUI3是两个不同的版本)等。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[RegExp]]></title>
      <url>/2017/07/12/RegExp/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式表达式的匹配模式]]></title>
      <url>/2017/07/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="我们的主题："><a href="#我们的主题：" class="headerlink" title="我们的主题："></a>我们的主题：</h2><p>正则表达式什么样子的？能用来做什么？怎么做？ok，一一揭示！</p>
<h3 id="一、正则表达式简介"><a href="#一、正则表达式简介" class="headerlink" title="一、正则表达式简介"></a>一、正则表达式简介</h3><p>正则表达式是一个描述字符模式的对象，注意是对象，创建方式不用说了，有构造函数和直接量两种方式。描述字符模式的规则是由字符(数字、字母和其他)组成的。</p>
<p>下面我们就把正则表达式的基本知识看一下：</p>
<h4 id="1、直接量字符"><a href="#1、直接量字符" class="headerlink" title="1、直接量字符"></a>1、直接量字符</h4><p>用反斜线()作为前缀进行转义：</p>
<pre><code>\o(NUL字符)等价于\u0000                 \t(制表符)等价于\u0009
\n(换行符)等价于\u000A                   \v(垂直制表符)等价于\u000b
\f(换页符)等价于\u000L                   \r(回车符)等价于\u000D
\uxxxx(十六进制数指定的Unicode字符)，既有\u009等价于\t
</code></pre><h4 id="2、字符类"><a href="#2、字符类" class="headerlink" title="2、字符类"></a>2、字符类</h4><p>将直接量字符单独放到方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。</p>
<pre><code>/[abc]/和字母&quot;a&quot;,&quot;b&quot;,&quot;c&quot;中的任意一个都匹配
/[a-zA-Z0-9]/匹配拉丁字母表中的任意字母和数字
</code></pre><p>尖括号“^”表示取反，注意它所在的位置是紧靠左边的方括号，/[^abc]/意思是匹配所有除三者之外的字符。</p>
<p>正则表达式中的字符类：</p>
<pre><code>[...] 方括号内的任意字符     [^...]  不在方括号内的所有字符
.     除了换行符\n和其他表示终止符的Unicode字符
\w    任何AS11码组成的单词，是数字和字母的组合[a-zA-Z0-9]是等价的
\W    与上者是相反的
\s    任何Unicode空白字符
\S    任何非空字符的UNicode字符
\d    任何AS11数字等价于[0-9]
\D    等价于[^0-9]
[\b]  表示退格直接量
</code></pre><p>方括号内也可以写特殊转义字符，/[\s\d]/(任何空白符或数字)</p>
<p>正则表达式里有个表示重复的字符语法：</p>
<pre><code>{n,m}  匹配前一项的重复次数，比n大比m小，这个m可选，n为必填的，当然有更简单的表示方法
</code></pre><p>比如：</p>
<pre><code>？ 等价于{0,1}、+ 等价于{1，}、*等价于{0，}
</code></pre><p>for example 1：</p>
<pre><code>/\d{2,4}/     2--4个数字
/\w{3}\d?/    精确匹配3个单词一个可选的数字
/\s+java\s+/  前后各至少有一个空白符的字符串&quot;java&quot;
/[^(]*/       匹配0个或多个非左括号的字符
</code></pre><p>正则表达式的选择、分组和引用字符</p>
<pre><code>|        有或者的意思
(...)    将几个项组合为一个单元
(?...)   只组合，不记忆
</code></pre><p>for example 2：</p>
<pre><code>/ab|cd|ef/         可以匹配字符串&quot;ab&quot;或者&quot;cd&quot;或者&quot;ef&quot;
/\d{3}|[a-z]{4}/   匹配的是3个数字或者4个小写字母
</code></pre><p>注意：这个模式一旦发现了我们所需要的匹配项，就立即停止，不再进行匹配</p>
<pre><code>/java(script)?/  可以匹配字符串java，其后的script可有可无
/(ab|cd)+|ef/     可以匹配字符串&quot;ef&quot;,也可以匹配字符串&quot;ab&quot;或者&quot;cd&quot;一次或者多次
</code></pre><p>我们可以用/^…$/来表示开始和结束，就有表示指定位置的意思</p>
<p>修饰符(放到/…/之后)有3个：<br>    i：表示模式不区分大小写<br>    g：表示进行全局搜索，找到所有的匹配项<br>    m:多行模式进行匹配，针对换行符</p>
<h3 id="二、正则表达式的String方法"><a href="#二、正则表达式的String方法" class="headerlink" title="二、正则表达式的String方法"></a>二、正则表达式的String方法</h3><p>上面说了正则表达式的基础知识，这里我们就说说怎么运用正则表达式。</p>
<h4 id="1、search"><a href="#1、search" class="headerlink" title="1、search()"></a>1、search()</h4><p>字面意思就是寻找什么，不错，他就是从字符串中寻找参数，有的话就返回开始的位置，没有的话就返回-1。参数如果不是正则表达式就会进行自动转换(调用RegExp()构造函数进行自动转换)</p>
<p>for  example 4：</p>
<pre><code>&quot;JavaScript&quot;.search(/script/i);
</code></pre><h4 id="2、replace"><a href="#2、replace" class="headerlink" title="2、replace()"></a>2、replace()</h4><p>字面意思就是根据正则表达式寻找到相应的字符串，这是第一个要做的事情，第二个参数就是要写个替换字符串，同样，如果第一个参数不是正则表达式，就会进行自动转换</p>
<p>for  example 5：</p>
<pre><code>text.replace(/javascript/gi,&quot;JavaScript&quot;);
</code></pre><h4 id="3、match"><a href="#3、match" class="headerlink" title="3、match()"></a>3、match()</h4><p>这个方法的参数是唯一的，如果不是全局搜索的话，就仅仅当匹配到第一个元素时就会停止，并同样会返回一个数组</p>
<p>for example 6：</p>
<pre><code>&quot;1 plus 2 equals 3&quot;.match(/\d+/g);//返回[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],进行了全局搜索
</code></pre><h4 id="4、split"><a href="#4、split" class="headerlink" title="4、split()"></a>4、split()</h4><p>这个方法不说了，之前有说到。</p>
<h3 id="三、RegExp对象的属性和方法"><a href="#三、RegExp对象的属性和方法" class="headerlink" title="三、RegExp对象的属性和方法"></a>三、RegExp对象的属性和方法</h3><p>RegExp对象的属性有5个，前4个是只读的。分别为：source、global(g,布尔值)、ignorancase(i,布尔值)、multiline(布尔值)、lastIndex(可读写的)</p>
<p>lastIndex，若匹配模式中有g修饰符，会发挥作用。有两个方法：test()和exec()</p>
<p>for example 7:</p>
<pre><code>var pattern = /java/i;
pattern.test(&quot;JavaScript&quot;);//true,这个方法返回的是布尔值
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一键清理]]></title>
      <url>/2017/07/07/%E4%B8%80%E9%94%AE%E6%B8%85%E7%90%86/</url>
      <content type="html"><![CDATA[<p>我是不愿意在自己的电脑上装个电脑管家、360卫士或者金山毒霸什么玩意的东西来清理我的电脑的，前两天在网上浏览到一个好玩的东西，你只要设置一下，花你几分钟的时间就能自己搞个清理器，不要钱还没有绑定的插件，效果还不错！<br>这个家伙长什么样子呢？</p>
<p><strong>如图：</strong></p>
<p><img src="image/clean.png" alt=""></p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1.这个样子你直接点击就能进行清理工作了；</p>
<p>2.这个文件的格式是.bat，这是必须改成这个样子；</p>
<p>3.编辑的时候把如下代码粘贴进text文档就行了：</p>
<pre><code>@echo off     
echo 正在清除系统垃圾文件，请稍等......     
del /f /s /q %systemdrive%\*.tmp     
del /f /s /q %systemdrive%\*._mp     
del /f /s /q %systemdrive%\*.log     
del /f /s /q %systemdrive%\*.gid     
del /f /s /q %systemdrive%\*.chk     
del /f /s /q %systemdrive%\*.old     
del /f /s /q %systemdrive%\recycled\*.*     
del /f /s /q %windir%\*.bak     
del /f /s /q %windir%\prefetch\*.*     
rd /s /q %windir%\temp &amp; md %windir%\temp     
del /f /q %userprofile%\COOKIES s\*.*     
del /f /q %userprofile%\recent\*.*     
del /f /s /q &quot;%userprofile%\Local Settings\Temporary Internet Files\*.*&quot;     
del /f /s /q &quot;%userprofile%\Local Settings\Temp\*.*&quot;     
del /f /s /q &quot;%userprofile%\recent\*.*&quot;     
sfc /purgecache &apos;清理系统盘无用文件     
defrag %systemdrive% -b &apos;优化预读信息     
echo 清除系统LJ完成！     
echo. &amp; pause  
</code></pre><p>把上面的粘到txt文档后，修改改为.bat就能用了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[通过设置hosts文件来翻墙]]></title>
      <url>/2017/07/06/hosts%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>下面我们就分几个步骤来说，文章以win10系统为例，其他系统类似。</p>
<h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p>首先你到网上找到个hosts文件，这个文件要找到个最新的版本，直接在百度上搜索去吧！找到后就下载下来；</p>
<h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p>在我的电脑里，打开文件的顺序如下： C盘/windows/system32/drivers/etc/hosts，把你下载的hosts文件拷贝到这里，替换掉系统原来的hosts文件。执行的时候可能会具备管理者权限才行。</p>
<h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><p>配置好后，，windows+r,进入命令面板，，输入ipconfig/flushdns,按enter键执行即可，这个是为了改变DNS指向</p>
<h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p>完事后，就把网给拔掉，重新连接网络</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>完事后关闭chrome再打开，这一切的前提是别忘了你得下载个Google浏览器，其他的事项应该就木有了吧！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[类和模块]]></title>
      <url>/2017/07/01/%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="这一节我们的主题是：类和模块"><a href="#这一节我们的主题是：类和模块" class="headerlink" title="这一节我们的主题是：类和模块"></a>这一节我们的主题是：类和模块</h1><p><strong>JavaScript的对象是一个属性的集合体，相互之间没有任何的联系。然而有些时候对象与对象之间的属性相同的时候，为了不重复写代码，我们要定义一个类，这个类里面的属性和方法对于他的成员或者实例都是共享的。下面就是对类的知识的介绍。</strong></p>
<h4 id="1、类和原型"><a href="#1、类和原型" class="headerlink" title="1、类和原型"></a>1、类和原型</h4><p>在JavaScript中，类的实现是基于原型继承机制的，所有的实例对象都是从同一个原型对象上继承属性，因此原型对象是类的核心。如果定义一个原型对象，然后通过inherit()函数创建一个继承自它的对象，这样就定义了一个JavaScript类。</p>
<p>例子中给一个表示“值的范围”的类定义了原型对象，还定义了一个工厂函数用以创建并初始化类的实例。</p>
<p>for example 1：</p>
<pre><code>//range.js:实现一个能表示值的范围的类

//这个工厂方法返回一个新的&quot;范围对象&quot;
function range(from,to) {
    //使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象
    //原型对象作为函数的一个属性存储，并定义所有&quot;范围对象&quot;所共享的方法
    var r = inherit(range.methods);

    //存储新的‘范围对象’的起始位置和结束位置（状态）
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    r.from = from;
    r.to = to;

    //返回这个新创建的对象
    return r;
}


//原型对象定义方法，这些方法为每个范围对象所继承
range.methods = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) {
        return this.from &lt;= x &amp;&amp; x &lt;=this.to;
    },


    //对于范围内的每个整数都调用一次f
    //这个方法只可用作数字范围
    foreach:function (f) {
        for(var x = Math.ceil(this.from);x &lt;= this.to;x++) f(x);
    },

    //返回表示这个范围的字符串
    tostring:function () {
        return&quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;
    }
};

//这里是使用‘范围对象’的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true,2在这个范围内
r.foreach(console.log);//输出1 2 3 
console.log(r);//输出(1...3)
</code></pre><p>解读：这段代码定义了一个工厂方法range(),用来创建新的范围对象。我们注意到，这里给range()函数定义了一个属性range.methods,用以快捷的存放定义类的原型对象。把对象挂在了函数上，这个方法不是惯用的方法。再者，注意range()函数给每个范围对象都定义了from和to属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在range.methods中定义的那些可共享、可继承的方法都用到了from和to属性，而且使用了this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类的方法都可以通过this的这种基本用法来读取对象的属性。</p>
<h3 id="2、类和构造函数"><a href="#2、类和构造函数" class="headerlink" title="2、类和构造函数"></a>2、类和构造函数</h3><h4 id="①、例子展示"><a href="#①、例子展示" class="headerlink" title="①、例子展示"></a>①、例子展示</h4><p>例子1中展示了定义类的其中一种方法，但是并不常用。说到了类也就有原型，而这种方法却没有用到构造函数。定义构造函数，它会初始化新创建的对象，调用构造函数的一个重要特征就是，构造函数的prototype属性被用于新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承于同一个相同的对象，属于同一个类的成员。下面我们就对例子1做了个修改，使用构造函数来代替工厂函数：</p>
<p>使用构造函数来定义“范围类”</p>
<p>for example 2：<br>    //range2.js:表示值的范围的类的另一种实现</p>
<pre><code>//这是一个构造函数，用以初始化新创建的“范围对象”
//注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from,to) {
    //存储‘范围对象‘的起始位置和结束位置
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}

//所有对象的’范围对象‘都继承自这个对象
//注意的是属性的名字必须是prototype
Range.prototype = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to;},
    //对于范围内的每个整数都调用一次f
    //这个方法只可用于数字范围
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    },
    //返回表示这个范围的字符串
    tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;}
};

//这里是使用’范围对象‘的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true，2在这个范围内
r.foreach(console.log);//输出1 2 3
console.log(r);//输出（1...3）
</code></pre><p>解读：ok，上面看到了两种方式来定义类，我们要知道一个编程约定：定义构造函数既是定义类，并且类名首字母要大写，而普通函数和方法是首字母小写。构造函数是使用关键字new来实现的，不必使用inherit()来创建对象。例子2中原型是Range.prototype,这是一个强制的命名，而例子1中是个随意的命名。对于Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。两者的相同之处是对于范围方法的定义和调用方式。</p>
<h4 id="②、构造函数和类的标识"><a href="#②、构造函数和类的标识" class="headerlink" title="②、构造函数和类的标识"></a>②、构造函数和类的标识</h4><p>原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的实例。初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的prototype属性指向同一个原型对象，那么这两个构造函数创建的实例属于同一个类。</p>
<p>构造函数是类的外在表现形式。构造函数的名字通常用作类名，我们通常用instanceOf运算符来检测对象是否属于某个类时会用到构造函数。假设有个对象r，我们想知道r是否是Range对象，我们可以这么做：</p>
<pre><code>r instanceOf Range //如果r继承自Range.prototype,则返回true
</code></pre><p>实际上，instanceOf不会检查r是否是由Range()构造函数初始化来的</p>
<h4 id="③、constructor属性"><a href="#③、constructor属性" class="headerlink" title="③、constructor属性"></a>③、constructor属性</h4><p>在上面的例子中，将Range.prototype定义为一个新的对象，这个对象包含了方法。其实在不创建一个新的对象的时候我们也可以做到，就是用对象直接量的属性就可以定义原型上的方法。JavaScript中几乎每个函数都自动拥有prototype属性。这个属性的值是个对象，这个对象也拥有一个不可枚举的属性constructor。</p>
<p>for example 3：</p>
<pre><code>var F = function() {};//这是个函数对象
var p = F.prototype;//F的原型对象
var c = p.constructor;//原型相关联的函数
console.log(c === F);//true，这是成立的，原型和实例对象的constructor指向的是他们的构造函数
</code></pre><p>既然如此，那我们怎么达到不用重新预定义Range.prototype对象呢。</p>
<p>for example 4：</p>
<p>①</p>
<pre><code>Range.prototype = {
    constructor:Range,//显式设置构造函数反向引用
    includes:function (x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to;},
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    },
    tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;}
};
</code></pre><p>②这种方法是使用预定义的原型对象，预定义的原型对象包含constructor属性，然后给原型对象添加方法。</p>
<pre><code>Range.prototype.includes:function (x) {
     return this.from &lt;= x &amp;&amp; x &lt;= this.to;
};
Range.prototype.foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    };
Range.prototype.tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;
};
</code></pre><h3 id="3、JavaScript中Java式的类继承"><a href="#3、JavaScript中Java式的类继承" class="headerlink" title="3、JavaScript中Java式的类继承"></a>3、JavaScript中Java式的类继承</h3><p>JavaScript中定义类的步骤可以分为3步，首先是定义一个构造函数，并设置初始化新对象的实例属性。再者，就是给构造函数的prototype对象定义实例的方法。最后就是，给构造函数定义类字段和类属性。封装到一个defineClass()函数中为：</p>
<pre><code>function defineClass(constructor,methods,statics) {
    if (methods) extend(constructor.prototype,methods);//实例的方法复制到原型中
    if (statics) extend(constructor,statics);//类属性，复制到构造函数中
    return constructor;
}
</code></pre><h3 id="4、类的扩充"><a href="#4、类的扩充" class="headerlink" title="4、类的扩充"></a>4、类的扩充</h3><p>JavaScript里的类是可以扩充的，例如如果没有去掉字符串前后空格时，可以定义个trim()方法，没有bind()方法，我们可以定义一个bind()方法。直接给Object.prototype添加方法就可以了。</p>
<p>for example 5：</p>
<pre><code>String.prototype.trim = String.prototype.trim || function() {
    return this.replace(/^\s+]\s+$/g);}
</code></pre><h3 id="5、类和类型"><a href="#5、类和类型" class="headerlink" title="5、类和类型"></a>5、类和类型</h3><p>这节主要说的是，一个对象是否是属于一个类，我们通过什么去判断，前面我们多次提到过两种方法就是通过instanceOf()运算符，再有就是通过constructor属性。但是他们的局限是执行上下文多个场景时不灵光了。再有就是我们虽然能判断是不是属于一个类，但我们不能知道构造函数的名称。通过函数名称来判断的话，也有问题就是不是所有的函数都有名称。下面我们重点说的就是鸭式辩型，就是根据一个对象能做什么来做判断。根据定义我们可以判断一个会走路、游泳并且会发出嘎嘎叫的鸟就是鸭子，因此我们可以判断对象的属性和方法是不是能做同一个事情来做判断。鸭式辩型不能用在内置类上。</p>
<p>for example 5：</p>
<pre><code>//如果o实现了除第一个参数之外的参数所表示的方法，则返回true
function quacks(o /*,..*/) {
    for(var i = 1;i &lt; arguments.length;i++) {//返回遍历o后的所有参数
    var arg = argiments[i];
    switch (typeof arg) {//如果参数是
        case &apos;string&apos;://直接用名字做检查
            if(typeof o[arg] !== &quot;function&quot;) return false;
            continue;
        case &apos;function&apos;://function：检查函数的原型对象上的方法，如果实参是函数，则使用它的原型
            arg = arg.prototype;
        case &apos;object&apos;:
            for( var m in arg) {
                if(typeof arg[m] !== &quot;function&quot;) continue;//跳过不是方法的属性
                if(typeof o[m] !== &quot;function&quot;) return false;
            }
        }
    }
    //如果程序运行到这里，说明o实现了所有的方法
    return true;
}
</code></pre><h3 id="6、JavaScript中的面向对象技术"><a href="#6、JavaScript中的面向对象技术" class="headerlink" title="6、JavaScript中的面向对象技术"></a>6、JavaScript中的面向对象技术</h3><p>前面我们学习到了JavaScript中类的基础知识：原型对象的重要性、它和构造函数的关系、instanceof()运算符如何工作等，这次我们就用两个例子实战一下。</p>
<h4 id="①、集合类"><a href="#①、集合类" class="headerlink" title="①、集合类"></a>①、集合类</h4><p>集合(set)是一种数据结构，来表示非重复值的无序集合。集合的基础方法有：添加值、检测值是否在集合中。下面的例子中一个更加通用的Set类，实现了从JavaScript值到唯一字符串的映射，然后将字符串用作属性名。</p>
<p>for example 6：</p>
<pre><code>//Set.js:值的任意集合
function Set() {//这是个构造函数
    this.values = {};//集合数据保存在对象的属性里
    this.n = 0;//集合中值的个数
    this.add.apply(this,arguments);//把所有的参数都添加到这个集合中
};

//将每个参数都添加到集合中
Set.prototype.add = function() {
    for(var i = 0;i &lt; arguments.length;i++) {//遍历每个参数
        var val = arguments[i];//待添加到集合中的值
        var str = Set._v2s(val);//把它转换为字符串
        if(!this.value.hasOwnProperty(str)) {//如果不在集合中
            this.value[str] = val;//将字符串和值对应起来
            this.n++;//集合中的值计数加一
        }
    }
    return this;//支持链式方法调用
};

//从集合删除元素，这些元素由参数指定
Set.prototype.remove = function() {
    for(var i = 0;i &lt; arguments.length;i++){
        var str = Set._v2s(arguments[i]);
        if(this.values.hasOwnProperty(str)){//如果它在集合中
            delete this.values[str];//删除它
            this.n--;
        }
    }
    return this;
};

//如果集合包含这个值，则返回true，否则返回false
Set.prototype.contains = function(value){
    return this.values.hasOwnProperty(Set._v2s(value));
};

//返回集合的大小
Set.prototype.size = function() {
    return this.n;
};

//遍历集合中的所有元素，在指定的上下文中调用f
Set.prototype.foreach = function (f,context) {
    for(var s in this.values)//遍历集合中的所有字符串
        if(this.values.hasOwnProperty(s))//忽略继承属性
        f.call(context,this.values[s]);//调用f,传入value
};

//这是一个内部函数，用以将任意JavaScript值和唯一的字符串对应起来
Set._v2s = function (val) {
    switch (val) {
        case undefined:  return &apos;u&apos;;//特殊的原始值
        case null;  return &apos;n&apos;;//值只有一个字母
        case true; return &apos;t&apos;;
        case false; return &apos;f&apos;;
        default:switch(typeof val) {
            case&apos;number&apos;: return &apos;#&apos; + val;//数字都带有#前缀
            case &apos;string&apos;:return &apos;&quot;&apos; + val;//字符串都带有&quot;前缀
            default: return &apos;@&apos; + objectId(val);
        }
    }

    //对任意对象来说，都会返回一个字符串
    //针对不同的对象，这个函数会返回不同的字符串
    //对于同一个对象的多次调用，总是返回相同的字符串
    //为做到这一点，它给o创建了一个属性，在ES5中，这个属性是不可枚举且是只读的
    function objectId(o) {
        var prop = &quot;|**object**|&quot;;//私有属性，用以存放id
        if(!o.hasOwnProperty(prop))//如果对象没有id
            o[prop] = Set._v2s.next++;//将下一个值赋给它
        return o[prop];//返回这个id
    }
};
Set._v2s.next = 100;//设置初始id的值
</code></pre><h4 id="②、枚举类型"><a href="#②、枚举类型" class="headerlink" title="②、枚举类型"></a>②、枚举类型</h4><p>枚举类型是一个类型，它是值的有限集合，如果值定义为这个类型则该值是可列出（可枚举）的。在C语言中，enum是个关键字，在JavaScript中它仅仅是个关键字，或许未来我们能看到它的身影。</p>
<p>for example 7：</p>
<pre><code>//这个函数创建一个新的枚举类型，实参对象表示类的每个实例的名字和值
//返回值是一个构造函数，它标识这个新类
//这个构造函数也会抛出异常，不能用它来创建该类型的新实例
//返回的构造函数包含名/值对的映射表
//包括由值组成的数组，以及一个foreach()迭代器函数
function enumeration(namesToValues) {
    //这个虚拟的构造函数是返回值
    var enumeration = function () {
        throw &quot;Can&apos;t Instantiate Enumerations&quot;;};

    //枚举值继承这个对象
    var proto = enumeration.prototype = {
        constructor:enumeration,//标识类型
        toString:function () { return this.name;},//返回名字
        valueOf:function () { return this.value;},//返回值
        toJSON:function () { return this.name}//转换为JSON
    };

    enumeration.values = [];//用以存放枚举对象的数组

    //现在创建新类型的实例
    for (name in namesToValues) {//遍历每个值
        var e = inherit(proto);//创建一个代表它的对象
        e.name = name;//给它一个名字
        e.value = namesToValues[name];//给它一个值
        enumeration[name] = e;//将它设置为构造函数的属性
        enumeration.values.push(e);//将它储存到值数组中
    }
    //一个类方法，用来对类的实例进行迭代
    enumeration.foreach = function (f,c) {
        for (var i = 0;i &lt; this.values.length;i++) 
            f.call(c,this.values[i]);
    };

    //返回标识这个新类型的构造函数
    return enumeration;
}
</code></pre><p>for example 8（用枚举类型来表示一副扑克牌）：</p>
<pre><code>//定义一个表示‘玩牌’的类
function Card(suit,rank) {
    this.suit = suit;//每张牌都有花色
    this.rank = rank;//以及点数
}

//使用枚举类型定义花色和点数
Card.Suit = enumeration({Clubs:1,Diamonds:2,Hearts:3,Spades:4});
Card.Rank = enumeration({Two:2,Three:3,Four:4,Five:5,Six:6,Seven:7,Eight:8,Nine:9,Ten:10,Jack:11,Queen:12,King:13,Ace:14});

//定义用以描述牌面的文本
Card.prototype.toString = function () {
    return this.rank.toString() + &quot;of&quot; + this.suit.toString();}
//比较扑克牌中两张牌的大小
Card.prototype.compareTo = function (that) {
    if (this.rank &lt; that.rank) return -1;
    if (this.rank &gt; that.rank) return 1;
    return 0;
};

//以扑克牌的玩法规则对扑克牌进行排序的函数
Card.orderByRank = function (a,b){ return a.compareTo(b);};

//以桥牌的玩法规则对牌进行排序的函数
Card.orderBySuit = function (a,b) {
    if (a.suit &lt; b.suit) return -1;
    if (a.suit &gt; b.suit) return 1;
    if (a.rank &lt; b.rank) return -1;
    if (a.rank &gt; b.rank) return 1;
    return 0;
};

//定义用以表示一副扑克牌的类
function Deck() {
    var cards = this.cards = [];//一副牌就是由牌组成的数组
    Card.Suit.foreach(function (s) {//初始化这个数组
        Card.Rank.foreach(function (r) {
            cards.push(new Card(s,r));
        });
    });
}

//洗牌的方法：重新洗牌并返回洗好的牌
Deck.prototype.shuffle = function () {
    //遍历数组中的每个元素，随机找出牌面中的最小元素，并与之交换
    var deck = this.cards.len = deck.length;
    for(var i = len - 1;i &gt; 0;i--) {
        var r = Math.floor(Math.random()*(i+1)),temp;//随机数
        temp = deck[i],deck[i] = deck[r],deck[r] = temp;//交换
    }
    return this;
};

//发牌的方法：返回牌的数组
Deck.prototype.deal = function (n) {
    if (this.cards.length &lt; n)  throw &quot;Out of cards&quot;;
    return this.cards.splice(this.cards.length - n,n);
};

//创建一副新扑克牌，洗牌并发牌
var deck = (new Deck()).shuffle();
var hand = deck.deal(13).sort(Card.orderBySuit);
</code></pre><h4 id="③、标准转换方法"><a href="#③、标准转换方法" class="headerlink" title="③、标准转换方法"></a>③、标准转换方法</h4><p>对象是要做类型转换的，有些方法是在需要做类型转换时由JavaScript解释器做自动转换调用的，而有时我们需要为没有定义的类实现这些方法。怎么做呢？有以下几个方法：</p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString:"></a>toString:</h5><p>这个方法返回的是可以表示这个对象的字符串，在要用到字符串的地方使用对象的话，就会自动调用这个方法。如果没有这个方法，类就会默认从Object.prototype中继承toString()方法。运算的结果是”[object object]”<br>,这个字符串用处不大。因为只有可读的字符串才有利用的价值。toLocaleString()与toString()方法类似。</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>它用来将对象转换为原始值。当数学运算符和关系运算符作用于数字文本表示的对象时，会自动调用这个方法。事实是多数对象都没有合适的原始值来表示它们。</p>
<h4 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h4><p>这个方法是由JSON.stringfy()自动调用的。JSON格式用于序列化良好的数据结构，而且可以处理JavaScript原始值、数组和纯对象。它和类无关，党对一个对象进行序列化操作时，它会忽略对象的原型和构造函数。如果将Range对象作为参数传给JSON.stringfy()，将会返回{“from”:1,”to”:3}这种字符串。如果将这些字符串传入JSON.parse()，将会得到一个和Range对象具有相同属性的纯对象，但不会包含继承来的方法。</p>
<p>同样有时我们也需要自定义toJSON()方法来实现个性化的序列化格式。</p>
<p>for  example 9(使用extend()来向Set.prototype来添加方法):</p>
<pre><code>//将这些方法都添加到Set类的原型对象中
extend(Set.prototype,{
    //将集合转换为字符串
    toString:function () {
        var s = &quot;{&quot;,
        i = 0;
        this.foreach(function (v) {s += ((i++ &gt; 0) ? &quot;,&quot;:&quot;&quot;) + v;});
        return s + &quot;}&quot;;
    },
    //类似toString(),但是对于所有的值都将调用toLocaleString()
    toLocaleString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            if (v == null) s += v;//null和undefined
            else s += v.toLocaleString();//其他情况
            });
        return s + &quot;}&quot;;
    },
    //将集合转换为数组
    toArray：function () {
        var a = [];
        this.foreach(function (v) {a.push(v);});
        return a;
    }
});

//对于要从JSON转换为字符串的集合都被当作数组来对待
Set.prototype.toJSON = Set.prototype.toArray;
</code></pre><h3 id="7、子类"><a href="#7、子类" class="headerlink" title="7、子类"></a>7、子类</h3><p>JavaScript里对子类的创建的关键之处在于采用合适的方法对原型对象进行初始化，并且会讲解到类继承的替代方案：组合。</p>
<p>创建子类的关键：</p>
<p>for example 10：</p>
<pre><code>B.prototype = inherit(A.prototype);//子类派生自父类
B.prototype.constructor = B;//重载继承来的constructor属性
</code></pre><h4 id="组合与子类"><a href="#组合与子类" class="headerlink" title="组合与子类"></a>组合与子类</h4><p>面向对象编程中一条广为人知的设计原则：组合优于继承。</p>
<p>for example 11(使用组合代替继承的集合的实现):</p>
<pre><code>//实现一个FilteredSet，它包装某个指定的”集合“的对象
//并对传入add()方法的值应用了某种指定的过滤器
//“范围”类中其他所有的核心方法延续到包装后的实例中

var FilteredSet = Set.extend(
    function FilteredSet(set,filter) {//构造函数
        this.set = set;
        this.filter = filter;
    },
    {//实例方法
    add:function() {
        //如果已经有过滤器，直接使用
        if(this.filter) {
            for(var i = 0;i &lt; arguments.length;i++) {
                var v = arguments[i];
                if(!this.filter(v))
                    throw new Error(&quot;FilteredSet:value &quot; + v + &quot;rejected by filter&quot;);
                }
            }

            //调用set中的add()方法
            this.set.add.apply(this.set,arguments);
            return this;
        },
        contains:function (v) { return this.set.contains(v);},
        size:function() { return this.set.size();},
        foreach:function(f,c) { this.set.foreach(f,c);}
});
</code></pre><h4 id="类的层次结构和抽象类"><a href="#类的层次结构和抽象类" class="headerlink" title="类的层次结构和抽象类"></a>类的层次结构和抽象类</h4><p>for example 12（抽象类和非抽象Set类的层次结构）：</p>
<pre><code>//这个函数可以用做任何抽象方法，很方便
function abstractmethod() { throw new Error (&quot;abstract method&quot;);}

//AbstractSet类定义了一个抽象方法：contains()

function AbstractSet() { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);}
AbstractSet.prototype.contains = abstractmethod;


//NotSet是AbstractSet的一个非抽象子类
//所有不在其他集合中的成员都在这个集合中
//因为它是在其他集合是不可写的条件下定义的
//同时由于它的成员是无限个，因此它是不可枚举的
//我们只能用它来检测元素成员的归属情况
//注意，我们使用了Function.prototype.extend()来定义这个子类

var NotSet = AbstractSet.extend(
    function NotSet(set) { this.set = set;},
    {
        contains:function (x) { return !this.set.contains(x);},
        toString:function (x) { return &quot;～&quot; + this.set.toString();},
        equals:function (that) {
            return that instanceof NotSet &amp;&amp; this.set.equals(that.set);
        }
    }
);


//AbstractEnumerableSet是AbstractSet的一个抽象子类
//它定义了抽象方法size()和foreach()
//然后实现了非抽象方法isEmpty()、toArray()、toLocaleString()和equals()方法
//子类实现了contains()、size()和foreach()，这三个方法可以很轻松的调用这5个非抽象方法

var AbstractEnumerableSet = AbstractSet.extend(
    function () { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);},
    {
    size:abstractmethod,
    foreach:abstractmethod,
    isEmpty:function () { return this.size == 0;},
    toString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            s += v
            });
        return s + &quot;}&quot;;
    },
    toLocaleString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            if (v == null) s += v;//null和undefined
            else s += v.toLocaleString();//其他情况
            });
        return s + &quot;}&quot;;
    },
    equals:function (that) {
        if(!(that instanceof AbstractEnumerableSet)) return false;
        //如果它们的大小不同，则它们不相等
        if(this.size() != that.size()) return false;
        //检查每一个元素是否也在that中
        try{
            this.foreach(function (v) { if(!that.contains(v)) throw false;});
            return true;//所有的元素都匹配，集合相等
        } catch(x) {
            if(x === false) return false;//集合不相等
            throw x;//发生了其他异常，重新抛出异常
        }
    }
});


//SingletonSet是AbstractEnumerableSet的非抽象子类
//singleton集合是只读的，它只包含一个成员

var SingletonSet = AbstractEnumerableSet.extend(
    function SingletonSet(member) { this.member = member;},
    {
        contains:function (x) { return x === this.member;},
        size:function () { return 1;},
        foreach:function (f,ctx) { f.call(ctx,this.member);}
    }
);


//AbstractWritableSet是AbstractEnumerableSet的抽象子类
//它定义了抽象方法add()和remove()
//然后实现了非抽象方法union()、intersection()和difference()

var AbstractEnumerableSet = AbstractEnumerableSet.extend(
    function () { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);},
    {
        add:abstractmethod,
        remove:abstractmethod,
        union:function (that) {
            var self = this;
            that.foreach(function (v) { self.add(v);});
            return this;
    },
    intersection:function (that) {
        var self = this;
        that.foreach(function (v) { if(!that.contains(v)  self.remove(v);)});
        return this;
    },
    difference:function (that) {
        var self = this;
        that.foreach(function (v) { self.remove(v);});
        return this;
    }
});


//ArraySet是AbstractWritableSet的非抽象子类
//它以数组的形式表示集合中的元素
//对于它的contains()方法使用了数组的线性查找
//因为contains()方法的算法复杂度是O(n),而不是O(1)
//它非常适用于相对较小型的集合，这里的实现用到了indexOf()和forEach()

var ArraySet = AbstractWritableSet.extend(
    function ArraySet() {
        this.values = [];
        this.add.apply(this.arguments);
    },
    {
        contains:function (v) { return this.values.indexOf(v) != -1;},
        size:function () { return this.values.length;},
        foreach:function (f,c) { this.values.forEach(f,c);},
        add:function () {
            for (var i = 0;i &lt; arguments.length;i++) {
                var arg = arguments[i];
                if(!this.contains(arg)) this.values.push(arg);
            }
            return this;
        },
        remove:function () {
            for (var i = 0;i &lt; arguments.length;i++) {
                var p = this.values.indexOf(arguments[i]);
                if(p === -1) continue;
                this.values.splice(p,1);
            }
            return this;
        }
    }
);
</code></pre><h3 id="8、ECMAScript5中的类"><a href="#8、ECMAScript5中的类" class="headerlink" title="8、ECMAScript5中的类"></a>8、ECMAScript5中的类</h3><p>ES5中给属性特性增加了方法支持（getter、setter、可枚举性、可写性和可配置性），还增加了对象可扩展性的限制。</p>
<h4 id="让属性不可枚举"><a href="#让属性不可枚举" class="headerlink" title="让属性不可枚举"></a>让属性不可枚举</h4><p>for example 13：</p>
<pre><code>//定义不可枚举的属性
//将代码包装在一个匿名函数中，这样定义的变量就在这个函数作用域内
(function () {
    //定义一个不可枚举的属性objectId，它可以被所有对象继承
    //当读取这个属性时调用getter函数
    //它没有定义setter，因此它是只读的
    //它不可配置，因此不能删除
    Object.defineProperty(Object.prototype,&quot;objectId&quot;,{
        get:idGetter,//取值器
        enumerable：false,//不可枚举
        configurable：false,//不可配置
    });

//当读取objectId的时候直接调用这个getter函数
function idGetter() {//getter函数返回该id
    if(!(iddrop in this)) {//如果对象中不存在id
        if(!Object.isExtensible(this))//并且可以增加属性
            throw Error(&quot;Can&apos;t define id for noneextensible objects&quot;);
        Object.defineProperty(this,idprop,{//给它一个值
                value:nextid++,//就是这个值
                writable:false,//只读
                enumerable:false,//不可枚举
                configuable:false//不可删除
            });
        }
        return this[iddrop];//返回已有的或新的值
    };

    //idGetter()用到了这些变量，这些都属于私有变量
    var iddrop = &quot;|**objectId**|&quot;;//假设这个属性没有用到
    var nextid = 1;//给它设置初始值

}());//立即执行这个包装函数
</code></pre><h3 id="9、模块化"><a href="#9、模块化" class="headerlink" title="9、模块化"></a>9、模块化</h3><h4 id="用做命名空间的对象"><a href="#用做命名空间的对象" class="headerlink" title="用做命名空间的对象"></a>用做命名空间的对象</h4><p>模块化的过程中为了避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为空间的对象属性储存起来，而不是定义全局函数和变量。例如Set()构造函数，是全局的，然后给这个类定义了很多实例方法，但将这些方法存储到Set.prototype的属性中，因此就不是全局的。</p>
<p>for  example  14：</p>
<pre><code>var collections;//声明这个全局变量
if(!collections)//如果它原本不存在
    collection = {};//创建一个顶层的命名空间对象
collection.sets = {};//将sets命名空间创建在它的内部
//在collections.sets内定义set类
collections.sets.AbstractSet = function () {}
</code></pre><h4 id="作为私有命名空间的函数"><a href="#作为私有命名空间的函数" class="headerlink" title="作为私有命名空间的函数"></a>作为私有命名空间的函数</h4><p>将模块定义在某个函数的内部实现。</p>
<p>for example 15：</p>
<pre><code>//模块中函数的Set类
//声明全局变量Set，使用一个函数的返回值给它赋值
//函数结束时紧跟一对圆括号说明这个函数定义后立即执行
//它的返回值赋值给set，而不是将这个函数赋值给Set
//这是一个函数表达式，不是一条语句，因此函数&quot;invocation&quot;并没有创建全局变量

var Set = (function invocation() {
    function Set() {//这个构造函数是局部变量
        this.values = {};//这个对象的属性用来保存这个集合
        this.n = 0;//集合中的值的个数
        this.add.apply(this,arguments);//将所有的参数都添加到集合中
    }

    //给Set.prototype定义实例方法
    //省略部分代码
    Set.prototype.contains = function(value) {
        //我们调用了v2s()，而不是调用笨重的set._v2s()
        return this.values.hasOwnProperty(v2s(value));
    }} ());//定义后立即执行
</code></pre><p>OR：</p>
<pre><code>var collections;//声明这个全局变量
if(!collections)//如果它原本不存在
    collection = {};//创建一个顶层的命名空间对象
collection.sets = (function invocation() {
    function Set() {//这个构造函数是局部变量
        this.values = {};//这个对象的属性用来保存这个集合
        this.n = 0;//集合中的值的个数
        this.add.apply(this,arguments);//将所有的参数都添加到集合中
    }

    //给Set.prototype定义实例方法
    //省略部分代码
    Set.prototype.contains = function(value) {
        //我们调用了v2s()，而不是调用笨重的set._v2s()
        return this.values.hasOwnProperty(v2s(value));
    }} ());//定义后立即执行
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[函数基础知识学习]]></title>
      <url>/2017/06/29/function/</url>
      <content type="html"><![CDATA[<h1 id="我们的主题是什么？"><a href="#我们的主题是什么？" class="headerlink" title="我们的主题是什么？"></a>我们的主题是什么？</h1><p>函数是一种特殊的对象，有自己的属性和方法，而这些个属性和方法是什么我们必须知道，什么样子是函数，函数的用处有哪些，这些是我们必须明确知晓的。</p>
<h2 id="一、函数的结构"><a href="#一、函数的结构" class="headerlink" title="一、函数的结构"></a>一、函数的结构</h2><p>函数体的组成部分必须包括：关键字function、函数名、一对圆括号、一对花括号、参数；</p>
<p>函数的声明方式有：函数语句式和函数定义式：</p>
<p>for example 1：</p>
<pre><code>① function  funcName() { //代码块} funcName();
② var f = function() {//代码块}  f();
</code></pre><p>注意第二种是把函数赋值给了一个函数，这里有和变量的声明一样的问题，就是声明提前的现象。</p>
<p>参数有形参和实参两种形式，形参是函数定义的时候出现的，而实参是函数调用的时候出现的，形参类似于局部变量，实参是一种类数组对象，名称为arguments，通过下标就能访问实参元素。</p>
<p>我们需要知道的是形参和实参的数量如果不相等的时候，若形参数量多于实参则属于undefined，如果实参多的话则会被自动省略掉。当然前面也说了实参列表是个类数组对象，我们可以用arguments来表达一个实参列表，这里就能用arguments来表示任意数量的实参个数了。</p>
<p>函数从被定义开始到调用为止，定义是一次完事，而调用的话则可以被调用任意次数。定义已经说完，就说调用。</p>
<h2 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h2><p>函数的调用有4中方式：函数调用、方法调用、构造函数调用和用call()和apply()的间接调用。</p>
<h3 id="1、函数调用"><a href="#1、函数调用" class="headerlink" title="1、函数调用"></a>1、函数调用</h3><p>这是最普通的调用了，解释器到达结尾返回undefined，碰到return语句，返回其值，没有值的话返回undefined。</p>
<p>注意的是，在非严格模式中，this返回的是全局对象不然就是undefined。</p>
<h3 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h3><p>函数作为对象的一个方法被调用，与函数调用的最大区别就是this值的不同，方法调用的this值的上下文是函数所处的对象。</p>
<p>当然，如果想要在函数调用中的this值是外部函数，则必须在外部函数的函数体内使用 <strong>var self = this</strong>，这样的话，就能达到this值就是外部函数了。</p>
<h3 id="3、构造函数调用"><a href="#3、构造函数调用" class="headerlink" title="3、构造函数调用"></a>3、构造函数调用</h3><p>构造函数必须用到new关键字，构造函数初始化了一个对象，这个对象的属性继承于prototype属性，而且this值指向的就是这个初始化了的对象。</p>
<p>构造函数调用允许省略实参列表和圆括号。</p>
<h3 id="4、间接调用"><a href="#4、间接调用" class="headerlink" title="4、间接调用"></a>4、间接调用</h3><p>用call()和apply()来达到某个对象使用某个函数作为方法的目的，这两种方法里的第一个实参的this值是这个使用函数的对象。无论哪个对象都可以使用本身所不具备的函数作为方法。call()的后面的参数是实参列表，但是apply()方法的后面就是个数组形式的实参列表了。</p>
<p>下面就说说作为一个整体的函数的情况吧，函数可以赋值给一个值，可以作为参数传给另外一个参数。</p>
<h2 id="三、函数的整体使用"><a href="#三、函数的整体使用" class="headerlink" title="三、函数的整体使用"></a>三、函数的整体使用</h2><h3 id="1、嵌套函数"><a href="#1、嵌套函数" class="headerlink" title="1、嵌套函数"></a>1、嵌套函数</h3><p>这里就有个作用域规则的事情，任何变量都能在他的函数体内发生作用，因为函数体是嵌套的，所以就有了嵌套的作用域，就有了作用域链，虽然外部函数不能访问到内部函数，但是可以把内部函数作为返回值返回出来。这里就会涉及到一个叫做闭包的技术，意思就是函数体通过作用域链关联起来（外部函数和嵌套函数是有关系的），函数体内的变量可以保存在作用域内。</p>
<h3 id="2、作为命名空间的函数"><a href="#2、作为命名空间的函数" class="headerlink" title="2、作为命名空间的函数"></a>2、作为命名空间的函数</h3><p>变量有全局变量，有局部变量。而我们不想让全局变量来污染全局作用域，那就必须用个函数来包括起来整个其他函数。方式有2：</p>
<p>for example 2：</p>
<pre><code>function func() {
    //模块代码
    //所有变量均为局部变量，不污染全局命名空间
}
func();//必须得调用
</code></pre><p>再有一种方式：</p>
<pre><code>(function(){

//代码块}())//立即调用，这是个定义表达式
</code></pre><h2 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h2><p>这个就是运用一些有一定含义的关键字来编写程序，比如可以用reduce()来计算数组合成一个数字的运算，而不用采取遍历计算的方式，等等吧。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数组基础知识]]></title>
      <url>/2017/06/23/Array/</url>
      <content type="html"><![CDATA[<h1 id="我们得知道这节的主题是什么："><a href="#我们得知道这节的主题是什么：" class="headerlink" title="我们得知道这节的主题是什么："></a>我们得知道这节的主题是什么：</h1><p><strong>一是数组是什么，长什么样子，我们看到了就能一眼认出来这个是不是数组；</strong></p>
<p><strong>二我们怎么创建数组，讲解的是数组的声明方式；</strong></p>
<p><strong>三是我们须知数组的一些属性和方法，因为数组不是你想怎么来就怎么来的，你必须按一定的套路走才是可行的；</strong></p>
<p><strong>四是我们要知道数组与对象和字符串的关系，因为是近亲所以有更多有意思的事情。</strong></p>
<p><strong>好了接下来一一说。</strong></p>
<h3 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h3><p><strong>数组是一系列值（元素）的有序集合体。</strong>从这里我们来解读一下。</p>
<p>①数组既然是个集合体，那么就有一个范围，来表示这就是一个数组单元，数组的开始和结束标识符就是”[]”,双引号里面的中括号就是一个数组的最基本的构成；</p>
<p>for example1：</p>
<pre><code>var a = [];
var b = [,1,2,7,true,&apos;ww&apos;,{x:1},1];
</code></pre><p>②数组里面的元素是什么，可以使任意数据类型的值的杂合，当然有时候杂合的东西的不容易操作。比如例子1里面的b数组就是个各种数据类型都有的杂合体，JSON无疑就是个数组里面加对象；</p>
<p>③有序，数组里面的元素是有顺序的，顺序是从整数0开始排序的（也就是每个数组的元素都有个索引值，这个索引值就是从0开始的），因此数组b中的两个元素数字1，他们的索引是不一样的，明显的是第一个索引值小，第二个大。</p>
<p>现在我们知道了数组的长相，能辨认数组了，那么接下来我们就看看怎么声明一个数组：</p>
<h3 id="二、数组的声明"><a href="#二、数组的声明" class="headerlink" title="二、数组的声明"></a>二、数组的声明</h3><p>声明数组的方式总的来说有两种：</p>
<p>①仿照对象的声明，通过数组直接量的形式，例子就是例子1；</p>
<p>②就是用个关键字new 来声明：</p>
<p>for example2：</p>
<pre><code>var a = new Array(1,2,3,true,&apos;test&apos;);
</code></pre><p>综合老看推荐的是使用数组直接量的方式来声明一个数组。</p>
<p>这里我们在稍微的说点，稀松数组就是数组里存在一个空的元素，而多维数组就是几个数组的嵌套了，因为数组的元素不是固定的，所以可以有这效果。</p>
<h3 id="三、数组的属性和方法"><a href="#三、数组的属性和方法" class="headerlink" title="三、数组的属性和方法"></a>三、数组的属性和方法</h3><p>数组知识的重点，就是这个数组的属性和方法，再有个重点就是数组与对象和字符串的关系。这次我们就先谈谈这个，分增、删、改、查4个方面来说。</p>
<h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>增的意思是数组的元素增多了，这个增多可以是原来数组的值的增加，也可以是形成了一个新的数组，这就意味着数组的length是变大了。好！开始介绍方法。</p>
<p>①、先来个不改变原来数组的:concat(),他的意思是把两个数组的元素给拼接起来,或者就是把元素添加到数组的元素中去：<br>for example4：</p>
<pre><code>var d = [1,3];
var dd = d.concat(&apos;1&apos;,2,4);//不改变原来的数组[1,3,&apos;1&apos;,2,4]
var ddd = d.concat([1,3,5],[4,7]);//[1,3,1,3,5,4,7]
</code></pre><p>②、通过索引为数组增加值，变化的是原来的数组：</p>
<p>for example3：</p>
<pre><code>var c = [];
c[0] = 1;//c = [0]
c[1] = 2;//c = [0,2]
c[3] = &apos;test&apos;;//c = [0,2,&apos;test&apos;]
</code></pre><p>③、push(),改变了原来的数组，意思是往原来的数组的末尾加一个或多个元素,这个和pop()组成了类似于栈的先进后出的感觉：</p>
<p>for example4：</p>
<pre><code>var pushes = [&apos;hello&apos;,&apos;2&apos;,22];
    pushes.push(11,77);//这样既可[&apos;hello&apos;,&apos;2&apos;,22,11,77]
</code></pre><p>④、unshift(),类似于push()，不过unshift()是把元素添加到了原数组元素的第一个位置：</p>
<p>for example4：</p>
<pre><code>var unshifted = [&apos;hello&apos;,&apos;2&apos;,22];
    unshifted.unshift(11,77);//这样既可[11,77,&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>⑤、splice(),这个比较特殊，因为他能增加也能减少，同样的是他改变的也是原来的数组,splice()方法里有三个参数，第一个为必填的，后两个为可选的，第一个参数是数组的索引值，是个整数，第二个意思是从第一个索引值的位置开始要去掉几个元素,这个值可以为负值，最后一个参数意思是去掉了参数，我们用什么来填补，是我们要填补的元素,返回的值是删除元素组成的数组：</p>
<p>for example5：</p>
<pre><code>var s = [&apos;hello&apos;,&apos;2&apos;,22,11,77];
    s.splice(0,3);//返回[&apos;hello&apos;,&apos;2&apos;,22]
    s.splice(0,3，&apos;world&apos;,33);//返回[&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>以上就是增，下面说说删。</p>
<h4 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h4><p>因为说过了增，删的部分大部分是对应的，所以我们就把那些不对应的讲解一下：</p>
<p>①、delete，这是个运算符，他删除的是元素的值，至于数组的length是不变的，去掉的是数组的元素值，去不掉的是数组的属性。</p>
<p>for example6：</p>
<pre><code>var del = [1,2,3];
delete del[2];//在原数组中就没有了元素3，但是数组的length仍旧是3
</code></pre><p>②、pop(),对比push()去吧！</p>
<p>③、shift(),对比unshift()去吧！</p>
<p>④、splice()</p>
<h4 id="3-改和查"><a href="#3-改和查" class="headerlink" title="3.改和查"></a>3.改和查</h4><p>把改和查放在一起，因为我们会感觉到他们是一体的。</p>
<p>①、slice(),能接收两个参数，第一个参数是必须的，为整数值，第二个参数为可选的，为整数值，都可为负值，不改变原有的数组,截取的值包前不包后：</p>
<p>for example7：</p>
<pre><code>var sl = [1,2,3];
sl.slice(0,1);//返回[1]
</code></pre><p>②、reverse(),把数组的元素值给倒过来排序，改变了原来的数组元素的排序：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3];
revers.reverse();//返回[3,2,1]
</code></pre><p>③、sort(),把数组的元素按英文字母的顺序进行排序，也就是ASC11的顺序，这个可以接受一个比较函数，进行更好运算：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3,10];
revers.sort();//返回[1,10,2,3]
revers.sort(function(x,y) {
        return x-y;
    });//返回的就是按数字大小比较后的顺序的数组了
</code></pre><p>对一个字符串数组执行不区分大小写的字符表排序，比较函数首先将参数转化为小写字符串，再开始比较：</p>
<p>for example8：</p>
<pre><code>var a = [&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;];
a.sort();//返回[&apos;Bug&apos;,&apos;Dog&apos;,&apos;ant&apos;,&apos;cat&apos;]
a.sort(function(x,y) {
        var a = x.toLowerCase();
        var b = y.toLowerCase();
        if (a &lt; b) return -1;
        if (a &gt; b) return 1;
        return 0;
    });//返回[&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;]
</code></pre><p>这里我们再简单的说说例子7和例子8中，比较函数的工作原理，我们传进去的是两个参数，所以这个比较函数每次的比较是两个两个进行比较的，每次比较后就进行一次两个元素位置的调换，而如果前(n-1)个元素没有排好序的话（说的就是最后一个元素前的元素如果已经排好序，那就直接进行第n-1个元素与最后一个元素的比较就可以了），正常情况下，我们是要用前面n-1个元素来与第n个元素进行比较的。如果想自己看看操作的话，就用chrome自己打个断点，自己看看他的工作流程。</p>
<p>④、遍历：for循环和forEach(),都是遍历数组内的每个元素，不同的是前者有个break可以跳出，后者想要终止的话，则必须把forEach()放到try()块中,里面传进去的是个函数：</p>
<p>for example8：</p>
<pre><code>function foreach(a,f,t) {
    try {a.forEach(f,t);}
    catch(e) {
        if (e === foreach.break) return;
        else throw e;
    }
}
foreach.break = new Error(&quot;StopIteration&quot;);
</code></pre><p>⑤、映射，这里就是用map()，就是数学函数里映射，一对一，里面包括一个函数：</p>
<p>for example9：</p>
<pre><code>var a = [1,3,4];
b = a.map(function(x) {
return x*x;});//返回的就是[1,9,16],返回的是新的数组，不修改原来的数组
</code></pre><p>⑥、过滤，就是用某个条件作为筛选，用到的是filter(),这个方法会过滤掉undefined和null，他返回的总是稠密数组不会是稀疏数组：</p>
<p>for example10：</p>
<pre><code>var a = [5,4,3,2,1];
smallValues = a.filter(function(x) { return x &lt; 3;});
other = a.filter(function(x) { return x%2 == 0;});//参数可以多个

a = a.filter(function(x) { return x !== undefined &amp;&amp; x !== null;});//过滤掉undefined和null元素
</code></pre><p>⑦、every()和some()，这里返回的是个boolean值：</p>
<p>for example11：</p>
<pre><code>var a = [1,2,3,4,5];
a.every(function(x) {return x &lt; 10;});//返回的就是true
a.every(function(x) { return x % 2 == 0;});//返回false
</code></pre><p>而如果用some()来代替every()的话，就全是true了，因为some()意思是存在而every()是全部的意思。</p>
<p>⑧、reduce()和reduceRight()，他们的意思就是通过某个函数把数组的元素整合为单个值，需要传进去两个参数，不过以数值和对象为主，前者是从低索引开始后者从高索引开始：</p>
<p>for example 12：</p>
<pre><code>var a = [1,2,3,4,5];
var sum = a.reduce(function(x,y) {
    return x+y;},0);//0是初始值，可以不要，返回15
var max = a.reduce(function(x,y) {
    return (x &gt; y) ? x :y;});//求最大值
var product = a.reduce(function(x,y) {
    return x * y;},1);//乘积
</code></pre><p>下面说说对象的形式吧！</p>
<p>for example 13:</p>
<pre><code>var objects = [{x:1},{y:2},{z:3}];
var merged = objects.reduce(union);//返回{x:1,y:2,z:3}，是对象的集合

var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
var leftUnion = objects.reduce(union);//返回{x:1,a:1,y:2,z:3}
var rightUnion = objects.reduceRight(union);//返回{x:1,y:2,z:3,a:3}
</code></pre><p>⑨、indexOf()和lastIndexOf()，里面填写的是元素，返回的是这个元素的位置的索引，如果元素重复，返回的是第一个元素的位置的索引值，这两个方法方向相反，如果没有的话就返回-1,有两个参数，第二个参数可选，意思是要从哪个索引开始：</p>
<p>for example 14:</p>
<pre><code>var a = [0,1,2,1,0];
a.indexOf(1);//1
a.indexOf(3);//-1，因为没有这个值
a.lastIndexOf(1);//3
</code></pre><p>for example 15:</p>
<pre><code>//在数组中查找所有出现的x,并返回一个匹配数组索引的数组
function findAll(a,x) {
    var results = [],
        len = a.length,
        pos = 0;
    while(pos &lt; len) {
        pos = a.indexOf(x,pos);
        if (pos === -1) break;
        results.push(pos);
        pos +=1;
    }
    return results;
}
</code></pre><h3 id="四、数组的亲密关系"><a href="#四、数组的亲密关系" class="headerlink" title="四、数组的亲密关系"></a>四、数组的亲密关系</h3><p>数组的亲密关系牵扯到两个：一是字符串；二是对象，无论哪个都可以有数组的一些特性，如:自动更新length、设置length来获取一段数组、从Array.prototype来继承有用的方法、其类属性为Array：</p>
<h4 id="1-与字符串的关系"><a href="#1-与字符串的关系" class="headerlink" title="1.与字符串的关系"></a>1.与字符串的关系</h4><p>①、join()和split()这是一对，前者把数组元素以某种方式拼接起来并输出一个字符串，后者是把字符串以某个元素为分界线分为数组，不再举例子；</p>
<p>②、toString()和toLocalString(),与join()类似，把数组元素转化为字符串，后者是以本地化分隔符连接元素生成字符串；</p>
<p>③、说说继承Array.prototype的方法：</p>
<p>for example 16:</p>
<pre><code>var s = &quot;JavaScript&quot;;
Array.prototype.join.call(s,&quot; &quot;);//&quot;J a v a S c r i p t&quot;,继承了join()方法
Array.prototype.filter.call(s,function(x) {
        return x.match(/[^aeiou]/);}).join(&quot;&quot;);//筛选掉了元音字母，&quot;JvScrpt&quot;
</code></pre><p>切记，字符串不能改变的，他们是只读的，对于那些push()、sort()、reverse()、splice()这些方法是不能使用的。</p>
<h4 id="2-类数组对象"><a href="#2-类数组对象" class="headerlink" title="2.类数组对象"></a>2.类数组对象</h4><p>这个我们还是能经常碰到的，譬如用document.getElementsByName()这个方法时得到的就是个类数组。</p>
<p>for example 17：</p>
<pre><code>var a = {&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3};//类数组对象
Array.prototype.join.call(a,&apos;+&apos;);//&apos;a+b+c&apos;
Array.prototype.slice.call(a,0);//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],真正的数组副本
Array.prototype.map.call(a,function(x) {
        return x.toUpperCase();});//[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]
</code></pre><h3 id="五、其他：数组类型"><a href="#五、其他：数组类型" class="headerlink" title="五、其他：数组类型"></a>五、其他：数组类型</h3><p>判断是不是数组我们用两个方式：</p>
<h4 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1.Array.isArray()"></a>1.Array.isArray()</h4><pre><code>Array.isArray([]);//true
Array.isArray({});//false
</code></pre><h4 id="2-instanceOf运算符"><a href="#2-instanceOf运算符" class="headerlink" title="2.instanceOf运算符"></a>2.instanceOf运算符</h4><pre><code>[] instanceOf Array;//true
({}) instanceOf Array;//false
</code></pre><h1 id="告一段落，下次看函数"><a href="#告一段落，下次看函数" class="headerlink" title="告一段落，下次看函数"></a>告一段落，下次看函数</h1>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[语句]]></title>
      <url>/2017/05/26/%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>一、表达式语句</strong></p>
<p>表达式语句常见的就是两类：赋值语句和函数调用，声明语句有var声明和function声明。</p>
<p><strong>二、条件语句</strong></p>
<p>条件语句两种if语句和switch语句，这里就说说switch语句：</p>
<pre><code>switch(n){
case ①;
//代码块
break；
case ②；
//代码块
break;
default;
//代码块
break;
}
</code></pre><p>传进来参数与①、②、③进行匹配，如果n与某个值恒等时，就执行相应的代码块。</p>
<p><strong>三、use strict（严格模式）与非严格模式的比较</strong></p>
<p>use strict语句的目的是说明脚本或者函数体的后续代码将会解析为严格代码。如果放在顶层了，那么就是严格代码。</p>
<p>use strict和普通语句的区别：</p>
<p>1.不包含任何语言的关键字，对于JavaScript解释器来说，它只是一条没有副作用的表达式语句，什么也没有做。</p>
<p>2.use strict只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。并不一定是出现在首行。</p>
<p>严格模式与非严格模式的区别</p>
<p>1.严格模式中禁止使用with语句；</p>
<p>2.所有的变量都要先声明；</p>
<p>3.严格模式中，调用的函数中的一个this值是undefined，非严格模式中调用的函数中的this值总是全局对象；</p>
<p>4.严格模式中，通过call（）或者apply（）来调用函数时，其中的this值就是通过call（）或者apply()传入的第一个参数（非严格模式中，null和undefined值被全局对象和转换为对象的非对象所代替）；</p>
<p>5.严格模式中，给只读属性赋值和给不可扩展的对象创建新成员时，会抛出一个类型错误的异常，在非中仅仅是操作失败；</p>
<p>6.严格模式中，函数的arguments对象拥有传入函数值的静态副本，非中arguments的数组和函数都是指向同一个值的引用；</p>
<p>7.严格模式中，当delete运算符后跟随非法的标识符（变量、函数、函数参数）时，会抛出语法错误，非严格模式中，delete什么也没有做，返回false；</p>
<p>8.严格模式中，在一个函数直接量中定义两个或多个同名属性将产生一个语法错误；</p>
<p>9.严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误，非中不会报错；</p>
<p>10.严格模式中，标识符eval和arguments当作关键字，它们的值是不能更改的。不能赋值、声明为变量、用作函数名、用作函数参数或者用作catch块的标识符；</p>
<p>11.严格模式中限制了对调用栈的检测能力，arguments.caller和arguments.callee都会抛出一个类型错误异常。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[部分运算符]]></title>
      <url>/2017/05/25/%E9%83%A8%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p><strong>1.in运算符</strong></p>
<p>in运算符左右有两个位置，左边的位置放的是字符串或者可以转化为字符串的值，右边的是对象，如：数组、对象。<br><img src="/image/in.jpg" alt=""></p>
<p>一般情况是字符串匹配的是对象，字符串的内容是属性名；是数字的时候匹配的是数组，数字是索引。</p>
<p><strong>2.instanceof运算符</strong></p>
<p>这个运算符是区分对象的类的，这里多提一点，区分对象的类的方法还有通过class特性和constructor属性，这两种方式，instanceof和in运算符类似，有两个操作数，不同的是①的位置是个对象，②的位置是个对象的类。<br><img src="/image/instanceof.jpg" alt=""></p>
<p>这个操作的返回值是个布尔值，如果①是②的实例化对象，则返回值是true，不是的话则返回值是false。这个寻找过程是：在原型链中找到①这个对象，再在①的原型链中找②.prototype,如果有的话就返回true，否则的话返回false。</p>
<p><strong>3.typeof运算符</strong></p>
<p>typeof运算符是我们经常用到的，我们用它来区分原始值和对象，typeof后面跟的可以是任意值。typeof是个一元运算符，我们要注意到和instanceof的不同。</p>
<p>使用形式有两种方式：  </p>
<pre><code>typeof &apos;hello world&apos;;//这里用到的是字符串
</code></pre><p> OR </p>
<pre><code>typeof (&apos;hello world&apos;);
</code></pre><p><strong>注意：</strong>typeof将函数区别对待，返回值页特殊。</p>
<p><strong>4.三元运算符</strong></p>
<p><img src="/image/three.jpg" alt=""></p>
<p>三元运算符有3个操作数，①的返回值是个布尔值，如果返回的是true，则执行②，并得出返回值，如果是false则执行③，这个比用if语句更加简洁。</p>
<p>最后说eval(),里面放进去的是字符串，返回的是一个值，因为只有字符串才会被编译（parse），其他的值放进去只会被原封不动地返回来，它是动态的，实际中运用之处微乎极微，可以考虑不使用。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[变量声明及作用域]]></title>
      <url>/2017/05/22/variable-key/</url>
      <content type="html"><![CDATA[<p>变量声明有两种方式一是用<strong>var</strong>关键词再有就是用<strong>function</strong>关键词，声明使代码具有了语义。</p>
<p>var关键词声明变量在函数体内是局部变量在函数体外是全局变量，不用var声明变量无论在函数体内还是函数体外都是全局变量，后种方式声明的变量是可以用运算符delete删除掉声明的变量的，var关键词声明的变量不能被删除掉。</p>
<p>作用域就是变量能发生作用的范围，JavaScript不像C那样：变量在声明它们的代码块之外是不可见的，C是块级作用域。而JavaScript的作用域是全局作用域和局部作用域，变量在声明他们的函数体内及函数体的嵌套函数体内都是可见的。</p>
<p>变量在未声明之前是可以使用的，变量的生命提前使得变量的声明提前到函数体的顶部。</p>
<p>下面说说作用域链，作用域链从把变量的声明当作对象的属性看待说起，作用域链就是个查找的过程了。在《JavaScript权威指南》里的原话放在这里，当定义一个函数时，它实际上保存一个<strong>作用域链</strong>，当调用这个函数时，他创建一个新的对象来存储他的<strong>局部变量</strong>，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。对于嵌套函数来说，事情变得更加有趣，每次<strong>调用外部函数</strong>时，<strong>内部函数又会重新定义一遍</strong>。因为每次<strong>调用外部函数的时候，作用域链都是不同的</strong>。内部函数在每次定义的时候都有微妙差别—在每次调用外部函数，内部函数的代码都是相同的，而关联这段代码的作用域不相同。</p>
<p>调用外部函数的时候，内部函数重新定义，这是由于作用域链的不同。大致理解了它的原理。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[对象]]></title>
      <url>/2017/05/21/object/</url>
      <content type="html"><![CDATA[<h2 id="一、综合概述"><a href="#一、综合概述" class="headerlink" title="一、综合概述"></a><strong>一、综合概述</strong></h2><p><strong>1.全局对象：</strong></p>
<p>全局属性：undefined、NaN、infinity</p>
<p>全局函数：isNaN()、parseInt()、eval()</p>
<p>全局对象：Math、JSON</p>
<p>构造函数：Date（）、RegExp()、String（）、Object（）、Array（）</p>
<p><strong>2.包装对象</strong></p>
<p>JavaScript里有些原始值如：字符串、数字、布尔值，它们是有自己的属性和方法的，那么它们不是对象，属性和方法又从何而来呢？</p>
<p>那我们就先从说对象说起，对象是一系列属性名和属性值的集合体。对象要引用属性值就用”.”加上属性名来引用；对象里的方法是用函数表示的，引用的时候用o.m()来表示。</p>
<p>不同的是，原始值里的字符串、数字和布尔值的属性和方法是不能被定义新的值的，而对象里面是能改变的。</p>
<p>在例子中：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;
s.indexOf(&apos;t&apos;) = 0;
</code></pre><p>在上面的例子中s是字符串，但是具有自己的属性和方法，它的实现方式是在s引用自己的属性和方法时，就会通过new String(s)创建一个临时对象，这个对象会继承s的特点。这个临时对象在用到的时候会被创建出来，一旦不用就会被销毁。</p>
<p>例如：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;//这里是设置的新的属性值
var t = s.len;
console.log(t);//undefined
</code></pre><p>在s.len = 4;使用完后，这个属性就被销毁了，不会在往下传递了，所以打印的结果是undefined；不是length哟！代码测试如果用下面的代码：</p>
<pre><code>var s = &apos;test&apos;;
s.length = 4;
var t = s.length;
console.log(t);//这个结果就是4了
</code></pre><p>可以运用构造函数来显示的创建包装对象，</p>
<pre><code>var s = &apos;test&apos;,n = 1,b = true;
var S = new String(s);
var N = new Number(n);
var B = new Boolean(b);
</code></pre><p>如果我们用’ == ‘来判断s与S、n与N、b与B的话，结果是true；如果用’ === ‘恒等式来判断的话，就不是这个结果了。</p>
<p>JavaScript中的值的类型会根据需要字型转变，无论进行什么运算，共同的值类型是每个单独的值都能转换过去的，转换的又隐式转换和显式转换</p>
<p>for example： </p>
<pre><code>&apos;5&apos; * &apos;6*;//30,//改变就是从字符串变化到了数字类型

 30 + &apos;object&apos;;//这里就只能转变为字符串了
</code></pre><p>parseInt() =&gt;意思是把值转换为16进制的，目前就是这么多了！不足的话就再加补充。</p>
<h2 id="二、对象的创建"><a href="#二、对象的创建" class="headerlink" title="二、对象的创建"></a>二、对象的创建</h2><p>ES5中创建对象有3中方式，对象直接量、new关键字和Object.create()，这3种方式。</p>
<p>for example：</p>
<p>①对象直接量，就是直接表示出对象里面的属性和方法：</p>
<pre><code>var o = {x:1,y:2,z:function (){alert(1);}
</code></pre><p>②new关键字，就是创建一个新的对象的意思：</p>
<pre><code>var o = new Object();
o.x = 1;
o.y = 2;
</code></pre><p>③第三种方式利用到了继承的性质，Object.create(<em>,</em>);这里面有两个参数，前面的是必须填写的，意思是某个对象继承了那个对象，当然也可以填写null，后面的第二个参数是个可选的参数：</p>
<pre><code>var o1 = Object.create({x:1,y:2});//o1继承了{x:1,y:2}的属性

var o2 = Object.create(null);
</code></pre><p>在o1的情况中涉及到了继承，一会说。</p>
<p>通过原型继承创建一个新对象</p>
<pre><code>//inherit()返回一个继承原型对象p的属性的新对象
function inherit(p){
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);//如果存在就是用它
    var t = typeof p;
    if (t !== &apos;object&apos; &amp;&amp; t !== &apos;function&apos;) throw TypeError();
    function f(){};
    f.prototype = p;
    return new f();
}
</code></pre><h2 id="三、属性的查询和设置"><a href="#三、属性的查询和设置" class="headerlink" title="三、属性的查询和设置"></a>三、属性的查询和设置</h2><p>我们要查询对象的属性时有两种方式：</p>
<p>1.是通过”.”:例如，o.name或者o.m(),来寻找属性或者方法；</p>
<p>2.通过[]来寻找或者设置：例如，o.[‘name’]，这里就要知道对象有时候也称为关联数组、散列或者字典；</p>
<p><strong>注意：</strong>JavaScript里面我们是不能通过第一种方式来改变属性名字的，因为我们不能改变一个标识符，不过我们能改变数据类型里的数据，而后一种方式就是数据类型里的字符串，是可以改变的。</p>
<p>既然谈到了属性那么我们得知道JavaScript的对象里面属性有自有属性和继承属性两种，继承属性则意味着这个属性不是自己独有的，是属于另外一个对象的，自己不过是使用了而已。</p>
<p>这里就先捋清原型、原型链、继承、类、对象之间的关系，其中原型和类再加上可扩展性是对象的3个属性。</p>
<p>我们先把一类东西，比如人给抽象出来，把人所具有的一般特征用属性和方法表示出来，意思就是一类人，对象的类属性用toString()返回的是一个字符串，表示的意思对象的类型信息。</p>
<p>原型与继承相关，这里就有涉及到了原型链，我们在查询对象o的属性时首先是到<br>对象的自有属性里查询，如果没有的话就到对象的原型里查询，再没有的话就到对象原型的原型里查询，一直到null为止，这么看来就有了一个链条的感觉。</p>
<p>如果是给属性赋值的话，失败的话，可能是属性为可读的但不可写，成功的话，就会有不同的答案了，要么创建一个属性，要么在原始对象中设置属性，例外的是如果o的属性是继承于属性x，而x属性是一个具有setter方法的accessor属性的话，就会有o直接调用setter方法，不会创建创建属性了，这个不会改变原型链。</p>
<p><strong>再谈谈setter和getter方法。</strong></p>
<p>对象是由属性名、属性值和一组特性组成，ES5中，属性值可以由一个或两个方法来代替，这两个方法就是getter方法和setter方法，由getter方法和setter方法定义的属性就是存取器属性（accessor property），不同于数据属性，存取器属性不具有可写性，要么是可读性要么是读/写性，也就是说如果只有setter方法的话，会返回的值是undefined。</p>
<p><strong>注意：定义存取器最简单的方法是采用对象的直接量语法的一种扩展写法</strong></p>
<p>形式：</p>
<pre><code>var o = {
    data_prop = value,
    get accessor_prop(){},//返回，这里是以逗号结尾的 
    set accessor_prop(value){}//设置
}
</code></pre><p>可用的地方是，我们可以传入一个值，然后返回一个不同的新值，这里就是数据双向绑定的最根本的开始喽！</p>
<p>权威指南上有个例子，在这里展示一下：2D笛卡尔点坐标</p>
<pre><code>var p = {
    //x,y均为普通的可读写的数据属性
    x：1.0，
    y:1.0,
    //r为可读写的存储器属性，它有setter和getter
    //函数体结束后不要忘了带上逗号
    get r(){
        return Math.sqrt(this.x*this.x + this.y*this.y);},
    set r(newValue){
        var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
        this.x *= ratio;
        this.y *= ratio;
    },
    //theta是只读存取器属性，只有getter方法
    get theta() { return Math.atan2(this.y,this.x);}
}
</code></pre><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1.属性访问错误</strong></p>
<p>同理既然是错误就是我们不想要的系统报错，两种方式：对象存在属性不在或者就是对象本身就不在</p>
<p><strong>2.删除属性</strong></p>
<p>只能删除自有属性，继承属性不能被删除，而delete运算符其实是断掉了属性与宿主的关系，对于属性中的属性则没有操作到，就是不是真正的删掉了属性，这个时候可能因为内存泄漏的原因，我们需要遍历属性中的属性，并删去</p>
<p>大家可以试试这个例子：</p>
<pre><code>var a = {p:{x:1}};
b = a.p;
delete a.p;
console.log(b.x);//结果依旧是1
//如果delete a.p.x来替代a.p的话，结果就是undefined了
</code></pre><p><strong>3.检测属性</strong></p>
<p>检测属性就用in运算符、hasOwnProperty()、propertyIsEnumerable(),这3种方式，in运算符返回的是布尔值，中间的大哥判断的是某个对象是否具有<strong>自有属性</strong>，最后的大哥是个加强版，自有属性还得可枚举性为真，这三者的返回值都是布尔值</p>
<p>for example：</p>
<pre><code>var o = { x:1 }
&apos;x&apos; in o;  //true
&apos;y&apos; in o;  //false
&apos;toString&apos; in o;//true,o继承toString属性
//看看用中间的大哥来检测的结果是什么
o.hasOwnProperty(&apos;x&apos;);//true,是自有属性
o.hasOwnProperty(&apos;y&apos;);//false,没有这个属性
o.hasOwnProperty(&apos;toString&apos;);//false,这个属性是继承得来的，不是自有的

//看看最后大哥的返回值及原因吧

var o = inherit({ y:2 });
o.x = 1;
o.propertyIsEnumerable(&apos;x&apos;);//true,o有一个可枚举的自有属性x
o.propertyIsEnumerable(&apos;y&apos;);//false,o的y属性是继承过来的
</code></pre><p>除此之外还可以通过非恒等式( !== )来判断一个属性值是不是undefined</p>
<pre><code>o.x !== undefined;//true
o.y !== undefined;//false
</code></pre><p>in运算符能区分不存在的属性和存在但值为undefined的属性</p>
<p><strong>4.可枚举性</strong></p>
<p>枚举属性，我们用到的是for/in，它可以枚举遍历对象中的自有属性和继承属性，但对象继承的内置方法不可枚举，添加的属性除非你转化为不可枚举，其他都是可枚举的。</p>
<p>for example:<br>    var o = {x:1,y:2,z:3};//3个可枚举的自有属性<br>    o.propertyIsEnumerable(‘toString’);//false,不可枚举<br>    for(p in o)<br>    console.log(p);</p>
<p>过滤的方法介绍：</p>
<pre><code>for(p in o) {
    if (!o.hasOwnProperty(p)) continue;//hasOwnProperty()是自有属性的检测，不是自有属性，那就是跳过继承的属性了
}

for(p in o) {
    if(typeof o[p] === &apos;function&apos;) continue;} //跳过方法，用的是数据类型的判断
</code></pre><p>用来枚举属性的对象的工具函数</p>
<p>for example：</p>
<p><strong>①.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，则覆盖o中的属性
 这个函数并不处理getter和setter以及复制属性*/

function extend(o,p) {
    for (prop in p) {   //遍历p中的所有属性
        o[prop] = p[prop]; //将属性添加到o中
    }
    return o;
}
</code></pre><p><strong>②.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，o中的属性则不会受到影响
 这个函数并不处理getter和setter以及复制属性*/

function merge(o,p) {
    for(prop in p) {  //遍历p中的所有属性
        if (o.hasOwnProperty[prop]) continue;//筛选掉p中已经存在的属性
        o[prop] = p[prop];将属性添加至o中
    }
    return o;
}
</code></pre><p><strong>③.</strong></p>
<pre><code>/*如果o中的属性和p中的属性没有同名的，则从o中删除这个属性
返回o*/

function restrict(o,p) {
    for(prop in o) {//遍历o中的所有属性
        if(!(prop in p)) delete o[prop];//如果在p中不存在，则删除它，这个删除还是遍历性的删除
    }
    return o;
}
</code></pre><p><strong>④.</strong></p>
<pre><code>/*如果o中的属性和p中的属性有同名的，则从o中删除这个属性
返回o*/

function subtract(o,p) {
    for (prop in p) {//遍历p中的所有属性
        delete o[prop];//把它删掉
    }
    return o;
}
</code></pre><p><strong>⑤.</strong></p>
<pre><code>/*返回一个数组，这个数组包含的是o中可枚举的自有属性的名字*/

function keys(o) {
    if(typeof o !== &apos;object&apos;) throw TypeError();//参数必须是对象
    var result = [];//将要返回的数组
    for (var prop in o) {//遍历所有的可枚举的属性
        if(o.hasOwnProperty(prop))//判断是否是自有属性
        result.push(prop);//将属性名添加到数组中
    }
    return result;//返回这个数组
}
</code></pre><p><strong>5.属性的特性</strong></p>
<p>一个属性包括1个名字和4个特性，数据属性这四个特性是：值(value)、可写性(writable)、可枚举性(enumerable)和可配置性(configurable)。而存取器属性不具有值和可写性的属性，具备的是读取(get)、写入(set)、可枚举性和可配置性。</p>
<p><strong>6.对象的三个属性</strong></p>
<p>每一个对象都有与之相关的原型(property)、类(class)和可扩展性(extensible)。</p>
<p><strong>①原型属性</strong></p>
<p>原型是用来实现继承属性的，原型也是个对象，在实例创建之初就已经设置好了</p>
<p>for example:</p>
<pre><code>var p = {x:1};//定义一个原型对象
var o = Object.create(p);//使用这个原型创建一个对象
p.isPropertyOf(o);//true，o继承p
Object.prototype.isPropertyOf(o);//true，p继承Object.prototype
</code></pre><p><strong>②类属性</strong></p>
<p>对象的类属性是一个字符串，用以表示对象的类型信息，我们只能通过间接的方式来查询它，默认的就是toString()方法，并返回字符串值。</p>
<p>for example：</p>
<pre><code>function classof(o) {
    if (o === null) return &apos;Null&apos;;
    if (o === undefined) return &apos;Undefined&apos;;
    return Object.prototype.toString.call(0).slice(8,-1);
}
</code></pre><p>classof函数可以传入任何参数，数字、字符串乃至布尔值都可以直接调用toString()方法。内置构造函数创建的对象和宿主对象都具有有意义的类属性，通过对象直接量和Object.create创建的对象的类属性是‘Object’，自定义的构造函数创建的对象也是如此，对于自定义的类来说，没办法通过类属性来区分对象的类。</p>
<p>for example：</p>
<pre><code>classof(null);
classof(1);
classof(&quot;&quot;);
classof(true);
classof([]);
classof(new Date());
function f() {};
classof(new f());//Object,这个是一定了
</code></pre><p><strong>③可扩展性</strong></p>
<p><strong>7.序列化对象</strong></p>
<p>对象序列化是指将对象的状态转化为字符串，也可以将字符串还原为对象，ES5提供了内置函数JSON.stringfy()和JSON.parse()来实现。</p>
<p>for example：</p>
<pre><code>var o = {x：1，y:{z:[false,null,&apos;&apos;]}};
s = JSON.stringfy(o);//o就成为了字符串
p = JSON.parse(s);//p是o的深拷贝
</code></pre><p><strong>8.对象方法</strong></p>
<p><strong>①toString()方法</strong></p>
<p>Array.toString()、Date.toString()等等，</p>
<pre><code>var s = {x:1,y:2}.toString();
</code></pre><p><strong>②toLocalString()方法</strong></p>
<p><strong>③toJSON</strong></p>
<p><strong>④valueOf()方法</strong></p>
<p>与toString()方法类似，但往往当JavaScript需要将对象转化为某种原始值而非字符串时才会用它，尤其是转换为数字的时候。</p>
<p>这一部分的知识就先到这里了，下一组是数组</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的数据类型]]></title>
      <url>/2017/05/18/JS-data-type/</url>
      <content type="html"><![CDATA[<p>JavaScript的数据是放在内存中的，而我们也知道数字、字符串等在内存中的存储方式、所占存储空间是不同的，分类就诞生了。JavaScript中的数据类型分为：基础数据类型（原始数据类型）、对象类型。</p>
<p>原始数据类型：<strong>数字（number）</strong>、<strong>字符串（string）</strong>、<strong>布尔值（Boolean）</strong>、<strong>null</strong>和<strong>undefined</strong>。</p>
<p>对象类型：<strong>Math（数字）</strong>、<strong>Date（日期）</strong>、<strong>Array（数组）</strong>、<strong>Function（函数）</strong>、<strong>RegExp（正则表达式）</strong>，这几种基础数据类型，先说第一个number吧！</p>
<h2 id="1-数字（number）"><a href="#1-数字（number）" class="headerlink" title="1.数字（number）"></a>1.数字（number）</h2><p>没啥意思，这个表示的就是数字，而数字中又分为整型和浮点型，就是整数和小数或分数。不好意思的是，JavaScript中没有具体的再区分它们两个，而是就用浮点型表示数字：1 == 1.0，这个是成立的。</p>
<p>运算符：+（加）、-（减）、*（乘）、/（除）、%（取余），运算也就是这个几个或者是几个的复合运算。</p>
<p>JavaScript数字的几个概念</p>
<p>无穷大（infinity），一个忒大的数字，出现了溢出（overflow），上溢出；</p>
<p>负无穷（-infinity），一个忒小的数字，出现了下溢出（underflow）；</p>
<p>除此之外，还有个中特别的存在就是非数字（not-a-number既NaN)，NaN是非数字的意思，情况有几种：无穷大除以无穷大、负数开平方、非数字或者不能获得数字的运算符进行了运算，这几种情况都是出现NaN。</p>
<p>NaN是个孤独的游魂，他没有伙伴，我们只能证明一个值不是NaN，而不能证明一个值是NaN，表达式是：</p>
<p> x != NaN,不能写作 x == NaN(后者是个错误的存在)。</p>
<p>上面的仅仅是数字的相关知识，还有Math对象对于数字的操作运算，这个下次再做分析。</p>
<h2 id="2-字符串（string）"><a href="#2-字符串（string）" class="headerlink" title="2.字符串（string）"></a>2.字符串（string）</h2><p>字符串就是个有次数的不可改变的16位值的序列，字符串的表现形式就是把值放到单引号’’或者双引号””里面，或者是个空值也可以。</p>
<p>因为JavaScript是用UTF-16编码的Unicode字符集，所以JavaScript的所有字符都是16位的。次序就是在字符串中相同字符也是有不同的索引的，不可改变就从字符串的所有方法看吧！</p>
<p>方法一是获取相关值</p>
<p>s.charAt();//用数字获取相关位置的值，因此里面填的是数字</p>
<p>s.substring(a,b);//两个数字，包前不包后</p>
<p>s.slice(a,b)；//同上</p>
<p>s.indexOf();//里面的字符串值，出现的就是这个字符的首次出现的位置的索引</p>
<p>s.lastIndexOf();//方法类似于上面</p>
<p>s.split();//以什么作为分割点</p>
<p>s.replace();//两个字符，前面的用后面的值来代替</p>
<p>s.toUpperCase();//变为大写</p>
<p>下面就用代码来实现一下，证实一下原字符串是不是不可改变的：</p>
<pre><code>var s = &quot;hello world&quot;;

console.log(s.indexOf(&apos;o&apos;));
console.log(s.lastIndexOf(&apos;o&apos;));
console.log(s.charAt(2));
console.log(s.toUpperCase());
console.log(s.substring(0,3));//同样是包前不包后
console.log(s.slice(2));//包前不包后，因为2后面没有结尾意思就是到最后
console.log(s.replace(&apos;w&apos;,&apos;W&apos;));
console.log(s.split(&apos;v&apos;));//这个就是字符串里没有的话，可以说是没有用的
console.log(s.split(&apos; &apos;));
</code></pre><h2 id="3-布尔值（boolean）"><a href="#3-布尔值（boolean）" class="headerlink" title="3.布尔值（boolean）"></a>3.布尔值（boolean）</h2><p>布尔值代表的意思是真或假、开或关、是或否，多用于控制结构的比较语句中，这个类型只有两个值：true、false。</p>
<p>JavaScript中的任意值都能转换成布尔值，下面的这些值能转换成false：undefined、null、0、-0、””(空字符串)、NaN，所有其他值包括对象（数组）则被转换成true。</p>
<p>用个例子：声明个变量o,<strong>if(o ！== null)</strong>再有一个<strong>if(o)</strong>,前个例子是证明变量o是不是null值，不是的话会执行下去，后一个变量是意思是为真（o不是false、null和undefined）的时候会执行下去。</p>
<p>关于布尔值的在有的话就是运算符的运用了！AND（&amp;&amp;）、OR（||）、非（NOT既！）。</p>
<h2 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a>4.null和undefined</h2><p>null就是程序级别的，不是系统报错报出来的，是我们可以写出来的，我们可以写作参数的；undefined是系统报错的，我们不期望遇到，遇到的原因大概有三：</p>
<p>①我们声明了变量，但是没有给变量赋值</p>
<p>如：    </p>
<pre><code>var a;

console.log(a);//这里打印出来的就是undefined
</code></pre><p>②参数的形式参数的引用了却没有实参</p>
<p>如：</p>
<pre><code> function a (b,c,d){

    console.log(b + c);

    console.log(d);//这里打印出来的就是undefined
  }

a(1,0);
</code></pre><p>好玩的是如果console.log(b + c + d);这里打印出来的值是NaN，你想想一个数字加undefined，结果就是NaN。</p>
<p>③再有一个现象就是对象里，我们有3个值，你非要找第四个值，那是没有了，只会报出undefined。</p>
<p>为了避免出现undefined的现象，我们一定要注意几个原因，声明变量的时候，</p>
<p>如：newHtml = “”;//不要只声明了不初始化值。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo中域名的配置]]></title>
      <url>/2017/05/16/my-domain/</url>
      <content type="html"><![CDATA[<p>这个时候，你的.io的github网站是可以使用的了，接下来就是怎么使用自己的域名去搞定一切了！OK,我们开始吧！</p>
<p><a href="http://www.szhot.com/" target="_blank" rel="external">http://www.szhot.com/</a>我的是在万维网申请的，在万维网你要做几件事：</p>
<p>1.申请一个域名，花多少钱，就看你自己个了！这一步就是给自己的网站起了个名字。</p>
<p>2.购买一个虚拟主机，花多少钱看你自己，有了名字但没有IP地址，就是服务器端没有你的空间，这一步就是在服务器端有个你的位置。</p>
<p>3.OK！为了顺利完成工作，你还要做：</p>
<p>①</p>
<p><img src="/image/www.png" alt=""></p>
<p>切记这三部分是必须完成的，光标点亮后才能进行下一步的工作；</p>
<p>②身份证正反面复印件，必须在一面上，还要有你的签名，按要求做吧；</p>
<p>③</p>
<p><img src="/image/kwww2.jpg" alt=""></p>
<p>这里还有一步关键，在你的E:\blog\source里，就是你的文件路径里配置个CNAME文件，没有后缀，在里面写上你的域名（不加www的域名）。这个下面就要用到了。</p>
<p><strong>按这个步骤进行操作</strong>圈子里的我们改成这个样子的，不要会错了意！！！</p>
<p>把这个搞好后就开始进行在dnspod上的修改，选择dnspod的原因是稳定！<a href="https://www.dnspod.cn/" target="_blank" rel="external">https://www.dnspod.cn/</a></p>
<p>修改的地方在哪里呢？请看：</p>
<p><img src="/image/www3.png" alt=""></p>
<p>在域名解析里，这个域名是我添加进来了，你要添加进来，点击进来</p>
<p><img src="/image/www4.png" alt=""></p>
<p>圈子里的是你照搬的，这个是github的IP地址，不用的话是找不到你的网页的。<br>而最下面的主机记录:www,记录类型:CNAME,记录值是你的github网址，OK了！<br>一切准备就绪！千万记得，hexo g和hexo d命令，把你的修改给布置到页面上来！</p>
<p>欢迎大家来践踏我的博文<a href="mashuaiqi.com">mashuaiqi.com</a>，，，，欢迎！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[markdownpad快捷键分享]]></title>
      <url>/2017/05/15/markdownpad/</url>
      <content type="html"><![CDATA[<p>Markdownpad是你编写博客的利器，使用的时候你可以用鼠标去为句子或者词语加粗、加链接、加图片等，但是快捷键的魅力之处就是一个词—快，快的不要不要的。</p>
<p><strong>Ctrl + I ： 斜体</strong></p>
<p><strong>Ctrl + B ： 粗体</strong></p>
<p><strong>Ctrl + G ： 图片</strong></p>
<p><strong>Ctrl + Q ： 引用</strong></p>
<p><strong>Ctrl + 1 ： 标题 1</strong></p>
<p><strong>Ctrl + 2 ： 标题 2</strong></p>
<p><strong>Ctrl + 3 ： 标题 3</strong></p>
<p><strong>Ctrl + K ： 代码块</strong></p>
<p><strong>Ctrl + L ： 超链接</strong></p>
<p><strong>Ctrl + T ： 时间戳</strong></p>
<p><strong>Ctrl + U ： 无序列表</strong></p>
<p><strong>Ctrl + R ： 水平标尺</strong></p>
<p><strong>F4 ： 启用水平布局</strong></p>
<p><strong>F5 ： 启用实时预览</strong></p>
<p><strong>F6 ： 在浏览器中预览</strong></p>
<p><strong>Ctrl + Shift + O ： 有序列表</strong></p>
<p>Ok！大家如果有更好的好玩的工具，分享给我哟！谢谢你们了！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript 诞生记]]></title>
      <url>/2017/05/13/javascript-txt/</url>
      <content type="html"><![CDATA[<p><strong>十八世纪英国文学家约翰逊博士对JavaScript说过一句很好的话，它的优秀之处并非原创，它的原创之处并不优秀。</strong></p>
<p>多么牛叉的一句话啊！那为什么这么说呢？我们看看JavaScript是怎么诞生的。</p>
<p>1994年，网景公司发布了第一个比较成熟的网络浏览器，但它仅仅支持浏览文件，就是你只能看，不能进行页面之间的互动，多么尴尬啊！Netscape需要一种网页脚本语言，使得网页之间通过浏览器进行互动。</p>
<p>那到底选择哪种语言呢？公司众说纷纭，选择现有的语言，如：Scheme、Python等，有现有的代码和程序员；不然的话，就发明一种更好的新语言。</p>
<p>这个时候公司招聘进来一个哥们–Brendan  Eich，他对函数式编程很感兴趣，公司招聘他的目的就是研究将Scheme作为网页脚本语言的可能性。这个时候Java是很火爆的，网景管理层也煞是迷恋。后来，网景公司有个决定，这个将要诞生的网页脚本语言必须与Java足够相似，使得非专业者也能很快上手。</p>
<p>既然有了要求就开始做个筛选吧！Java是面向对象编程的，而已经存在的语言，如：Perl、Python、Tcl、Scheme，它们是非面向对象的，因此他们自然就被排除在外了。作为简化版的Java语言的设计师—Brendan  Eich反而对Java不感冒。</p>
<p>这兄弟就开始一顿乱搞了，七拼八凑的，10天就把JavaScript给造出来了。</p>
<p>他的设计思路是：</p>
<ol>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Java的数据类型和内存管理；</strong></li>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Self语言，使用基于原型（prototype）的继承机制，对象就随之出现；</strong></li>
</ol>
<p>综上知：<strong>JavaScript = 简化的函数式编程 + 面向对象编程</strong>，这是多么愉快的决定啊！把Java作为JavaScript的设计原型，这是公司的决定，在既圆了公司管理层的决定，又有自己的决定在里面，这个东西本来就是一种迎合公司和自己的杂合物。</p>
<p>在结束的时候回味一下约翰逊博士的话，应该能有所体悟吧！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象方法]]></title>
      <url>/2017/04/27/oop/</url>
      <content type="html"><![CDATA[<h2 id="一、-面向对象方法出现的原因"><a href="#一、-面向对象方法出现的原因" class="headerlink" title="一、 面向对象方法出现的原因"></a>一、 面向对象方法出现的原因</h2><p>传统软件工程方法的确给软件产业带来了巨大进步，但它仅在中小规模软件开发中获得了好成绩，在大型的软件开发中很少取得成功。因此，后来面向对象技术得到了开发者的青睐。</p>
<h2 id="二、-面向对象方法的4个要点"><a href="#二、-面向对象方法的4个要点" class="headerlink" title="二、 面向对象方法的4个要点"></a>二、 面向对象方法的4个要点</h2><p><strong>1.</strong>树立对象意识，客观世界是有各种对象组成的，复杂的对象由简单的对象组成。因此，面向对象的软件系统是由对象组成的，软件中的任何元素都是对象，复杂的对象由简单的对象组成。与传统方法的区别是用对象分解代替了其功能分解。</p>
<p><strong>2.</strong>把所有对象划分为各种对象类，每个类都定义了一组数据和方法。数据用于表示数据的静态属性，乃对象的静态属性，每当建立一个对象类的实例时，就按照对象类中对数据的定义，生成一组专用的数据。例如，荧光屏上不同位置显示的半径各不相同的圆，虽然都是Circle类的对象，但都有自己的专属数据，以便记录各自的圆心位置、半径等。</p>
<p>类中定义的方法，是允许施加于该类对象上的操作，是该类所有对象共享的，并不需要为每个对象都复制操作的代码。因为过程是一样的或是类似的，我们把操作的流程（操作）给定义下来，就是一条流水线生产多种产品了。</p>
<p><strong>3.</strong>按照子类与父类的关系，把若干对象类组成一个系统，下层的类与上层类的特性相同，这就是一种继承现象。同时也得晓得底层的类能屏蔽高层类的同名特性。</p>
<p><strong>4.</strong>对象彼此之间仅能通过传递信息相互联系。这里也与传统方法的数据有本质的区别，它不是被动的等待外界世界对它施加操作，相反的是，它是进行操作的主体，不能直接从外部世界修改它的私有数据，所有的私有数据都是封装在对象类中，这就是封装性。</p>
<h2 id="三、-面向对象方法的优点"><a href="#三、-面向对象方法的优点" class="headerlink" title="三、 面向对象方法的优点"></a>三、 面向对象方法的优点</h2><p><strong>1.</strong>符合人类的思维特点</p>
<p>抽象为一般的特点，然后再说一个个个例的不同之处。例如，我们说动物，我们会把具有某些相似特征的生物划分为动物，ok！有了动物，那么我们还要更加细化，则在根据某些特征抽象出来，比如把人从动物里就可以抽象出来。</p>
<p><strong>2.</strong>稳定性好</p>
<p>功能发生改变，在传统方法里，因为功能分析和功能分解，如果功能需求发生改变，改变的是整个软件结构，这个量很大的。相反，在面向对象方法里，仅仅通过修改局部方法就可以，不必修改全部。</p>
<p><strong>3.</strong>可重用性好</p>
<p>可以用旧的零件做新的产品，重复使用一个对象类，创建新的实例或者在对象类里增加数据和方法，都是不影响原来的使用。</p>
<p><strong>4.</strong>容易开发大型的软件</p>
<p>原因就是，把大的软件产品分解为许多相互独立的小个体，技术难度降低、开发管理更容易。</p>
<p><strong>5.</strong>可维护性好</p>
<p>面向对象方法开发的软件稳定性好、易于修改、容易理解更加易于测试，总体就突出了它的可维护性好的特点。</p>
<h2 id="四、-面向对象的概念介绍"><a href="#四、-面向对象的概念介绍" class="headerlink" title="四、 面向对象的概念介绍"></a>四、 面向对象的概念介绍</h2><p><strong>1.</strong>说说对象的特点</p>
<p>①以数据为中心。因为数据是对象数据结构的一部分，是它的状态。</p>
<p>②本质上具有并行性。不同对象各自独立处理自身数据，彼此通过发送消息传递信息完成通信。因此，具有并行工作的属性。</p>
<p>③模块独立性好。模块与对象的关系，对象本身就是面向对象的软件的基本模块，模块讲究的内聚性和耦合性在对象上能充分体现出来。因为对象的数据和属性是在一个对象类里面的，操作也是在这里面的，作为一个基本的模块单元，它的内聚性很高。也因为这个原因，对象之间的关联很小，它们之间的耦合性很宽松。</p>
<p><strong>2.</strong>其他的相关概念</p>
<p>①类（class）</p>
<p>古语讲，物以类聚，这个“类”说的也是某些特点的在一起，抽象出来了一群人。类是支持继承的抽象数据类型，而对象是类的实例。</p>
<p>②实例（instance）</p>
<p>实例就是类的个体化</p>
<p>③消息（message）</p>
<p>把消息传递进去就有个不同的实例</p>
<p>④方法（method）</p>
<p>对象所能执行的操作，能做什么事情</p>
<p>⑤属性（attribute）</p>
<p>类中定义圆的大小、半径、颜色就是对象的属性，就是对象的特点</p>
<p>⑥封装（encapsulation）</p>
<p>字面上说就是把一个事物包起来，使外界不知道该事物的具体内容，面向对象方法中，把表示对象状态的数据和对数据的操作放到对象内部，只把接口提供出来。因此，它有个清晰的边界，外界是看不到内部的；再有就是有确定的接口，这些接口就是对象能接受的消息，只能向对象发送消息使用它；受保护的内部实现。</p>
<p>⑦继承（inheritance）</p>
<p>广义地说，继承就是直接使用已有的性质和特征，而不必重复定义他们。一个类可以有自己的父类和子类，这就一定具有继承的特性，一个类直接继承其父类的全部描述（数据和操作）。</p>
<p>OK！基本知识就到此了，不充足的会再补充。。。。。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[模块]]></title>
      <url>/2017/04/27/module-1/</url>
      <content type="html"><![CDATA[<p>在开发阶段里总体设计的过程中，我们必须明确系统是“怎么做事情”的了。在软件的设计过程中有些原理和概念是我们必须遵循的，这就是与<strong>模块</strong>有关的知识了！</p>
<h1 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1.模块化"></a>1.模块化</h1><p>先说个有意思的规律：C(x) 定义问题X的复杂程度，函数E(x)定义解决X问题所需要的工作量。对于问题P1和P2，如果</p>
<pre><code>C(P1) &gt; C(P2)
</code></pre><p> 显然       </p>
<pre><code>E(P1) &gt; E(P2)
</code></pre><p>根据人类解决问题的一般经验，一个有意思的规律就是</p>
<pre><code>C(P1+P2) &gt; C(P1)+C(P2)
</code></pre><p>因此也就有了</p>
<pre><code>E(P1+P2) &gt; E(P1)+E(P2)
</code></pre><p>结论是什么呢？就是把复杂的问题给分解成容易解决的小问题，那么大问题就迎刃而解，这是模块化的根据。</p>
<p>这就有个有意思的问题了，无限的分割软件，最后开发软件的工作量确实小的很多了。但模块间的接口的设计就在增多，你去脑洞吧，一个在减少工作量，一个在增加工作量，那模块量多少才是合适？（既是设计模块和模块接口的工作量合适，成本也合适），这个问题再说了！</p>
<h1 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2.抽象"></a>2.抽象</h1><p>抽象是现实世界的事物、状态、过程等相似方面的集中和概括，暂时忽略他们之间的差异，模块就是把抽象出来的某个层次用一定的方式描述出来。因为抽象是一层一层的，因此模块也是有其特点的。</p>
<h1 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3.逐步求精"></a>3.逐步求精</h1><p>人类认知过程中遵循个Miller法则：一个人在任何时候都只能把注意力集中到[5 9]个知识块上。</p>
<p>因此，在抽象的过程中，有了不同的层次，不同的模块，那么就有了模块的不断地精化。</p>
<h1 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4.信息隐藏和局部化"></a>4.信息隐藏和局部化</h1><p>这里隐藏的不是有关模块的所有信息，而是模块之间还要交换那些为了完成系统功能而必须交换的信息，当然是仅仅交换这些信息。模块本身就体现了这一特质。</p>
<h1 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5.模块独立"></a>5.模块独立</h1><p>模块的独立是模块化、抽象、信息隐藏和局部化的直接结果。既容易开发又容易测试是模块独立的好处，然而模块之间还是要通信的，那评价模块独立的标准又是是什么呢？<strong>内聚</strong> 和<strong>耦合</strong>。</p>
<p><strong>内聚</strong></p>
<p>内聚说的是一个模块内的事情，从一个最底层的模块说会更容易理解，既然“大家伙”（模块内的各个元素）都是一个“团队”（模块）了，那么我们就要力向一处使（做好一件事情），也就是说模块里的兄弟姐妹们都是与这件事情极其相关的。所以说内聚就是说模块内的元素关系密切，不然放一块干嘛！同理就是模块的设计时，尽量做到模块内的元素关系密切，这才符合模块间的信息隐藏和局部化。</p>
<p><strong>耦合</strong></p>
<p>有了内聚做参考就知道了既然能做同一件事或者相关事情的元素都放到一块去了（成为了一个模块），那么模块之间的关系就是松散的耦合关系喽！因为模块之间不可能做到一点关系都没有，是吧？做到松散耦合就OK了！</p>
<p>好了！以上就是关于模块的理论知识，以后在碰到关于模块的问题时不至于会一脸懵逼吧，，，</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[软件工程方法学（番外篇）]]></title>
      <url>/2017/04/27/module-knowlage1/</url>
      <content type="html"><![CDATA[<p>本篇的主题讲述的是<a href="module-1.md"><strong>模块</strong></a>和<a href="oop.md"><strong>面向对象方法学</strong></a>，这篇番外篇讲的就是“主人公”的生活大环境，内容是下面3方面，“主人公”出现在软件工程的哪个位置、出现的原因、解决了什么问题，主要是这几个方面。</p>
<p>在计算机系统发展历史中，开发软件的错误方法和观念导致了软件危机的出现。为了计算机系统的进一步发展，就逐步发展和完善了软件工程学科。</p>
<p>软件工程方法是软件工程的技术方面的内容，软件工程使用的最广泛的是：<strong>传统方法</strong>和<strong>面向对象方法</strong>。</p>
<p><strong>一、传统方法</strong></p>
<p>又叫做生命周期方法学或者结构化范型，它是把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务。OK！你看到了生命周期，它的意思是一个软件从定义、开发、使用和维护，直到被废弃，经历的漫长时期，就类似于一个人的出生、婴儿、童年、青年、中年和老年，直到死亡的漫长期限。</p>
<p>它的阶段有哪些呢？</p>
<p><img src="/image/tra.jpg" alt=""></p>
<p>看到了<a href="module-1.md"><strong>模块</strong></a>思想开始应用的阶段（开发阶段里的总体设计）了吧！当然既然是思想，可以用到的地方必然很多了，在模块化专章里我们具体的讲讲关于它的知识。</p>
<p><strong>二、面向对象方法</strong></p>
<p>对于面向对象方法学，这次就说一个方程就行了：</p>
<h1 id="OO-objects-classes-inheritance-communication-with-messages"><a href="#OO-objects-classes-inheritance-communication-with-messages" class="headerlink" title="OO = objects + classes + inheritance + communication with messages"></a>OO = objects + classes + inheritance + communication with messages</h1><p>意思就是：面向对象就是既使用对象又使用类和继承等机制，而且对象之间仅能通过传递消息实现彼此通信。</p>
<p>OK！下次细细讲解模块化和面向对象方法。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[个人简历]]></title>
      <url>/2017/04/26/resume/</url>
      <content type="html"><![CDATA[<p><strong>姓名：</strong>马帅旗       </p>
<p><strong>籍贯：</strong>河南商丘 </p>
<p><strong>职业：</strong>人生工程师</p>
<p><strong>技能：</strong>精通HTML、CSS、JS 等</p>
<p><strong>座右铭：</strong>爱计算机的工商管理专业兄弟！没事咱们也可以一起聊聊马刺或者一起来个长途骑行！  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[sublime设置自己的浏览器方法]]></title>
      <url>/2017/04/26/sublime/</url>
      <content type="html"><![CDATA[<p>sublime 中，有个默认的浏览器，就是你鼠标右键点击后出现的，我的是sublime Text 3 </p>
<p><img src="/image/s.png" alt=""></p>
<p>这里的红色部分的Open in brower 就是你的默认浏览器，我的事默认浏览器是IE，当然我想在Chrome里看看效果，并调试一下，怎么设置呢？</p>
<p>点击深绿色的Preferences栏</p>
<p><img src="/image/s2.png" alt=""></p>
<p>看到了Key Bindings 点进去进到如下界面：</p>
<p><img src="/image/s3.png" alt=""></p>
<p>你的是没有红色部分及下面的内容的，这里就是我自己设置的了，你就直接把我的代码放进去就可以了，你能 <strong>随意改</strong> 的是 keys这里的快捷键，再有就是application里的内容，你是要必须改的，换成你的浏览器位置的路径</p>
<p><img src="/image/s4.png" alt=""></p>
<p><strong>注意：</strong>这里的斜杠是怎么写的一定要注意</p>
<p>你要用的代码：<br>//chorme</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f6&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Users\\asus\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>},<br>//Firefox</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f7&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>}</p>
<p>到了这一步了，你可能会说，我怎么获得我的浏览器的位置呢，ok！在你的桌面上<strong>把鼠标悬浮到你要设置的浏览器上，并点击右键</strong>，会有# <strong>打开文件所在的位置</strong> #这个命令，点击进去，会到这个页面</p>
<p><img src="/image/s5.png" alt=""></p>
<p>找到了，点击上面红色的路径，粘贴到application里去，记得加上后面的chrome.exe，这样就设置好了，以后用的时候直接用快捷键就行了</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建博客（二）]]></title>
      <url>/2017/04/26/hexo2/</url>
      <content type="html"><![CDATA[<p>上次说到会用网址访问页面，细想了一下，你只要能按我发的那个链接走的话就能很好的出现效果，下面就说说一些必要的注意事项。</p>
<p>1.下载Markdownpad,<a href="http://markdownpad.com/" target="_blank" rel="external">http://markdownpad.com/</a>，这里在windows10里会有个小问题，需要配置个什么小玩意，你自己去搞定啦！</p>
<p>再有就是下载个Notepad++，<a href="https://notepad-plus-plus.org/" target="_blank" rel="external">https://notepad-plus-plus.org/</a>，目的是避免以后你编辑的东西会因为字符集的问题而不能正常使用</p>
<p>2.下载完成后，就按链接里前辈的路子走吧！以下几个命令是常用的，它们执行后的样子是啥样的</p>
<p><strong>hexo g</strong> ##目的是把你修改的东西变成静态文件，每次修改后都要在Git里执行一次这个命令，成功的样子是</p>
<p><img src="/image/12.png" alt=""></p>
<p><strong>hexo s</strong> ##启动服务器，当你想在把东西放到网页上前检查一下的时候用</p>
<p><img src="/image/13.png" alt=""></p>
<p>localhost:4000在这个时候使用，要执行其他的命令就要用Ctrl+C快捷键停止这一步</p>
<p><strong>hexo d</strong> ##把文件部署到github,这一步有意思的东西多，部署成功的标志是，命令执行完后，成功标志</p>
<p><img src="/image/14.png" alt=""></p>
<p>其他的均属未成功，解决方案：重新登录github网站，能进去的话，就把你所遇到的问题粘贴到网上搜索答案，不能进去的话，一个方法就是等到能进去的时候在执行这个命令。</p>
<p>3.主题的配置，当你把Hexo下载完后，是一个默认的主题，后面的主题，你就可以自己去选择了，你可以选择和前辈一样的主题，也可以自己寻找实验，找到更适合你的，安装方法就是去看主题制作者的Readme里面有详细的步骤</p>
<p><strong>注：</strong>有什么不会的我们可以共同讨论，这个主题就先到这里了</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客（一）]]></title>
      <url>/2017/04/23/myblog/</url>
      <content type="html"><![CDATA[<p><strong>你目前看到的这个博客就是我才搭建好的属于我自己的简易窝棚，搭建过程中虽然是看着前辈的流程走的，但不得不说我还是踩了很多坑的，好了接下来我向大家说说我的踩坑经历吧！</strong>你也可以参考其他前辈的过程，不过，记住一定要以一个的过程为主，我参考的是<a href="http://tengj.top/2016/02/22/hexo1/" target="_blank" rel="external">http://tengj.top/2016/02/22/hexo1/</a></p>
<ol>
<li>先下载必备的东西Git，通过它把文件托管到本地和github上，必须下载，<a href="https://git-scm.com" title="下载地址" target="_blank" rel="external">https://git-scm.com</a>。<br><img src="/image/g.png" alt="">,右下角的这个位置，注意：电脑系统版本</li>
<li>下载Nodejs去，同样是官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>，<img src="/image/g2.png" alt="最好是最新版本的"></li>
<li>工具已经准备完成，下面就开始操刀吧！</li>
</ol>
<p><strong>首先</strong>，安装Hexo，这里安装的时候可以在nodejs里安装，也可以在Git里安装：</p>
<p>nodejs里：<strong>npm install -g hexo</strong> 或者<strong>npm install hexo-cli -g</strong></p>
<p><img src="/image/nodejs.png" alt=""><br>检测安装成功与否，用<strong>hexo -v</strong> ,出现版本号说明成功</p>
<p>Git里的执行命令是一样的，注意：应该在Git Bash Here里执行同样命令</p>
<p><strong>第二步</strong>，在你建立的blog文件夹下，点击右键出现如下<img src="/image/git.png" alt=""> </p>
<p>执行命令 <strong>hexo init</strong> 自动在目标文件夹建立网站所需要的所有文件。</p>
<p>然后执行<strong>npm install</strong> 安装依赖包<br><strong>第三步</strong>，这一步就是验证以上的操作效果如何了，先执行<strong>hexo g</strong>,这是用于生成静态文件，再执行<strong>hexo s</strong>，这是启动服务器，<img src="img/dis.png" alt="">,执行之后就按图片去看看默认的效果吧！<img src="/image/re.png" alt="">,出现这个效果就完成了初步目的</p>
<p>最后，我们应该知道我们访问的东西是用localhost:4000访问得到的，下一步我们就用域名来获得这个页面，明天见！</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
