
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>浮游Bar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="小码哥">
    

    
    <meta name="description" content="web知识">
<meta property="og:type" content="website">
<meta property="og:title" content="浮游Bar">
<meta property="og:url" content="http://maHouse.github.io/index.html">
<meta property="og:site_name" content="浮游Bar">
<meta property="og:description" content="web知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浮游Bar">
<meta name="twitter:description" content="web知识">

    
    <link rel="alternative" href="/atom.xml" title="浮游Bar" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="浮游Bar" title="浮游Bar"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="浮游Bar">浮游Bar</a></h1>
				<h2 class="blog-motto">道之所向，虽千万人吾往矣</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:maHouse.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/28/new/" title="Window 对象" itemprop="url">Window 对象</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-28T10:03:18.000Z" itemprop="datePublished"> 发表于 2017-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本章介绍Window对象的属性和方法，Window对象是以窗口命名的，本章介绍的知识点如下：</p>
<h3 id="一、计时器"><a href="#一、计时器" class="headerlink" title="一、计时器"></a>一、计时器</h3><p>setTimeout()和setInterval()可以用来注册在指定的时间之后单次或者重复调用的函数。他们都是全局函数，定义为Window对象的方法，不会对窗口做什么事情。</p>
<p>setTimeout()方法实现一个函数在指定的毫秒数之后执行。它返回的是一个值，这个值可以传给clearTimeout()用于取消这个函数的执行。setInterval()和setTimeout()一样，不过这个函数会在指定的毫秒数的间隔里重读调用：</p>
<pre><code>setInterval(updateClock,60000);//每60秒调用一次updateClock()
</code></pre><p>和setTimeout()一样，setInterval()也返回一个值，这个值可以传递给clearInterval(),用于取消后续函数的调用。</p>
<p>for example 1：</p>
<pre><code>//安排函数f()在未来的调用模式
//在等待了若干毫秒之后调用f()
//如果设置了interval,并没有设置end参数，则对f()调用将不会停止
//如果没有设置interval和end，只在若干毫秒后调用f()一次
//只有指定了f()，才会从start=0的时刻开始
//注意，调用invoke()不会阻塞，它会立即返回

function invoke(f,start,interval,end) {
    if (!start) start = 0;//默认设置为0毫秒
    if (arguments.length &lt;= 2)//单次调用模式
        setTimeout(f,start);//若干毫秒后的单次调用模式
    else{                   //多次调用模式
        setTimeout(repeat,start);//若干毫秒后调用repeat()
        function repeat() {//在上一行所示的setTimeout()中调用
            var h = setInterval(f,interval);//循环调用f()
            //在end毫秒后停止调用，前提是end已经定义了
            if (end) setTimeout(function() {clearInterval(h);},end);
        }
    } 
}
</code></pre><h3 id="二、浏览器定位和导航"><a href="#二、浏览器定位和导航" class="headerlink" title="二、浏览器定位和导航"></a>二、浏览器定位和导航</h3><p>Window对象的location属性引用的是Location对象，它表示该窗口中所显示的文档的URL，并定义了方法来使用窗口载入新的文档。</p>
<p>Document对象的location属性也引用到Location对象：</p>
<p>window.location === document.location //总是返回true</p>
<p>Document对象也有一个URL属性，是文档首次载入后保存到该文档的URL的静态字符串。</p>
<h4 id="１、解析URL"><a href="#１、解析URL" class="headerlink" title="１、解析URL"></a>１、解析URL</h4><p>Location对象的其他属性－－protocol，host,hostname,port,pathname和search，分别表示URL的各个部分。search属性返回的是问号之后的URL，这部分通常是某种类型的查询字符。</p>
<p>for example 2：</p>
<pre><code>//提取URL的搜索字符串中的参数
//这个函数用来解析来自URL的查询串中的name=value参数对
//它将name=value对存储在一个对象的属性中，并返回该对象
//使用方法
//var args = urlArgs();//从URL中解析参数
//var q = args.q || &quot;&quot;;//如果参数定义了的话就使用参数，否则使用一个默认值
//var n = args.n ? parseInt(args.n) : 10;

function urlArgs() {
    var args = {};//定义一个空对象
    var query = location.search.substring(1);//查找到查询串，并去掉?
    var pairs = query.split(&quot;&amp;&quot;);//根据&amp;符号将查询字符串分开
    for (var i = 0;i &lt; pairs.length;i++) {//对于每一个片段
        var pos = pairs[i].indexOf(&quot;=&quot;);//查找name=value
        if (pos == -1) continue;//如果没有的话，就跳过
        var name = pairs[i].substring(0,pos);提取name
        var value = pairs[i].substring(pos+1);//提取value
        value = decodeURIComponent(value);//对value进行解码
        args[name] = value;//储存为属性
    }
    return args;//返回解析后的参数
}
</code></pre><h3 id="三、浏览历史"><a href="#三、浏览历史" class="headerlink" title="三、浏览历史"></a>三、浏览历史</h3><p>Window对象的history属性引用的是该窗口的History对象。History对象的length属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的URL。History对象的back()和forward()方法与浏览器的后退和前进按钮一样，第三个方法是go()，它接受一个参数，这个参数是正整数表示向前跳几页，是负整数表示向后跳几页。</p>
<pre><code>history.go(-2);//后退两个历史记录，相当于点击后退按钮两次
</code></pre><h3 id="四、浏览器和屏幕信息"><a href="#四、浏览器和屏幕信息" class="headerlink" title="四、浏览器和屏幕信息"></a>四、浏览器和屏幕信息</h3><p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关的信息。本节将介绍Window对象的navigator和screen属性。他们分别引用Navigator和Screen对象。</p>
<h3 id="五、对话框"><a href="#五、对话框" class="headerlink" title="五、对话框"></a>五、对话框</h3><p>Window对话框我们只讲到3个，alert()向用户显示一条信息并等待用户关闭对话框、confirm()也是一条信息，要求用户单击确定或者取消按钮，并返回一个布尔值、prompt()同样是一条信息，等待用户输入字符串，并返回那个字符串。这三个方法都是阻塞的，只有关闭后才能进行下一步。</p>
<pre><code>do{
    var name = prompt(&quot;what is your name?&quot;);//得到一个字符串输入
    var correct = confirm(&quot;You entered &apos;&quot; + name + &quot;&apos;.\n&quot; +//得到一个布尔值
                &quot;Click Okay to proceed or Cancel to re-enter&quot;);
} while(!correct)
alert(&quot;Hello,&quot; + name);//输出一个纯文本消息
</code></pre><p>上述三种方式之外还有种稍微复杂的方法：showModalDialog()，显示一个包含HTML格式的“模态对话框”。可以给它传入参数，以及从对话框里返回值。showModalDialog()在浏览器当前窗口中显示一个模态窗口。第一个参数用以指定对话框中HTML内容的URL。第二个参数是一个任意值（数组和对象均可），这个值在对话框中的脚本可以通过window.dialogArguments属性的值访问。第三个参数是一个非标准的列表，包含以分号隔开的name=value对，如果提供这个参数，可以配置对话框的尺寸或其他属性。用dialogwidth和dialogheight来设置对话框窗口的大小，用resizable=yes来允许用户改变窗口大小。</p>
<p>for example 4：</p>
<pre><code>&lt;!--
    这个HTML文件并不是独立的，这个文件由showModalDialog()所调用，它希望window.dialogArguments是一个由字符串组成的数组，数组的第一个元素将放置在对话框的顶部，剩下的每个元素是每行的输入框的标识，当单击Okay按钮的时候，返回一个数组，这个数组是由每个输入框的值组成，使用诸如这样的代码来调用：
var p = showModalDialog(&quot;multiprompt,html&quot;,
            [&quot;Enter 3D point coordinates&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;],
        &quot;dialogwidth:400;dialogheight:300;resizable:yes&quot;);
     --!&gt;
&lt;form&gt;
&lt;fieldset id=&quot;fields&quot;&gt;&lt;!--对话框中的正文部分--!&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;!--关闭这个对话框的按钮--!&gt;
&lt;button onclick=&quot;okay()&quot;&gt;Okay&lt;/button&gt;&lt;!--设置返回值和关闭事件--!&gt;
&lt;button onclick=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;&lt;!--关闭时不带任何返回值--!&gt;
&lt;/div&gt;
&lt;script&gt;
//创建对话框的主体部分，并在fieldset中显示出来
var args = dialogArguments;
var text = &quot;&lt;legend&gt;&quot; + args[0] + &quot;&lt;/legend&gt;&quot;;
for (var i = 1;i &lt; args.length;i++) 
    text += &quot;&lt;label&gt;&quot; + args[i] + &quot;:&lt;input id = &apos;f&quot; + i +&quot;&apos;&gt;&lt;/label&gt;&lt;br&gt;&quot;;
document.getElementById(&quot;fields&quot;).innerHTML = text;

//直接关闭这个对话框，不设置返回值
function cancel() { window.close();}

//读取输入框的值，然后设置一个返回值，之后关闭
function okay() {
    window.returnValue = [];//返回一个数组
    for(var i = 1;i &lt; args.length;i++) //设置输入框的元素
        window.returnValue[i-1] = document.getElementById(&quot;f&quot; + i).value;
    window.close();//关闭对话框，使showModalDialog()返回
}
&lt;/script&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
</code></pre><h4 id="六、作为Window对象属性的文档元素"><a href="#六、作为Window对象属性的文档元素" class="headerlink" title="六、作为Window对象属性的文档元素"></a>六、作为Window对象属性的文档元素</h4><pre><code>var $ = function(id) { return document.getElementById(id);};
ui.prompt = $(&quot;prompt&quot;);
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/18/client-JavaScript/" title="Web浏览器中的JavaScript" itemprop="url">Web浏览器中的JavaScript</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-18T13:01:24.000Z" itemprop="datePublished"> 发表于 2017-07-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>前一部分介绍了JavaScript语言核心，这一部分转向Web浏览器中JavaScript的实现。web浏览器是如何呈现页面的呢？一些呈现静态信息的页面叫做文档(加入JavaScript会有动态的效果但是信息本身是静态的，不过页面可以动态的载入信息)。下面会说到JavaScript代码是如何在HTML文档中嵌入并执行的，还会介绍兼容性、可访问性和安全性等问题。</p>
<h3 id="一、客户端JavaScript"><a href="#一、客户端JavaScript" class="headerlink" title="一、客户端JavaScript"></a>一、客户端JavaScript</h3><p>Window对象是所有客户端JavaScript特性和API的主要接入点。Window对象定义了一些属性，指代Location对象的location属性，Location对象指定当前显示在窗口里载入新的URL。</p>
<pre><code>//设置location属性，从而跳转到新的web页面
window.location = &quot;http://www.oreilly.com/&quot;;
</code></pre><p>Window对象还定义了一些方法，比如alert()方法，还有setTimeout()，可以注册一个函数，在给定的一段时间后触发一个回调：</p>
<pre><code>//等待两秒，然后说 hello
setTimeout(function() {alert(&quot;hello JavaScript!&quot;);},2000);
</code></pre><p>客户端JavaScript中，Window对象也是全局对象，Window对象处于作用域的顶端，它的属性和方法实际上是全局变量和全局函数。Window对象有一个引用自身属性叫做window。</p>
<p>Window对象有一个最重要的属性是document，它引用Document对象，后者表示显示在窗口中的文档。Document对象有一些重要方法，比如getElementById(),可以基于元素id属性的值返回单一的文档元素：</p>
<pre><code>//查找 id = &quot;timestamp&quot;的元素
var timestamp = document.getElementById(&quot;timestamp&quot;);
</code></pre><p>getElementById()返回的Element对象有其他重要的属性和方法，比如允许脚本获取它的内容，设置属性值等：</p>
<pre><code>//如果元素为空，往里面插入当前的日期和时间
if(timestamp.firstChild == null)
    timestamp.appendChild(document.createTextNode(new Date().toString()));
</code></pre><p>每个Element对象都有style和className属性，允许脚本指定文档元素的CSS样式，或者修改应用元素上的CSS类名。设置这些CSS相关属性会改变文档元素的呈现：</p>
<pre><code>//显示修改目标元素的呈现
timestamp.style.backgroundColor = &quot;yellow&quot;;

//或者只改变类，让样式表指定具体内容
timestamp.className = &quot;highlight&quot;;
</code></pre><p>事件处理程序可以让JavaScript代码修改窗口、文档和组成文档的元素的行为。事件处理程序的属性名是以单词“on”开始的：</p>
<pre><code>//当用户单机timestamp元素时，更新它的内容
timestamp.onclick = function () {this .innerHTML = new Date().toString();}

//显示内容的简单客户端JavaScript：
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
.reveal*{display:none;}
.reveal *.handle{display:block;}&lt;!...除了这个handle的元素...&gt;
&lt;/style&gt;

&lt;script&gt;
window.onload = function() {
    var elements = document.getElementsByName(&quot;reveal&quot;);
    for (var i = 0;i &lt; elements.length;i++) {
        var elt = elements[i];
        var title = elt.getElementsByName(&quot;handle&quot;)[0];
        addRevealHandler(title,elt);
        function addRevealHandler(title,elt) {
            title.onclick = function () {
                if(elt.className == &quot;reveal&quot;)
                    elt.calssName = &quot;ravealed&quot;;
                else if (elt.className == &quot;revealed&quot;)
                    elt.className = &quot;reveal&quot;;
            }
        }
    }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;reveal&quot;&gt;
&lt;h1 class=&quot;handle&quot;&gt; Click Here to Reveal Hidden Text&lt;/h1&gt;
&lt;p&gt;This paragraph is hidden.It appears when you click on the title.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="1、web文档里的JavaScript"><a href="#1、web文档里的JavaScript" class="headerlink" title="1、web文档里的JavaScript"></a>1、web文档里的JavaScript</h4><p>用户的体验不应该依赖于JavaScript，但它却可以增强用户体验，通过如下的方式来实现：</p>
<p>》创建动画和其他视觉效果，巧妙的引导和帮助用户进行页面导航。</p>
<p>》对表格的列进行分组，让用户更容易找到所需要的。</p>
<p>》隐藏某些内容，当用户“深入”到内容里时，在逐渐展示详细信息。</p>
<p>Web浏览器是简单操作系统的概念，这样就可以把Web应用定义为用JavaScript访问更多浏览器提供的高级服务(比如网络、图像和数据存储)的页面。高级服务里最有名的是XMLHttpRequest对象，后者可以对HTTP请求编程来启用网络。Web应用使用这个服务从服务器获取新信息，而不用重新载入页面，达到局部刷新的效果。</p>
<h3 id="二、在HTML里嵌入JavaScript"><a href="#二、在HTML里嵌入JavaScript" class="headerlink" title="二、在HTML里嵌入JavaScript"></a>二、在HTML里嵌入JavaScript</h3><p>嵌入到HTML文档里共有4种方式：</p>
<p>《 内联，放置在<code>&lt;script&gt;&lt;/script&gt;</code>之间。</p>
<p>《 放置在由<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</p>
<p>《放置在HTML事件处理程序中，该事件处理程序由onclick或者onmouseover这样的HTML属性值指定。</p>
<p>《放在一个URL里，这个URL使用特殊的“javascript”协议。</p>
<p>嵌入到HTML文档里方法总共是这几种，但是我们常用的是第二种，达到了表现形式与行为的分离的目的。</p>
<pre><code>//这是个简单的JavaScript数字时钟程序
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;
Digital Clock
&lt;/title&gt;
&lt;script&gt;
//定义一个函数用以显示当前的时间
function displayTime() {
    var elt = document.getElementById(&quot;clock&quot;);
    var now = new Date();
    elt.innerHTML = now.toLocaleTimeString();
    setTimeout(displayTime,1000);
}
window.onload = displayTime;
&lt;/script&gt;
&lt;style&gt;
#clock {
    font:bold 24pt sans;
    background:#ddf;
    padding:10px;
    border:solid black 2px;
    border-radius:10px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Digital Clock&lt;/h1&gt;
&lt;span id=&quot;clock&quot;&gt;&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>其他的引入方式这里不再做介绍，下面我们仅仅说一下外部文件中的脚本：</p>
<pre><code>&lt;script src=&quot;../../scripts/util.js&quot;&gt;&lt;/script&gt;//相对路径
</code></pre><h3 id="三、JavaScript程序的执行"><a href="#三、JavaScript程序的执行" class="headerlink" title="三、JavaScript程序的执行"></a>三、JavaScript程序的执行</h3><p>JavaScript程序的执行有2个阶段：</p>
<p>第一阶段，载入文档内容，并执行<code>&lt;script&gt;</code>元素里的代码(包括内联的和外部脚本)。脚本通常会按它们在文档中出现的顺序执行。所有脚本里的JavaScript代码都是从上到下，按照它在条件、循环以及其他控制语句中的出现顺序执行。这个阶段是JavaScript代码自己的执行阶段，不参与与HTML文档的互动工作。</p>
<p>当文档载入完成，并且所有的脚本执行完成后，JavaScript就进入它的第二阶段。这个阶段是异步的，而且由事件驱动。在事件驱动阶段，Web浏览器调用事件处理程序函数(第一阶段里执行的脚本指定的HTML事件处理程序)，来响应异步发生的事件。这个阶段就是JavaScript代码与HTML文档的互动，不过这里面由事件驱动罢了！</p>
<p>事件驱动阶段发生的第一个事件是load事件，这是说明文档加载完成。因为JavaScript代码的执行是单线程的，所以这两个阶段的执行在同一个时间内只能执行一个操作。同样只有当JavaScript代码执行完成之后，文档才能继续下去。</p>
<p>JavaScript代码有个快速生成内容的方式就是通过document.write()来实现：</p>
<pre><code>//载入时生成文档内容
&lt;h1&gt;Table of Factorials&lt;/h1&gt;
&lt;script&gt;
function factorial(n) {
    if(n &lt;= 1) return n;
    else return n*fatorial(n-1);
}
document.write(&apos;&lt;table&gt;&apos;);
document.write(&apos;&lt;tr&gt;&lt;th&gt;n&lt;/th&gt;&lt;th&gt;n!&lt;/th&gt;&lt;/tr&gt;&apos;);
for(var i = 1;i &lt;= 10;i++) {
    document.write(&apos;&lt;tr&gt;&lt;td&gt;&apos; + i + &apos;&lt;/td&gt;&lt;td&gt;&apos; + fatorial(i) + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
document.write(&apos;&lt;/table&gt;&apos;);
document.write(&apos;Generated at&apos; + new Date());//输出时间戳
&lt;/script&gt;
</code></pre><p>当脚本把文本传递给document.write()时，这个文本被添加到文档输入流中，HTML会创建一个文本节点插入到这个文本节点之后，我们不推荐这么使用。脚本的执行只在默认的情况下是同步和阻塞的。要有所改变我们可以当文本加载完成之后执行代码，也可以在文档加载之前尽快执行代码。前者就是defer的使用意义，后者就是async的使用意义，但是这两者的共同使用则是采用async属性。这两者就是JavaScript代码的同步、异步和延迟。不同的是延迟脚本的执行同样是按顺序走的，而异步脚本则可能是无序执行的。</p>
<p>动态创建脚本并把它插入到文档中来实现脚本的异步载入和执行，通过loadasync()函数来实现这个工作。</p>
<pre><code>//异步载入并执行脚本
function loadasync() {
    var head = document.getElementsByName(&apos;head&apos;)[0];//找到&lt;head&gt;元素
    var s = document.createElement(&apos;script&apos;);//创建一个&lt;script&gt;元素
    s.src = url;//设置其src属性
    head.appendChild(s);//将script元素插入到head标签中
}
</code></pre><p>注意：这个loadasync()函数会动态的载入脚本成为正在执行的JavaScript程序的一部分，不是通过web页面内联包含也不是来自页面的静态引用。</p>
<h3 id="1、事件的驱动JavaScript"><a href="#1、事件的驱动JavaScript" class="headerlink" title="1、事件的驱动JavaScript"></a>1、事件的驱动JavaScript</h3><p>事件都有名字比如click、change、load、mouseover、keypress或者readystatechange，指示发生的事件的通用类型。事件还有目标，就是对象，意思是哪个对象发生了什么事情，所以当我们谈到事件的时候，必须同时包含事件类型（名字）和目标（对象）：比如一个单击事件发生在HTMLButtonElement对象上，或者一个readystatechange事件发生在XMLHttpRequest对象上。</p>
<p>如果想要程序响应一个事件，写一个函数，叫做“事件处理程序”、“事件监听器”或者“回调”。然后注册这个函数，这样当事件发生时就会调用它。可以如下写代码：</p>
<pre><code>window.onload = function () {...};
document.getElementById(&quot;button1&quot;).onclick = function () {..};
function handleResponse() {...}
request.onreadystatechange = handleRequest;
</code></pre><p>对于大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击(IE里面事件信息被储存在全局event对象里)。</p>
<p>有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”，例如用户在<code>&lt;button&gt;</code>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样任何注册在容器元素上的单击事件都会调用。</p>
<p>大部分可以成为事件目标的对象都有一个叫做addEventListener()的方法，允许注册多个监听器：</p>
<pre><code>window.addEventListaner(&quot;load&quot;,function () {...},false);
request.addEventListener(&quot;readystatechange&quot;,function () {...},false);
</code></pre><p>这个函数的第一个参数是事件的名称，不好意思的是在IE中，IE8之前的版本中只能运用一个相似的办法，用attachEvent():</p>
<pre><code>window.attachEvent(&quot;onload&quot;,function () {...});
</code></pre><p>setTimeout()函数叫做“回调逻辑”不是“事件处理程序”，但它和setInterval()都是异步的。</p>
<pre><code>//当文档载入完成时调用一个函数
//注册函数f，当文档载入完成时执行这个函数f
//如果文档已经载入完成，尽快已异步方式执行它
function onLoad(f) {
    if(onLoad.loaded)//如果文档已经载入完成
        window.setTimeout(f,0);//将f放入异步队列，并尽快执行它
    else if(window.addEventListener)//注册事件的标准方法
        window.addEventListener(&quot;loade&quot;,f,false);
    else if(window.attachEvent)//IE8以及更早的IE版本浏览器注册事件的方法
        window.attachEvent(&quot;onload&quot;,f);
}
//给onLoad设置一个标志，用来指示文档是否完成
onLoad.loaded = false;
//注册一个函数，当文档载入完成时设置这个标志
onLoad(function () {onLoad.loaded = true;});
</code></pre><h3 id="四、兼容性和互用性"><a href="#四、兼容性和互用性" class="headerlink" title="四、兼容性和互用性"></a>四、兼容性和互用性</h3><p>客户端JavaScript兼容性和交互性的问题可以归纳为3类：</p>
<h4 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h4><p>Web平台在进化当中，什么标准都在进化</p>
<h4 id="未实现"><a href="#未实现" class="headerlink" title="未实现"></a>未实现</h4><p>没有实现，是浏览器开发商没有实现某个特性，比如<code>&lt;canvas&gt;</code>元素，IE8就不支持，而其他浏览器就已经实现了</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>每个浏览器都有bug</p>
<h4 id="解决兼容性问题的办法"><a href="#解决兼容性问题的办法" class="headerlink" title="解决兼容性问题的办法"></a>解决兼容性问题的办法</h4><p>1、</p>
<p>处理兼容性问题的方法之一是使用类库，比如jQuery，因为它们定义了新的客户端API并兼容所有浏览器。jQuery中事件处理程序的注册是使用bind()方法来完成的，如果用jQuery来做开发，就不用考虑addEventListener()和attachEvent()之间的兼容性。</p>
<p>2、功能测试</p>
<p>就是用某种方法测试你要使用的功能在某个浏览上是不是可用，不可用的话就不用，或者改用其它通用的方法。</p>
<pre><code>if(element.addEventListener) {//在使用这个W3C方法之前首先检测它是否可用
    element.addEventListener(&quot;keydown&quot;,handler,false);
    element.addEventListener(&quot;keypress&quot;,handler,false);
}
else if(element.attachEvent) {//在使用该IE方法之前首先检测它
    element.attachEvent(&quot;keydown&quot;,handler);
    element.attachEvent(&quot;keypress&quot;,handler);
}
else {//否则，选择普遍支持的技术
    element.onkeydown = element.onkeypress = handler;
}
</code></pre><p>3、怪异模式和标准模式</p>
<p>标准模式是符合W3Cschool的，怪异模式不属于</p>
<p>4、浏览器测试</p>
<p>5、IE的条件注释</p>
<p>很多的不兼容性都是针对IE浏览器的，我们可以用一种不怎么规范的方式来处理不兼容性问题。<br>例如：</p>
<pre><code>&lt;!--[if IE 6]&gt;
This content is actually inside an HTML comment.
It will only be displayed in IE6.
&lt;![endif]--&gt;

&lt;!--[if ite IE7]&gt;
This content will only be displayed by IE 5,6 and 7 and earlier.
Ite stands for &quot;less than or equal&quot;. You can also use &quot;It&quot;,&quot;gt&quot;,and &quot;gte&quot;.
&lt;![endif]--]&gt;

&lt;!--[if !IE]&gt;&lt;--&gt;
This is normal HTML content,but IE will not display it
because of the comment above and the comment below.
&lt;!--&gt;&lt;![endif]--&gt;

This is normal content,displayed by all browsers.
</code></pre><p>由于这个类库只有IE需要，因此有理由在页面里使用条件注释引用它，这样其他浏览器就不会载入它：</p>
<pre><code>&lt;!--[if IE]&lt;script src=&quot;excanvas.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;
</code></pre><h3 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h3><p>Web浏览器中包含JavaScript解释器，一旦载入Web页面，就可以让任意的JavaScript代码在计算机里执行，不过这里存在着安全隐患，浏览器厂商在下面两个方面进行着权衡和博弈：</p>
<p>定义强大的客户端API，启用强大的Web应用；</p>
<p>阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间。</p>
<p>下面会涉及到JavaScript的安全限制和安全问题，这个是要意识到的。</p>
<h4 id="1、JavaScript不能做什么"><a href="#1、JavaScript不能做什么" class="headerlink" title="1、JavaScript不能做什么"></a>1、JavaScript不能做什么</h4><p>客户端JavaScript没有权限来写入或删除客户计算机上的任意文件或列出任意目录，就意味着JavaScript程序不能删除数据或植入病毒。类似的，客户端JavaScript没有任何通用的网络能力。客户端JavaScript程序可以对HTTP协议编程，并且HTML5也有一个附属标准WebSockets，定义了一个类套接字的API，用于和指定的服务器通信。但是这些API都不允许对于范围更广的网络进行直接访问。通用的Internet客户端和服务器不能同时使用客户端JavaScript来写。</p>
<h4 id="2、同源策略"><a href="#2、同源策略" class="headerlink" title="2、同源策略"></a>2、同源策略</h4><p>同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<code>&lt;iframe&gt;</code>元素或者打开其他浏览器窗口的时候，这一策略通常会发挥作用。具体来说，脚本只能读取和所属文档来源相同的窗口和文档的属性。</p>
<p>文档的来源包含协议、主机，以及载入文档的URL端口。从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用http:协议载入的文档和使用https:协议载入的文档具有不同的来源，即使它们来自于同一个服务器。</p>
<p>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，这个很重要。假设一个来自于主机A的脚本被包含到宿主B的一个Web页面中。这个脚本的来源是主机B，并且可以完整的访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自于主机B的另一个文档，脚本对这个文档的内容也具有完全访问的权限。但是，如果脚本打开第三个窗口并载入一个来自于主机C的文档，同源策略就会阻止访问这个文档。</p>
<p>限制恶意脚本侵入文档，同源策略做的很好了，但是某些时候同源策略就显得过于严格了。下面就是3中不严格的同源策略。</p>
<h4 id="第一个就是主域名相同而子域名不同的情况。"><a href="#第一个就是主域名相同而子域名不同的情况。" class="headerlink" title="第一个就是主域名相同而子域名不同的情况。"></a>第一个就是主域名相同而子域名不同的情况。</h4><p>例如，来自于home.example.com的文档里的脚本想要合法的读取从developer.example.com载入的文档的属性，或者来自于orders.example.com的脚本可能要读取catalog.example.com上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的domain属性。</p>
<p>默认的情况下，属性domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须是具有有效的域前缀或它本身。因此，一个domain属性的初始值是字符串“home.example.com”就可以把它设置为“example.com”，但是不能设置为“home.example”或者“example.com”。另外，domain值中必须有一个点，不能把它设置为“com”或其他顶级域名。</p>
<p>这样文档就有了同源性，可以互相读取属性，切记这是主域名相同的情况下。</p>
<h4 id="第二个跨域资源共享"><a href="#第二个跨域资源共享" class="headerlink" title="第二个跨域资源共享"></a>第二个跨域资源共享</h4><p>请求头和新的Access-Control-Allow-Origin响应头来扩展HTTP。它允许服务器用头信息显示地列出源，或者使用通配符来匹配所有的源并允许由任何地址请求文件，这样XMLHttpRequest就不会被同源策略所限制了。</p>
<h4 id="第三种叫做跨文档消息"><a href="#第三种叫做跨文档消息" class="headerlink" title="第三种叫做跨文档消息"></a>第三种叫做跨文档消息</h4><p>允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用Window对象上的postMessage()方法，可以异步传递信息事件到窗口的文档里。</p>
<h3 id="3、跨站脚本"><a href="#3、跨站脚本" class="headerlink" title="3、跨站脚本"></a>3、跨站脚本</h3><p>跨站脚本(Cross-site scripting)或者叫做XSS，这个术语表示一类安全问题，也就是攻击者向目标Web站点注入HTML标签或者脚本。防止XSS攻击是服务器Web开发者的一项基本工作。然而，客户端JavaScript开发者必须意识到或者预防跨站脚本。</p>
<p>来看个例子，它是如何使用JavaScript通过用户的名字来向用户问好：</p>
<pre><code>&lt;script&gt;
var name = decodeURICompnent(window.location.search.substring(1)) || &quot;&quot;;
document.write(&quot;Hello&quot; + name);
&lt;/script&gt;
</code></pre><p>这两行脚本使用window.location.search来获得获得它们自己的URL中以“？”<br>开始的部分。它使用document.write()来向文档添加动态生成的内容。</p>
<p>来防止XSS攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签。可以通过添加如下一行代码来移除<code>&lt;script&gt;</code>标签两边的尖括号。</p>
<pre><code>name = name.replace(/&lt;/g,&quot;&amp;lt;&quot;).replace(/&gt;/g,&quot;&amp;gt;&quot;);
</code></pre><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>就是不让开客户端使用者使用客户端浏览器</p>
<h3 id="客户端框架"><a href="#客户端框架" class="headerlink" title="客户端框架"></a>客户端框架</h3><p>jQuery框架之外还有Prototype类库(专门针对DOM和Ajax实现的一套实用工具)、Dojo(是一个大型的框架包含众多的UI组件集合、包管理系统、数据抽象层等)、YUI(Yahoo开发的，和Dojo一样很庞大，包括语言工具、DOM工具、UI组件，目前YUI2和YUI3是两个不同的版本)等。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/12/RegExp/" title="RegExp" itemprop="url">RegExp</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-12T15:04:21.000Z" itemprop="datePublished"> 发表于 2017-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/10/正则表达式/" title="正则表达式表达式的匹配模式" itemprop="url">正则表达式表达式的匹配模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-10T10:06:09.000Z" itemprop="datePublished"> 发表于 2017-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="我们的主题："><a href="#我们的主题：" class="headerlink" title="我们的主题："></a>我们的主题：</h2><p>正则表达式什么样子的？能用来做什么？怎么做？ok，一一揭示！</p>
<h3 id="一、正则表达式简介"><a href="#一、正则表达式简介" class="headerlink" title="一、正则表达式简介"></a>一、正则表达式简介</h3><p>正则表达式是一个描述字符模式的对象，注意是对象，创建方式不用说了，有构造函数和直接量两种方式。描述字符模式的规则是由字符(数字、字母和其他)组成的。</p>
<p>下面我们就把正则表达式的基本知识看一下：</p>
<h4 id="1、直接量字符"><a href="#1、直接量字符" class="headerlink" title="1、直接量字符"></a>1、直接量字符</h4><p>用反斜线()作为前缀进行转义：</p>
<pre><code>\o(NUL字符)等价于\u0000                 \t(制表符)等价于\u0009
\n(换行符)等价于\u000A                   \v(垂直制表符)等价于\u000b
\f(换页符)等价于\u000L                   \r(回车符)等价于\u000D
\uxxxx(十六进制数指定的Unicode字符)，既有\u009等价于\t
</code></pre><h4 id="2、字符类"><a href="#2、字符类" class="headerlink" title="2、字符类"></a>2、字符类</h4><p>将直接量字符单独放到方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。</p>
<pre><code>/[abc]/和字母&quot;a&quot;,&quot;b&quot;,&quot;c&quot;中的任意一个都匹配
/[a-zA-Z0-9]/匹配拉丁字母表中的任意字母和数字
</code></pre><p>尖括号“^”表示取反，注意它所在的位置是紧靠左边的方括号，/[^abc]/意思是匹配所有除三者之外的字符。</p>
<p>正则表达式中的字符类：</p>
<pre><code>[...] 方括号内的任意字符     [^...]  不在方括号内的所有字符
.     除了换行符\n和其他表示终止符的Unicode字符
\w    任何AS11码组成的单词，是数字和字母的组合[a-zA-Z0-9]是等价的
\W    与上者是相反的
\s    任何Unicode空白字符
\S    任何非空字符的UNicode字符
\d    任何AS11数字等价于[0-9]
\D    等价于[^0-9]
[\b]  表示退格直接量
</code></pre><p>方括号内也可以写特殊转义字符，/[\s\d]/(任何空白符或数字)</p>
<p>正则表达式里有个表示重复的字符语法：</p>
<pre><code>{n,m}  匹配前一项的重复次数，比n大比m小，这个m可选，n为必填的，当然有更简单的表示方法
</code></pre><p>比如：</p>
<pre><code>？ 等价于{0,1}、+ 等价于{1，}、*等价于{0，}
</code></pre><p>for example 1：</p>
<pre><code>/\d{2,4}/     2--4个数字
/\w{3}\d?/    精确匹配3个单词一个可选的数字
/\s+java\s+/  前后各至少有一个空白符的字符串&quot;java&quot;
/[^(]*/       匹配0个或多个非左括号的字符
</code></pre><p>正则表达式的选择、分组和引用字符</p>
<pre><code>|        有或者的意思
(...)    将几个项组合为一个单元
(?...)   只组合，不记忆
</code></pre><p>for example 2：</p>
<pre><code>/ab|cd|ef/         可以匹配字符串&quot;ab&quot;或者&quot;cd&quot;或者&quot;ef&quot;
/\d{3}|[a-z]{4}/   匹配的是3个数字或者4个小写字母
</code></pre><p>注意：这个模式一旦发现了我们所需要的匹配项，就立即停止，不再进行匹配</p>
<pre><code>/java(script)?/  可以匹配字符串java，其后的script可有可无
/(ab|cd)+|ef/     可以匹配字符串&quot;ef&quot;,也可以匹配字符串&quot;ab&quot;或者&quot;cd&quot;一次或者多次
</code></pre><p>我们可以用/^…$/来表示开始和结束，就有表示指定位置的意思</p>
<p>修饰符(放到/…/之后)有3个：<br>    i：表示模式不区分大小写<br>    g：表示进行全局搜索，找到所有的匹配项<br>    m:多行模式进行匹配，针对换行符</p>
<h3 id="二、正则表达式的String方法"><a href="#二、正则表达式的String方法" class="headerlink" title="二、正则表达式的String方法"></a>二、正则表达式的String方法</h3><p>上面说了正则表达式的基础知识，这里我们就说说怎么运用正则表达式。</p>
<h4 id="1、search"><a href="#1、search" class="headerlink" title="1、search()"></a>1、search()</h4><p>字面意思就是寻找什么，不错，他就是从字符串中寻找参数，有的话就返回开始的位置，没有的话就返回-1。参数如果不是正则表达式就会进行自动转换(调用RegExp()构造函数进行自动转换)</p>
<p>for  example 4：</p>
<pre><code>&quot;JavaScript&quot;.search(/script/i);
</code></pre><h4 id="2、replace"><a href="#2、replace" class="headerlink" title="2、replace()"></a>2、replace()</h4><p>字面意思就是根据正则表达式寻找到相应的字符串，这是第一个要做的事情，第二个参数就是要写个替换字符串，同样，如果第一个参数不是正则表达式，就会进行自动转换</p>
<p>for  example 5：</p>
<pre><code>text.replace(/javascript/gi,&quot;JavaScript&quot;);
</code></pre><h4 id="3、match"><a href="#3、match" class="headerlink" title="3、match()"></a>3、match()</h4><p>这个方法的参数是唯一的，如果不是全局搜索的话，就仅仅当匹配到第一个元素时就会停止，并同样会返回一个数组</p>
<p>for example 6：</p>
<pre><code>&quot;1 plus 2 equals 3&quot;.match(/\d+/g);//返回[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],进行了全局搜索
</code></pre><h4 id="4、split"><a href="#4、split" class="headerlink" title="4、split()"></a>4、split()</h4><p>这个方法不说了，之前有说到。</p>
<h3 id="三、RegExp对象的属性和方法"><a href="#三、RegExp对象的属性和方法" class="headerlink" title="三、RegExp对象的属性和方法"></a>三、RegExp对象的属性和方法</h3><p>RegExp对象的属性有5个，前4个是只读的。分别为：source、global(g,布尔值)、ignorancase(i,布尔值)、multiline(布尔值)、lastIndex(可读写的)</p>
<p>lastIndex，若匹配模式中有g修饰符，会发挥作用。有两个方法：test()和exec()</p>
<p>for example 7:</p>
<pre><code>var pattern = /java/i;
pattern.test(&quot;JavaScript&quot;);//true,这个方法返回的是布尔值
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/07/一键清理/" title="一键清理" itemprop="url">一键清理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-07T09:42:13.000Z" itemprop="datePublished"> 发表于 2017-07-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我是不愿意在自己的电脑上装个电脑管家、360卫士或者金山毒霸什么玩意的东西来清理我的电脑的，前两天在网上浏览到一个好玩的东西，你只要设置一下，花你几分钟的时间就能自己搞个清理器，不要钱还没有绑定的插件，效果还不错！<br>这个家伙长什么样子呢？</p>
<p><strong>如图：</strong></p>
<p><img src="image/clean.png" alt=""></p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1.这个样子你直接点击就能进行清理工作了；</p>
<p>2.这个文件的格式是.bat，这是必须改成这个样子；</p>
<p>3.编辑的时候把如下代码粘贴进text文档就行了：</p>
<pre><code>@echo off     
echo 正在清除系统垃圾文件，请稍等......     
del /f /s /q %systemdrive%\*.tmp     
del /f /s /q %systemdrive%\*._mp     
del /f /s /q %systemdrive%\*.log     
del /f /s /q %systemdrive%\*.gid     
del /f /s /q %systemdrive%\*.chk     
del /f /s /q %systemdrive%\*.old     
del /f /s /q %systemdrive%\recycled\*.*     
del /f /s /q %windir%\*.bak     
del /f /s /q %windir%\prefetch\*.*     
rd /s /q %windir%\temp &amp; md %windir%\temp     
del /f /q %userprofile%\COOKIES s\*.*     
del /f /q %userprofile%\recent\*.*     
del /f /s /q &quot;%userprofile%\Local Settings\Temporary Internet Files\*.*&quot;     
del /f /s /q &quot;%userprofile%\Local Settings\Temp\*.*&quot;     
del /f /s /q &quot;%userprofile%\recent\*.*&quot;     
sfc /purgecache &apos;清理系统盘无用文件     
defrag %systemdrive% -b &apos;优化预读信息     
echo 清除系统LJ完成！     
echo. &amp; pause  
</code></pre><p>把上面的粘到txt文档后，修改改为.bat就能用了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/06/hosts设置/" title="通过设置hosts文件来翻墙" itemprop="url">通过设置hosts文件来翻墙</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-06T09:45:49.000Z" itemprop="datePublished"> 发表于 2017-07-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>下面我们就分几个步骤来说，文章以win10系统为例，其他系统类似。</p>
<h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p>首先你到网上找到个hosts文件，这个文件要找到个最新的版本，直接在百度上搜索去吧！找到后就下载下来；</p>
<h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p>在我的电脑里，打开文件的顺序如下： C盘/windows/system32/drivers/etc/hosts，把你下载的hosts文件拷贝到这里，替换掉系统原来的hosts文件。执行的时候可能会具备管理者权限才行。</p>
<h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><p>配置好后，，windows+r,进入命令面板，，输入ipconfig/flushdns,按enter键执行即可，这个是为了改变DNS指向</p>
<h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p>完事后，就把网给拔掉，重新连接网络</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>完事后关闭chrome再打开，这一切的前提是别忘了你得下载个Google浏览器，其他的事项应该就木有了吧！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/01/类和模模块/" title="类和模块" itemprop="url">类和模块</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-07-01T08:53:41.000Z" itemprop="datePublished"> 发表于 2017-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="这一节我们的主题是：类和模块"><a href="#这一节我们的主题是：类和模块" class="headerlink" title="这一节我们的主题是：类和模块"></a>这一节我们的主题是：类和模块</h1><p><strong>JavaScript的对象是一个属性的集合体，相互之间没有任何的联系。然而有些时候对象与对象之间的属性相同的时候，为了不重复写代码，我们要定义一个类，这个类里面的属性和方法对于他的成员或者实例都是共享的。下面就是对类的知识的介绍。</strong></p>
<h4 id="1、类和原型"><a href="#1、类和原型" class="headerlink" title="1、类和原型"></a>1、类和原型</h4><p>在JavaScript中，类的实现是基于原型继承机制的，所有的实例对象都是从同一个原型对象上继承属性，因此原型对象是类的核心。如果定义一个原型对象，然后通过inherit()函数创建一个继承自它的对象，这样就定义了一个JavaScript类。</p>
<p>例子中给一个表示“值的范围”的类定义了原型对象，还定义了一个工厂函数用以创建并初始化类的实例。</p>
<p>for example 1：</p>
<pre><code>//range.js:实现一个能表示值的范围的类

//这个工厂方法返回一个新的&quot;范围对象&quot;
function range(from,to) {
    //使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象
    //原型对象作为函数的一个属性存储，并定义所有&quot;范围对象&quot;所共享的方法
    var r = inherit(range.methods);

    //存储新的‘范围对象’的起始位置和结束位置（状态）
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    r.from = from;
    r.to = to;

    //返回这个新创建的对象
    return r;
}


//原型对象定义方法，这些方法为每个范围对象所继承
range.methods = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) {
        return this.from &lt;= x &amp;&amp; x &lt;=this.to;
    },


    //对于范围内的每个整数都调用一次f
    //这个方法只可用作数字范围
    foreach:function (f) {
        for(var x = Math.ceil(this.from);x &lt;= this.to;x++) f(x);
    },

    //返回表示这个范围的字符串
    tostring:function () {
        return&quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;
    }
};

//这里是使用‘范围对象’的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true,2在这个范围内
r.foreach(console.log);//输出1 2 3 
console.log(r);//输出(1...3)
</code></pre><p>解读：这段代码定义了一个工厂方法range(),用来创建新的范围对象。我们注意到，这里给range()函数定义了一个属性range.methods,用以快捷的存放定义类的原型对象。把对象挂在了函数上，这个方法不是惯用的方法。再者，注意range()函数给每个范围对象都定义了from和to属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在range.methods中定义的那些可共享、可继承的方法都用到了from和to属性，而且使用了this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类的方法都可以通过this的这种基本用法来读取对象的属性。</p>
<h3 id="2、类和构造函数"><a href="#2、类和构造函数" class="headerlink" title="2、类和构造函数"></a>2、类和构造函数</h3><h4 id="①、例子展示"><a href="#①、例子展示" class="headerlink" title="①、例子展示"></a>①、例子展示</h4><p>例子1中展示了定义类的其中一种方法，但是并不常用。说到了类也就有原型，而这种方法却没有用到构造函数。定义构造函数，它会初始化新创建的对象，调用构造函数的一个重要特征就是，构造函数的prototype属性被用于新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承于同一个相同的对象，属于同一个类的成员。下面我们就对例子1做了个修改，使用构造函数来代替工厂函数：</p>
<p>使用构造函数来定义“范围类”</p>
<p>for example 2：<br>    //range2.js:表示值的范围的类的另一种实现</p>
<pre><code>//这是一个构造函数，用以初始化新创建的“范围对象”
//注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from,to) {
    //存储‘范围对象‘的起始位置和结束位置
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}

//所有对象的’范围对象‘都继承自这个对象
//注意的是属性的名字必须是prototype
Range.prototype = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes:function (x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to;},
    //对于范围内的每个整数都调用一次f
    //这个方法只可用于数字范围
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    },
    //返回表示这个范围的字符串
    tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;}
};

//这里是使用’范围对象‘的一些例子
var r = range(1,3);//创建一个范围对象
r.includes(2);//true，2在这个范围内
r.foreach(console.log);//输出1 2 3
console.log(r);//输出（1...3）
</code></pre><p>解读：ok，上面看到了两种方式来定义类，我们要知道一个编程约定：定义构造函数既是定义类，并且类名首字母要大写，而普通函数和方法是首字母小写。构造函数是使用关键字new来实现的，不必使用inherit()来创建对象。例子2中原型是Range.prototype,这是一个强制的命名，而例子1中是个随意的命名。对于Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。两者的相同之处是对于范围方法的定义和调用方式。</p>
<h4 id="②、构造函数和类的标识"><a href="#②、构造函数和类的标识" class="headerlink" title="②、构造函数和类的标识"></a>②、构造函数和类的标识</h4><p>原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的实例。初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的prototype属性指向同一个原型对象，那么这两个构造函数创建的实例属于同一个类。</p>
<p>构造函数是类的外在表现形式。构造函数的名字通常用作类名，我们通常用instanceOf运算符来检测对象是否属于某个类时会用到构造函数。假设有个对象r，我们想知道r是否是Range对象，我们可以这么做：</p>
<pre><code>r instanceOf Range //如果r继承自Range.prototype,则返回true
</code></pre><p>实际上，instanceOf不会检查r是否是由Range()构造函数初始化来的</p>
<h4 id="③、constructor属性"><a href="#③、constructor属性" class="headerlink" title="③、constructor属性"></a>③、constructor属性</h4><p>在上面的例子中，将Range.prototype定义为一个新的对象，这个对象包含了方法。其实在不创建一个新的对象的时候我们也可以做到，就是用对象直接量的属性就可以定义原型上的方法。JavaScript中几乎每个函数都自动拥有prototype属性。这个属性的值是个对象，这个对象也拥有一个不可枚举的属性constructor。</p>
<p>for example 3：</p>
<pre><code>var F = function() {};//这是个函数对象
var p = F.prototype;//F的原型对象
var c = p.constructor;//原型相关联的函数
console.log(c === F);//true，这是成立的，原型和实例对象的constructor指向的是他们的构造函数
</code></pre><p>既然如此，那我们怎么达到不用重新预定义Range.prototype对象呢。</p>
<p>for example 4：</p>
<p>①</p>
<pre><code>Range.prototype = {
    constructor:Range,//显式设置构造函数反向引用
    includes:function (x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to;},
    foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    },
    tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;}
};
</code></pre><p>②这种方法是使用预定义的原型对象，预定义的原型对象包含constructor属性，然后给原型对象添加方法。</p>
<pre><code>Range.prototype.includes:function (x) {
     return this.from &lt;= x &amp;&amp; x &lt;= this.to;
};
Range.prototype.foreach: function (f) {
        for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x);
    };
Range.prototype.tostring:function () {
        return &quot;(&quot; + this.from + &quot;...&quot; + this.to +&quot;)&quot;;
};
</code></pre><h3 id="3、JavaScript中Java式的类继承"><a href="#3、JavaScript中Java式的类继承" class="headerlink" title="3、JavaScript中Java式的类继承"></a>3、JavaScript中Java式的类继承</h3><p>JavaScript中定义类的步骤可以分为3步，首先是定义一个构造函数，并设置初始化新对象的实例属性。再者，就是给构造函数的prototype对象定义实例的方法。最后就是，给构造函数定义类字段和类属性。封装到一个defineClass()函数中为：</p>
<pre><code>function defineClass(constructor,methods,statics) {
    if (methods) extend(constructor.prototype,methods);//实例的方法复制到原型中
    if (statics) extend(constructor,statics);//类属性，复制到构造函数中
    return constructor;
}
</code></pre><h3 id="4、类的扩充"><a href="#4、类的扩充" class="headerlink" title="4、类的扩充"></a>4、类的扩充</h3><p>JavaScript里的类是可以扩充的，例如如果没有去掉字符串前后空格时，可以定义个trim()方法，没有bind()方法，我们可以定义一个bind()方法。直接给Object.prototype添加方法就可以了。</p>
<p>for example 5：</p>
<pre><code>String.prototype.trim = String.prototype.trim || function() {
    return this.replace(/^\s+]\s+$/g);}
</code></pre><h3 id="5、类和类型"><a href="#5、类和类型" class="headerlink" title="5、类和类型"></a>5、类和类型</h3><p>这节主要说的是，一个对象是否是属于一个类，我们通过什么去判断，前面我们多次提到过两种方法就是通过instanceOf()运算符，再有就是通过constructor属性。但是他们的局限是执行上下文多个场景时不灵光了。再有就是我们虽然能判断是不是属于一个类，但我们不能知道构造函数的名称。通过函数名称来判断的话，也有问题就是不是所有的函数都有名称。下面我们重点说的就是鸭式辩型，就是根据一个对象能做什么来做判断。根据定义我们可以判断一个会走路、游泳并且会发出嘎嘎叫的鸟就是鸭子，因此我们可以判断对象的属性和方法是不是能做同一个事情来做判断。鸭式辩型不能用在内置类上。</p>
<p>for example 5：</p>
<pre><code>//如果o实现了除第一个参数之外的参数所表示的方法，则返回true
function quacks(o /*,..*/) {
    for(var i = 1;i &lt; arguments.length;i++) {//返回遍历o后的所有参数
    var arg = argiments[i];
    switch (typeof arg) {//如果参数是
        case &apos;string&apos;://直接用名字做检查
            if(typeof o[arg] !== &quot;function&quot;) return false;
            continue;
        case &apos;function&apos;://function：检查函数的原型对象上的方法，如果实参是函数，则使用它的原型
            arg = arg.prototype;
        case &apos;object&apos;:
            for( var m in arg) {
                if(typeof arg[m] !== &quot;function&quot;) continue;//跳过不是方法的属性
                if(typeof o[m] !== &quot;function&quot;) return false;
            }
        }
    }
    //如果程序运行到这里，说明o实现了所有的方法
    return true;
}
</code></pre><h3 id="6、JavaScript中的面向对象技术"><a href="#6、JavaScript中的面向对象技术" class="headerlink" title="6、JavaScript中的面向对象技术"></a>6、JavaScript中的面向对象技术</h3><p>前面我们学习到了JavaScript中类的基础知识：原型对象的重要性、它和构造函数的关系、instanceof()运算符如何工作等，这次我们就用两个例子实战一下。</p>
<h4 id="①、集合类"><a href="#①、集合类" class="headerlink" title="①、集合类"></a>①、集合类</h4><p>集合(set)是一种数据结构，来表示非重复值的无序集合。集合的基础方法有：添加值、检测值是否在集合中。下面的例子中一个更加通用的Set类，实现了从JavaScript值到唯一字符串的映射，然后将字符串用作属性名。</p>
<p>for example 6：</p>
<pre><code>//Set.js:值的任意集合
function Set() {//这是个构造函数
    this.values = {};//集合数据保存在对象的属性里
    this.n = 0;//集合中值的个数
    this.add.apply(this,arguments);//把所有的参数都添加到这个集合中
};

//将每个参数都添加到集合中
Set.prototype.add = function() {
    for(var i = 0;i &lt; arguments.length;i++) {//遍历每个参数
        var val = arguments[i];//待添加到集合中的值
        var str = Set._v2s(val);//把它转换为字符串
        if(!this.value.hasOwnProperty(str)) {//如果不在集合中
            this.value[str] = val;//将字符串和值对应起来
            this.n++;//集合中的值计数加一
        }
    }
    return this;//支持链式方法调用
};

//从集合删除元素，这些元素由参数指定
Set.prototype.remove = function() {
    for(var i = 0;i &lt; arguments.length;i++){
        var str = Set._v2s(arguments[i]);
        if(this.values.hasOwnProperty(str)){//如果它在集合中
            delete this.values[str];//删除它
            this.n--;
        }
    }
    return this;
};

//如果集合包含这个值，则返回true，否则返回false
Set.prototype.contains = function(value){
    return this.values.hasOwnProperty(Set._v2s(value));
};

//返回集合的大小
Set.prototype.size = function() {
    return this.n;
};

//遍历集合中的所有元素，在指定的上下文中调用f
Set.prototype.foreach = function (f,context) {
    for(var s in this.values)//遍历集合中的所有字符串
        if(this.values.hasOwnProperty(s))//忽略继承属性
        f.call(context,this.values[s]);//调用f,传入value
};

//这是一个内部函数，用以将任意JavaScript值和唯一的字符串对应起来
Set._v2s = function (val) {
    switch (val) {
        case undefined:  return &apos;u&apos;;//特殊的原始值
        case null;  return &apos;n&apos;;//值只有一个字母
        case true; return &apos;t&apos;;
        case false; return &apos;f&apos;;
        default:switch(typeof val) {
            case&apos;number&apos;: return &apos;#&apos; + val;//数字都带有#前缀
            case &apos;string&apos;:return &apos;&quot;&apos; + val;//字符串都带有&quot;前缀
            default: return &apos;@&apos; + objectId(val);
        }
    }

    //对任意对象来说，都会返回一个字符串
    //针对不同的对象，这个函数会返回不同的字符串
    //对于同一个对象的多次调用，总是返回相同的字符串
    //为做到这一点，它给o创建了一个属性，在ES5中，这个属性是不可枚举且是只读的
    function objectId(o) {
        var prop = &quot;|**object**|&quot;;//私有属性，用以存放id
        if(!o.hasOwnProperty(prop))//如果对象没有id
            o[prop] = Set._v2s.next++;//将下一个值赋给它
        return o[prop];//返回这个id
    }
};
Set._v2s.next = 100;//设置初始id的值
</code></pre><h4 id="②、枚举类型"><a href="#②、枚举类型" class="headerlink" title="②、枚举类型"></a>②、枚举类型</h4><p>枚举类型是一个类型，它是值的有限集合，如果值定义为这个类型则该值是可列出（可枚举）的。在C语言中，enum是个关键字，在JavaScript中它仅仅是个关键字，或许未来我们能看到它的身影。</p>
<p>for example 7：</p>
<pre><code>//这个函数创建一个新的枚举类型，实参对象表示类的每个实例的名字和值
//返回值是一个构造函数，它标识这个新类
//这个构造函数也会抛出异常，不能用它来创建该类型的新实例
//返回的构造函数包含名/值对的映射表
//包括由值组成的数组，以及一个foreach()迭代器函数
function enumeration(namesToValues) {
    //这个虚拟的构造函数是返回值
    var enumeration = function () {
        throw &quot;Can&apos;t Instantiate Enumerations&quot;;};

    //枚举值继承这个对象
    var proto = enumeration.prototype = {
        constructor:enumeration,//标识类型
        toString:function () { return this.name;},//返回名字
        valueOf:function () { return this.value;},//返回值
        toJSON:function () { return this.name}//转换为JSON
    };

    enumeration.values = [];//用以存放枚举对象的数组

    //现在创建新类型的实例
    for (name in namesToValues) {//遍历每个值
        var e = inherit(proto);//创建一个代表它的对象
        e.name = name;//给它一个名字
        e.value = namesToValues[name];//给它一个值
        enumeration[name] = e;//将它设置为构造函数的属性
        enumeration.values.push(e);//将它储存到值数组中
    }
    //一个类方法，用来对类的实例进行迭代
    enumeration.foreach = function (f,c) {
        for (var i = 0;i &lt; this.values.length;i++) 
            f.call(c,this.values[i]);
    };

    //返回标识这个新类型的构造函数
    return enumeration;
}
</code></pre><p>for example 8（用枚举类型来表示一副扑克牌）：</p>
<pre><code>//定义一个表示‘玩牌’的类
function Card(suit,rank) {
    this.suit = suit;//每张牌都有花色
    this.rank = rank;//以及点数
}

//使用枚举类型定义花色和点数
Card.Suit = enumeration({Clubs:1,Diamonds:2,Hearts:3,Spades:4});
Card.Rank = enumeration({Two:2,Three:3,Four:4,Five:5,Six:6,Seven:7,Eight:8,Nine:9,Ten:10,Jack:11,Queen:12,King:13,Ace:14});

//定义用以描述牌面的文本
Card.prototype.toString = function () {
    return this.rank.toString() + &quot;of&quot; + this.suit.toString();}
//比较扑克牌中两张牌的大小
Card.prototype.compareTo = function (that) {
    if (this.rank &lt; that.rank) return -1;
    if (this.rank &gt; that.rank) return 1;
    return 0;
};

//以扑克牌的玩法规则对扑克牌进行排序的函数
Card.orderByRank = function (a,b){ return a.compareTo(b);};

//以桥牌的玩法规则对牌进行排序的函数
Card.orderBySuit = function (a,b) {
    if (a.suit &lt; b.suit) return -1;
    if (a.suit &gt; b.suit) return 1;
    if (a.rank &lt; b.rank) return -1;
    if (a.rank &gt; b.rank) return 1;
    return 0;
};

//定义用以表示一副扑克牌的类
function Deck() {
    var cards = this.cards = [];//一副牌就是由牌组成的数组
    Card.Suit.foreach(function (s) {//初始化这个数组
        Card.Rank.foreach(function (r) {
            cards.push(new Card(s,r));
        });
    });
}

//洗牌的方法：重新洗牌并返回洗好的牌
Deck.prototype.shuffle = function () {
    //遍历数组中的每个元素，随机找出牌面中的最小元素，并与之交换
    var deck = this.cards.len = deck.length;
    for(var i = len - 1;i &gt; 0;i--) {
        var r = Math.floor(Math.random()*(i+1)),temp;//随机数
        temp = deck[i],deck[i] = deck[r],deck[r] = temp;//交换
    }
    return this;
};

//发牌的方法：返回牌的数组
Deck.prototype.deal = function (n) {
    if (this.cards.length &lt; n)  throw &quot;Out of cards&quot;;
    return this.cards.splice(this.cards.length - n,n);
};

//创建一副新扑克牌，洗牌并发牌
var deck = (new Deck()).shuffle();
var hand = deck.deal(13).sort(Card.orderBySuit);
</code></pre><h4 id="③、标准转换方法"><a href="#③、标准转换方法" class="headerlink" title="③、标准转换方法"></a>③、标准转换方法</h4><p>对象是要做类型转换的，有些方法是在需要做类型转换时由JavaScript解释器做自动转换调用的，而有时我们需要为没有定义的类实现这些方法。怎么做呢？有以下几个方法：</p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString:"></a>toString:</h5><p>这个方法返回的是可以表示这个对象的字符串，在要用到字符串的地方使用对象的话，就会自动调用这个方法。如果没有这个方法，类就会默认从Object.prototype中继承toString()方法。运算的结果是”[object object]”<br>,这个字符串用处不大。因为只有可读的字符串才有利用的价值。toLocaleString()与toString()方法类似。</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>它用来将对象转换为原始值。当数学运算符和关系运算符作用于数字文本表示的对象时，会自动调用这个方法。事实是多数对象都没有合适的原始值来表示它们。</p>
<h4 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h4><p>这个方法是由JSON.stringfy()自动调用的。JSON格式用于序列化良好的数据结构，而且可以处理JavaScript原始值、数组和纯对象。它和类无关，党对一个对象进行序列化操作时，它会忽略对象的原型和构造函数。如果将Range对象作为参数传给JSON.stringfy()，将会返回{“from”:1,”to”:3}这种字符串。如果将这些字符串传入JSON.parse()，将会得到一个和Range对象具有相同属性的纯对象，但不会包含继承来的方法。</p>
<p>同样有时我们也需要自定义toJSON()方法来实现个性化的序列化格式。</p>
<p>for  example 9(使用extend()来向Set.prototype来添加方法):</p>
<pre><code>//将这些方法都添加到Set类的原型对象中
extend(Set.prototype,{
    //将集合转换为字符串
    toString:function () {
        var s = &quot;{&quot;,
        i = 0;
        this.foreach(function (v) {s += ((i++ &gt; 0) ? &quot;,&quot;:&quot;&quot;) + v;});
        return s + &quot;}&quot;;
    },
    //类似toString(),但是对于所有的值都将调用toLocaleString()
    toLocaleString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            if (v == null) s += v;//null和undefined
            else s += v.toLocaleString();//其他情况
            });
        return s + &quot;}&quot;;
    },
    //将集合转换为数组
    toArray：function () {
        var a = [];
        this.foreach(function (v) {a.push(v);});
        return a;
    }
});

//对于要从JSON转换为字符串的集合都被当作数组来对待
Set.prototype.toJSON = Set.prototype.toArray;
</code></pre><h3 id="7、子类"><a href="#7、子类" class="headerlink" title="7、子类"></a>7、子类</h3><p>JavaScript里对子类的创建的关键之处在于采用合适的方法对原型对象进行初始化，并且会讲解到类继承的替代方案：组合。</p>
<p>创建子类的关键：</p>
<p>for example 10：</p>
<pre><code>B.prototype = inherit(A.prototype);//子类派生自父类
B.prototype.constructor = B;//重载继承来的constructor属性
</code></pre><h4 id="组合与子类"><a href="#组合与子类" class="headerlink" title="组合与子类"></a>组合与子类</h4><p>面向对象编程中一条广为人知的设计原则：组合优于继承。</p>
<p>for example 11(使用组合代替继承的集合的实现):</p>
<pre><code>//实现一个FilteredSet，它包装某个指定的”集合“的对象
//并对传入add()方法的值应用了某种指定的过滤器
//“范围”类中其他所有的核心方法延续到包装后的实例中

var FilteredSet = Set.extend(
    function FilteredSet(set,filter) {//构造函数
        this.set = set;
        this.filter = filter;
    },
    {//实例方法
    add:function() {
        //如果已经有过滤器，直接使用
        if(this.filter) {
            for(var i = 0;i &lt; arguments.length;i++) {
                var v = arguments[i];
                if(!this.filter(v))
                    throw new Error(&quot;FilteredSet:value &quot; + v + &quot;rejected by filter&quot;);
                }
            }

            //调用set中的add()方法
            this.set.add.apply(this.set,arguments);
            return this;
        },
        contains:function (v) { return this.set.contains(v);},
        size:function() { return this.set.size();},
        foreach:function(f,c) { this.set.foreach(f,c);}
});
</code></pre><h4 id="类的层次结构和抽象类"><a href="#类的层次结构和抽象类" class="headerlink" title="类的层次结构和抽象类"></a>类的层次结构和抽象类</h4><p>for example 12（抽象类和非抽象Set类的层次结构）：</p>
<pre><code>//这个函数可以用做任何抽象方法，很方便
function abstractmethod() { throw new Error (&quot;abstract method&quot;);}

//AbstractSet类定义了一个抽象方法：contains()

function AbstractSet() { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);}
AbstractSet.prototype.contains = abstractmethod;


//NotSet是AbstractSet的一个非抽象子类
//所有不在其他集合中的成员都在这个集合中
//因为它是在其他集合是不可写的条件下定义的
//同时由于它的成员是无限个，因此它是不可枚举的
//我们只能用它来检测元素成员的归属情况
//注意，我们使用了Function.prototype.extend()来定义这个子类

var NotSet = AbstractSet.extend(
    function NotSet(set) { this.set = set;},
    {
        contains:function (x) { return !this.set.contains(x);},
        toString:function (x) { return &quot;～&quot; + this.set.toString();},
        equals:function (that) {
            return that instanceof NotSet &amp;&amp; this.set.equals(that.set);
        }
    }
);


//AbstractEnumerableSet是AbstractSet的一个抽象子类
//它定义了抽象方法size()和foreach()
//然后实现了非抽象方法isEmpty()、toArray()、toLocaleString()和equals()方法
//子类实现了contains()、size()和foreach()，这三个方法可以很轻松的调用这5个非抽象方法

var AbstractEnumerableSet = AbstractSet.extend(
    function () { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);},
    {
    size:abstractmethod,
    foreach:abstractmethod,
    isEmpty:function () { return this.size == 0;},
    toString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            s += v
            });
        return s + &quot;}&quot;;
    },
    toLocaleString:function () {
        var s = &quot;{&quot;,i = 0;
        this.foreach(function (v) {
            if (i++ &gt; 0) s += &quot;,&quot;;
            if (v == null) s += v;//null和undefined
            else s += v.toLocaleString();//其他情况
            });
        return s + &quot;}&quot;;
    },
    equals:function (that) {
        if(!(that instanceof AbstractEnumerableSet)) return false;
        //如果它们的大小不同，则它们不相等
        if(this.size() != that.size()) return false;
        //检查每一个元素是否也在that中
        try{
            this.foreach(function (v) { if(!that.contains(v)) throw false;});
            return true;//所有的元素都匹配，集合相等
        } catch(x) {
            if(x === false) return false;//集合不相等
            throw x;//发生了其他异常，重新抛出异常
        }
    }
});


//SingletonSet是AbstractEnumerableSet的非抽象子类
//singleton集合是只读的，它只包含一个成员

var SingletonSet = AbstractEnumerableSet.extend(
    function SingletonSet(member) { this.member = member;},
    {
        contains:function (x) { return x === this.member;},
        size:function () { return 1;},
        foreach:function (f,ctx) { f.call(ctx,this.member);}
    }
);


//AbstractWritableSet是AbstractEnumerableSet的抽象子类
//它定义了抽象方法add()和remove()
//然后实现了非抽象方法union()、intersection()和difference()

var AbstractEnumerableSet = AbstractEnumerableSet.extend(
    function () { throw new Error(&quot;Can&apos;t intantiate abstract classes&quot;);},
    {
        add:abstractmethod,
        remove:abstractmethod,
        union:function (that) {
            var self = this;
            that.foreach(function (v) { self.add(v);});
            return this;
    },
    intersection:function (that) {
        var self = this;
        that.foreach(function (v) { if(!that.contains(v)  self.remove(v);)});
        return this;
    },
    difference:function (that) {
        var self = this;
        that.foreach(function (v) { self.remove(v);});
        return this;
    }
});


//ArraySet是AbstractWritableSet的非抽象子类
//它以数组的形式表示集合中的元素
//对于它的contains()方法使用了数组的线性查找
//因为contains()方法的算法复杂度是O(n),而不是O(1)
//它非常适用于相对较小型的集合，这里的实现用到了indexOf()和forEach()

var ArraySet = AbstractWritableSet.extend(
    function ArraySet() {
        this.values = [];
        this.add.apply(this.arguments);
    },
    {
        contains:function (v) { return this.values.indexOf(v) != -1;},
        size:function () { return this.values.length;},
        foreach:function (f,c) { this.values.forEach(f,c);},
        add:function () {
            for (var i = 0;i &lt; arguments.length;i++) {
                var arg = arguments[i];
                if(!this.contains(arg)) this.values.push(arg);
            }
            return this;
        },
        remove:function () {
            for (var i = 0;i &lt; arguments.length;i++) {
                var p = this.values.indexOf(arguments[i]);
                if(p === -1) continue;
                this.values.splice(p,1);
            }
            return this;
        }
    }
);
</code></pre><h3 id="8、ECMAScript5中的类"><a href="#8、ECMAScript5中的类" class="headerlink" title="8、ECMAScript5中的类"></a>8、ECMAScript5中的类</h3><p>ES5中给属性特性增加了方法支持（getter、setter、可枚举性、可写性和可配置性），还增加了对象可扩展性的限制。</p>
<h4 id="让属性不可枚举"><a href="#让属性不可枚举" class="headerlink" title="让属性不可枚举"></a>让属性不可枚举</h4><p>for example 13：</p>
<pre><code>//定义不可枚举的属性
//将代码包装在一个匿名函数中，这样定义的变量就在这个函数作用域内
(function () {
    //定义一个不可枚举的属性objectId，它可以被所有对象继承
    //当读取这个属性时调用getter函数
    //它没有定义setter，因此它是只读的
    //它不可配置，因此不能删除
    Object.defineProperty(Object.prototype,&quot;objectId&quot;,{
        get:idGetter,//取值器
        enumerable：false,//不可枚举
        configurable：false,//不可配置
    });

//当读取objectId的时候直接调用这个getter函数
function idGetter() {//getter函数返回该id
    if(!(iddrop in this)) {//如果对象中不存在id
        if(!Object.isExtensible(this))//并且可以增加属性
            throw Error(&quot;Can&apos;t define id for noneextensible objects&quot;);
        Object.defineProperty(this,idprop,{//给它一个值
                value:nextid++,//就是这个值
                writable:false,//只读
                enumerable:false,//不可枚举
                configuable:false//不可删除
            });
        }
        return this[iddrop];//返回已有的或新的值
    };

    //idGetter()用到了这些变量，这些都属于私有变量
    var iddrop = &quot;|**objectId**|&quot;;//假设这个属性没有用到
    var nextid = 1;//给它设置初始值

}());//立即执行这个包装函数
</code></pre><h3 id="9、模块化"><a href="#9、模块化" class="headerlink" title="9、模块化"></a>9、模块化</h3><h4 id="用做命名空间的对象"><a href="#用做命名空间的对象" class="headerlink" title="用做命名空间的对象"></a>用做命名空间的对象</h4><p>模块化的过程中为了避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为空间的对象属性储存起来，而不是定义全局函数和变量。例如Set()构造函数，是全局的，然后给这个类定义了很多实例方法，但将这些方法存储到Set.prototype的属性中，因此就不是全局的。</p>
<p>for  example  14：</p>
<pre><code>var collections;//声明这个全局变量
if(!collections)//如果它原本不存在
    collection = {};//创建一个顶层的命名空间对象
collection.sets = {};//将sets命名空间创建在它的内部
//在collections.sets内定义set类
collections.sets.AbstractSet = function () {}
</code></pre><h4 id="作为私有命名空间的函数"><a href="#作为私有命名空间的函数" class="headerlink" title="作为私有命名空间的函数"></a>作为私有命名空间的函数</h4><p>将模块定义在某个函数的内部实现。</p>
<p>for example 15：</p>
<pre><code>//模块中函数的Set类
//声明全局变量Set，使用一个函数的返回值给它赋值
//函数结束时紧跟一对圆括号说明这个函数定义后立即执行
//它的返回值赋值给set，而不是将这个函数赋值给Set
//这是一个函数表达式，不是一条语句，因此函数&quot;invocation&quot;并没有创建全局变量

var Set = (function invocation() {
    function Set() {//这个构造函数是局部变量
        this.values = {};//这个对象的属性用来保存这个集合
        this.n = 0;//集合中的值的个数
        this.add.apply(this,arguments);//将所有的参数都添加到集合中
    }

    //给Set.prototype定义实例方法
    //省略部分代码
    Set.prototype.contains = function(value) {
        //我们调用了v2s()，而不是调用笨重的set._v2s()
        return this.values.hasOwnProperty(v2s(value));
    }} ());//定义后立即执行
</code></pre><p>OR：</p>
<pre><code>var collections;//声明这个全局变量
if(!collections)//如果它原本不存在
    collection = {};//创建一个顶层的命名空间对象
collection.sets = (function invocation() {
    function Set() {//这个构造函数是局部变量
        this.values = {};//这个对象的属性用来保存这个集合
        this.n = 0;//集合中的值的个数
        this.add.apply(this,arguments);//将所有的参数都添加到集合中
    }

    //给Set.prototype定义实例方法
    //省略部分代码
    Set.prototype.contains = function(value) {
        //我们调用了v2s()，而不是调用笨重的set._v2s()
        return this.values.hasOwnProperty(v2s(value));
    }} ());//定义后立即执行
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/29/function/" title="函数基础知识学习" itemprop="url">函数基础知识学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-06-29T14:03:04.000Z" itemprop="datePublished"> 发表于 2017-06-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="我们的主题是什么？"><a href="#我们的主题是什么？" class="headerlink" title="我们的主题是什么？"></a>我们的主题是什么？</h1><p>函数是一种特殊的对象，有自己的属性和方法，而这些个属性和方法是什么我们必须知道，什么样子是函数，函数的用处有哪些，这些是我们必须明确知晓的。</p>
<h2 id="一、函数的结构"><a href="#一、函数的结构" class="headerlink" title="一、函数的结构"></a>一、函数的结构</h2><p>函数体的组成部分必须包括：关键字function、函数名、一对圆括号、一对花括号、参数；</p>
<p>函数的声明方式有：函数语句式和函数定义式：</p>
<p>for example 1：</p>
<pre><code>① function  funcName() { //代码块} funcName();
② var f = function() {//代码块}  f();
</code></pre><p>注意第二种是把函数赋值给了一个函数，这里有和变量的声明一样的问题，就是声明提前的现象。</p>
<p>参数有形参和实参两种形式，形参是函数定义的时候出现的，而实参是函数调用的时候出现的，形参类似于局部变量，实参是一种类数组对象，名称为arguments，通过下标就能访问实参元素。</p>
<p>我们需要知道的是形参和实参的数量如果不相等的时候，若形参数量多于实参则属于undefined，如果实参多的话则会被自动省略掉。当然前面也说了实参列表是个类数组对象，我们可以用arguments来表达一个实参列表，这里就能用arguments来表示任意数量的实参个数了。</p>
<p>函数从被定义开始到调用为止，定义是一次完事，而调用的话则可以被调用任意次数。定义已经说完，就说调用。</p>
<h2 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h2><p>函数的调用有4中方式：函数调用、方法调用、构造函数调用和用call()和apply()的间接调用。</p>
<h3 id="1、函数调用"><a href="#1、函数调用" class="headerlink" title="1、函数调用"></a>1、函数调用</h3><p>这是最普通的调用了，解释器到达结尾返回undefined，碰到return语句，返回其值，没有值的话返回undefined。</p>
<p>注意的是，在非严格模式中，this返回的是全局对象不然就是undefined。</p>
<h3 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h3><p>函数作为对象的一个方法被调用，与函数调用的最大区别就是this值的不同，方法调用的this值的上下文是函数所处的对象。</p>
<p>当然，如果想要在函数调用中的this值是外部函数，则必须在外部函数的函数体内使用 <strong>var self = this</strong>，这样的话，就能达到this值就是外部函数了。</p>
<h3 id="3、构造函数调用"><a href="#3、构造函数调用" class="headerlink" title="3、构造函数调用"></a>3、构造函数调用</h3><p>构造函数必须用到new关键字，构造函数初始化了一个对象，这个对象的属性继承于prototype属性，而且this值指向的就是这个初始化了的对象。</p>
<p>构造函数调用允许省略实参列表和圆括号。</p>
<h3 id="4、间接调用"><a href="#4、间接调用" class="headerlink" title="4、间接调用"></a>4、间接调用</h3><p>用call()和apply()来达到某个对象使用某个函数作为方法的目的，这两种方法里的第一个实参的this值是这个使用函数的对象。无论哪个对象都可以使用本身所不具备的函数作为方法。call()的后面的参数是实参列表，但是apply()方法的后面就是个数组形式的实参列表了。</p>
<p>下面就说说作为一个整体的函数的情况吧，函数可以赋值给一个值，可以作为参数传给另外一个参数。</p>
<h2 id="三、函数的整体使用"><a href="#三、函数的整体使用" class="headerlink" title="三、函数的整体使用"></a>三、函数的整体使用</h2><h3 id="1、嵌套函数"><a href="#1、嵌套函数" class="headerlink" title="1、嵌套函数"></a>1、嵌套函数</h3><p>这里就有个作用域规则的事情，任何变量都能在他的函数体内发生作用，因为函数体是嵌套的，所以就有了嵌套的作用域，就有了作用域链，虽然外部函数不能访问到内部函数，但是可以把内部函数作为返回值返回出来。这里就会涉及到一个叫做闭包的技术，意思就是函数体通过作用域链关联起来（外部函数和嵌套函数是有关系的），函数体内的变量可以保存在作用域内。</p>
<h3 id="2、作为命名空间的函数"><a href="#2、作为命名空间的函数" class="headerlink" title="2、作为命名空间的函数"></a>2、作为命名空间的函数</h3><p>变量有全局变量，有局部变量。而我们不想让全局变量来污染全局作用域，那就必须用个函数来包括起来整个其他函数。方式有2：</p>
<p>for example 2：</p>
<pre><code>function func() {
    //模块代码
    //所有变量均为局部变量，不污染全局命名空间
}
func();//必须得调用
</code></pre><p>再有一种方式：</p>
<pre><code>(function(){

//代码块}())//立即调用，这是个定义表达式
</code></pre><h2 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h2><p>这个就是运用一些有一定含义的关键字来编写程序，比如可以用reduce()来计算数组合成一个数字的运算，而不用采取遍历计算的方式，等等吧。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/23/Array/" title="数组基础知识" itemprop="url">数组基础知识</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-06-23T12:57:30.000Z" itemprop="datePublished"> 发表于 2017-06-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="我们得知道这节的主题是什么："><a href="#我们得知道这节的主题是什么：" class="headerlink" title="我们得知道这节的主题是什么："></a>我们得知道这节的主题是什么：</h1><p><strong>一是数组是什么，长什么样子，我们看到了就能一眼认出来这个是不是数组；</strong></p>
<p><strong>二我们怎么创建数组，讲解的是数组的声明方式；</strong></p>
<p><strong>三是我们须知数组的一些属性和方法，因为数组不是你想怎么来就怎么来的，你必须按一定的套路走才是可行的；</strong></p>
<p><strong>四是我们要知道数组与对象和字符串的关系，因为是近亲所以有更多有意思的事情。</strong></p>
<p><strong>好了接下来一一说。</strong></p>
<h3 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h3><p><strong>数组是一系列值（元素）的有序集合体。</strong>从这里我们来解读一下。</p>
<p>①数组既然是个集合体，那么就有一个范围，来表示这就是一个数组单元，数组的开始和结束标识符就是”[]”,双引号里面的中括号就是一个数组的最基本的构成；</p>
<p>for example1：</p>
<pre><code>var a = [];
var b = [,1,2,7,true,&apos;ww&apos;,{x:1},1];
</code></pre><p>②数组里面的元素是什么，可以使任意数据类型的值的杂合，当然有时候杂合的东西的不容易操作。比如例子1里面的b数组就是个各种数据类型都有的杂合体，JSON无疑就是个数组里面加对象；</p>
<p>③有序，数组里面的元素是有顺序的，顺序是从整数0开始排序的（也就是每个数组的元素都有个索引值，这个索引值就是从0开始的），因此数组b中的两个元素数字1，他们的索引是不一样的，明显的是第一个索引值小，第二个大。</p>
<p>现在我们知道了数组的长相，能辨认数组了，那么接下来我们就看看怎么声明一个数组：</p>
<h3 id="二、数组的声明"><a href="#二、数组的声明" class="headerlink" title="二、数组的声明"></a>二、数组的声明</h3><p>声明数组的方式总的来说有两种：</p>
<p>①仿照对象的声明，通过数组直接量的形式，例子就是例子1；</p>
<p>②就是用个关键字new 来声明：</p>
<p>for example2：</p>
<pre><code>var a = new Array(1,2,3,true,&apos;test&apos;);
</code></pre><p>综合老看推荐的是使用数组直接量的方式来声明一个数组。</p>
<p>这里我们在稍微的说点，稀松数组就是数组里存在一个空的元素，而多维数组就是几个数组的嵌套了，因为数组的元素不是固定的，所以可以有这效果。</p>
<h3 id="三、数组的属性和方法"><a href="#三、数组的属性和方法" class="headerlink" title="三、数组的属性和方法"></a>三、数组的属性和方法</h3><p>数组知识的重点，就是这个数组的属性和方法，再有个重点就是数组与对象和字符串的关系。这次我们就先谈谈这个，分增、删、改、查4个方面来说。</p>
<h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>增的意思是数组的元素增多了，这个增多可以是原来数组的值的增加，也可以是形成了一个新的数组，这就意味着数组的length是变大了。好！开始介绍方法。</p>
<p>①、先来个不改变原来数组的:concat(),他的意思是把两个数组的元素给拼接起来,或者就是把元素添加到数组的元素中去：<br>for example4：</p>
<pre><code>var d = [1,3];
var dd = d.concat(&apos;1&apos;,2,4);//不改变原来的数组[1,3,&apos;1&apos;,2,4]
var ddd = d.concat([1,3,5],[4,7]);//[1,3,1,3,5,4,7]
</code></pre><p>②、通过索引为数组增加值，变化的是原来的数组：</p>
<p>for example3：</p>
<pre><code>var c = [];
c[0] = 1;//c = [0]
c[1] = 2;//c = [0,2]
c[3] = &apos;test&apos;;//c = [0,2,&apos;test&apos;]
</code></pre><p>③、push(),改变了原来的数组，意思是往原来的数组的末尾加一个或多个元素,这个和pop()组成了类似于栈的先进后出的感觉：</p>
<p>for example4：</p>
<pre><code>var pushes = [&apos;hello&apos;,&apos;2&apos;,22];
    pushes.push(11,77);//这样既可[&apos;hello&apos;,&apos;2&apos;,22,11,77]
</code></pre><p>④、unshift(),类似于push()，不过unshift()是把元素添加到了原数组元素的第一个位置：</p>
<p>for example4：</p>
<pre><code>var unshifted = [&apos;hello&apos;,&apos;2&apos;,22];
    unshifted.unshift(11,77);//这样既可[11,77,&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>⑤、splice(),这个比较特殊，因为他能增加也能减少，同样的是他改变的也是原来的数组,splice()方法里有三个参数，第一个为必填的，后两个为可选的，第一个参数是数组的索引值，是个整数，第二个意思是从第一个索引值的位置开始要去掉几个元素,这个值可以为负值，最后一个参数意思是去掉了参数，我们用什么来填补，是我们要填补的元素,返回的值是删除元素组成的数组：</p>
<p>for example5：</p>
<pre><code>var s = [&apos;hello&apos;,&apos;2&apos;,22,11,77];
    s.splice(0,3);//返回[&apos;hello&apos;,&apos;2&apos;,22]
    s.splice(0,3，&apos;world&apos;,33);//返回[&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>以上就是增，下面说说删。</p>
<h4 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h4><p>因为说过了增，删的部分大部分是对应的，所以我们就把那些不对应的讲解一下：</p>
<p>①、delete，这是个运算符，他删除的是元素的值，至于数组的length是不变的，去掉的是数组的元素值，去不掉的是数组的属性。</p>
<p>for example6：</p>
<pre><code>var del = [1,2,3];
delete del[2];//在原数组中就没有了元素3，但是数组的length仍旧是3
</code></pre><p>②、pop(),对比push()去吧！</p>
<p>③、shift(),对比unshift()去吧！</p>
<p>④、splice()</p>
<h4 id="3-改和查"><a href="#3-改和查" class="headerlink" title="3.改和查"></a>3.改和查</h4><p>把改和查放在一起，因为我们会感觉到他们是一体的。</p>
<p>①、slice(),能接收两个参数，第一个参数是必须的，为整数值，第二个参数为可选的，为整数值，都可为负值，不改变原有的数组,截取的值包前不包后：</p>
<p>for example7：</p>
<pre><code>var sl = [1,2,3];
sl.slice(0,1);//返回[1]
</code></pre><p>②、reverse(),把数组的元素值给倒过来排序，改变了原来的数组元素的排序：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3];
revers.reverse();//返回[3,2,1]
</code></pre><p>③、sort(),把数组的元素按英文字母的顺序进行排序，也就是ASC11的顺序，这个可以接受一个比较函数，进行更好运算：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3,10];
revers.sort();//返回[1,10,2,3]
revers.sort(function(x,y) {
        return x-y;
    });//返回的就是按数字大小比较后的顺序的数组了
</code></pre><p>对一个字符串数组执行不区分大小写的字符表排序，比较函数首先将参数转化为小写字符串，再开始比较：</p>
<p>for example8：</p>
<pre><code>var a = [&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;];
a.sort();//返回[&apos;Bug&apos;,&apos;Dog&apos;,&apos;ant&apos;,&apos;cat&apos;]
a.sort(function(x,y) {
        var a = x.toLowerCase();
        var b = y.toLowerCase();
        if (a &lt; b) return -1;
        if (a &gt; b) return 1;
        return 0;
    });//返回[&apos;ant&apos;,&apos;Bug&apos;,&apos;cat&apos;,&apos;Dog&apos;]
</code></pre><p>这里我们再简单的说说例子7和例子8中，比较函数的工作原理，我们传进去的是两个参数，所以这个比较函数每次的比较是两个两个进行比较的，每次比较后就进行一次两个元素位置的调换，而如果前(n-1)个元素没有排好序的话（说的就是最后一个元素前的元素如果已经排好序，那就直接进行第n-1个元素与最后一个元素的比较就可以了），正常情况下，我们是要用前面n-1个元素来与第n个元素进行比较的。如果想自己看看操作的话，就用chrome自己打个断点，自己看看他的工作流程。</p>
<p>④、遍历：for循环和forEach(),都是遍历数组内的每个元素，不同的是前者有个break可以跳出，后者想要终止的话，则必须把forEach()放到try()块中,里面传进去的是个函数：</p>
<p>for example8：</p>
<pre><code>function foreach(a,f,t) {
    try {a.forEach(f,t);}
    catch(e) {
        if (e === foreach.break) return;
        else throw e;
    }
}
foreach.break = new Error(&quot;StopIteration&quot;);
</code></pre><p>⑤、映射，这里就是用map()，就是数学函数里映射，一对一，里面包括一个函数：</p>
<p>for example9：</p>
<pre><code>var a = [1,3,4];
b = a.map(function(x) {
return x*x;});//返回的就是[1,9,16],返回的是新的数组，不修改原来的数组
</code></pre><p>⑥、过滤，就是用某个条件作为筛选，用到的是filter(),这个方法会过滤掉undefined和null，他返回的总是稠密数组不会是稀疏数组：</p>
<p>for example10：</p>
<pre><code>var a = [5,4,3,2,1];
smallValues = a.filter(function(x) { return x &lt; 3;});
other = a.filter(function(x) { return x%2 == 0;});//参数可以多个

a = a.filter(function(x) { return x !== undefined &amp;&amp; x !== null;});//过滤掉undefined和null元素
</code></pre><p>⑦、every()和some()，这里返回的是个boolean值：</p>
<p>for example11：</p>
<pre><code>var a = [1,2,3,4,5];
a.every(function(x) {return x &lt; 10;});//返回的就是true
a.every(function(x) { return x % 2 == 0;});//返回false
</code></pre><p>而如果用some()来代替every()的话，就全是true了，因为some()意思是存在而every()是全部的意思。</p>
<p>⑧、reduce()和reduceRight()，他们的意思就是通过某个函数把数组的元素整合为单个值，需要传进去两个参数，不过以数值和对象为主，前者是从低索引开始后者从高索引开始：</p>
<p>for example 12：</p>
<pre><code>var a = [1,2,3,4,5];
var sum = a.reduce(function(x,y) {
    return x+y;},0);//0是初始值，可以不要，返回15
var max = a.reduce(function(x,y) {
    return (x &gt; y) ? x :y;});//求最大值
var product = a.reduce(function(x,y) {
    return x * y;},1);//乘积
</code></pre><p>下面说说对象的形式吧！</p>
<p>for example 13:</p>
<pre><code>var objects = [{x:1},{y:2},{z:3}];
var merged = objects.reduce(union);//返回{x:1,y:2,z:3}，是对象的集合

var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
var leftUnion = objects.reduce(union);//返回{x:1,a:1,y:2,z:3}
var rightUnion = objects.reduceRight(union);//返回{x:1,y:2,z:3,a:3}
</code></pre><p>⑨、indexOf()和lastIndexOf()，里面填写的是元素，返回的是这个元素的位置的索引，如果元素重复，返回的是第一个元素的位置的索引值，这两个方法方向相反，如果没有的话就返回-1,有两个参数，第二个参数可选，意思是要从哪个索引开始：</p>
<p>for example 14:</p>
<pre><code>var a = [0,1,2,1,0];
a.indexOf(1);//1
a.indexOf(3);//-1，因为没有这个值
a.lastIndexOf(1);//3
</code></pre><p>for example 15:</p>
<pre><code>//在数组中查找所有出现的x,并返回一个匹配数组索引的数组
function findAll(a,x) {
    var results = [],
        len = a.length,
        pos = 0;
    while(pos &lt; len) {
        pos = a.indexOf(x,pos);
        if (pos === -1) break;
        results.push(pos);
        pos +=1;
    }
    return results;
}
</code></pre><h3 id="四、数组的亲密关系"><a href="#四、数组的亲密关系" class="headerlink" title="四、数组的亲密关系"></a>四、数组的亲密关系</h3><p>数组的亲密关系牵扯到两个：一是字符串；二是对象，无论哪个都可以有数组的一些特性，如:自动更新length、设置length来获取一段数组、从Array.prototype来继承有用的方法、其类属性为Array：</p>
<h4 id="1-与字符串的关系"><a href="#1-与字符串的关系" class="headerlink" title="1.与字符串的关系"></a>1.与字符串的关系</h4><p>①、join()和split()这是一对，前者把数组元素以某种方式拼接起来并输出一个字符串，后者是把字符串以某个元素为分界线分为数组，不再举例子；</p>
<p>②、toString()和toLocalString(),与join()类似，把数组元素转化为字符串，后者是以本地化分隔符连接元素生成字符串；</p>
<p>③、说说继承Array.prototype的方法：</p>
<p>for example 16:</p>
<pre><code>var s = &quot;JavaScript&quot;;
Array.prototype.join.call(s,&quot; &quot;);//&quot;J a v a S c r i p t&quot;,继承了join()方法
Array.prototype.filter.call(s,function(x) {
        return x.match(/[^aeiou]/);}).join(&quot;&quot;);//筛选掉了元音字母，&quot;JvScrpt&quot;
</code></pre><p>切记，字符串不能改变的，他们是只读的，对于那些push()、sort()、reverse()、splice()这些方法是不能使用的。</p>
<h4 id="2-类数组对象"><a href="#2-类数组对象" class="headerlink" title="2.类数组对象"></a>2.类数组对象</h4><p>这个我们还是能经常碰到的，譬如用document.getElementsByName()这个方法时得到的就是个类数组。</p>
<p>for example 17：</p>
<pre><code>var a = {&quot;0&quot;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3};//类数组对象
Array.prototype.join.call(a,&apos;+&apos;);//&apos;a+b+c&apos;
Array.prototype.slice.call(a,0);//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],真正的数组副本
Array.prototype.map.call(a,function(x) {
        return x.toUpperCase();});//[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]
</code></pre><h3 id="五、其他：数组类型"><a href="#五、其他：数组类型" class="headerlink" title="五、其他：数组类型"></a>五、其他：数组类型</h3><p>判断是不是数组我们用两个方式：</p>
<h4 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1.Array.isArray()"></a>1.Array.isArray()</h4><pre><code>Array.isArray([]);//true
Array.isArray({});//false
</code></pre><h4 id="2-instanceOf运算符"><a href="#2-instanceOf运算符" class="headerlink" title="2.instanceOf运算符"></a>2.instanceOf运算符</h4><pre><code>[] instanceOf Array;//true
({}) instanceOf Array;//false
</code></pre><h1 id="告一段落，下次看函数"><a href="#告一段落，下次看函数" class="headerlink" title="告一段落，下次看函数"></a>告一段落，下次看函数</h1>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/26/循环和严格模式/" title="语句" itemprop="url">语句</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="小码哥" target="_blank" itemprop="author">小码哥</a>
		
  <p class="article-time">
    <time datetime="2017-05-26T01:57:14.000Z" itemprop="datePublished"> 发表于 2017-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>一、表达式语句</strong></p>
<p>表达式语句常见的就是两类：赋值语句和函数调用，声明语句有var声明和function声明。</p>
<p><strong>二、条件语句</strong></p>
<p>条件语句两种if语句和switch语句，这里就说说switch语句：</p>
<pre><code>switch(n){
case ①;
//代码块
break；
case ②；
//代码块
break;
default;
//代码块
break;
}
</code></pre><p>传进来参数与①、②、③进行匹配，如果n与某个值恒等时，就执行相应的代码块。</p>
<p><strong>三、use strict（严格模式）与非严格模式的比较</strong></p>
<p>use strict语句的目的是说明脚本或者函数体的后续代码将会解析为严格代码。如果放在顶层了，那么就是严格代码。</p>
<p>use strict和普通语句的区别：</p>
<p>1.不包含任何语言的关键字，对于JavaScript解释器来说，它只是一条没有副作用的表达式语句，什么也没有做。</p>
<p>2.use strict只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。并不一定是出现在首行。</p>
<p>严格模式与非严格模式的区别</p>
<p>1.严格模式中禁止使用with语句；</p>
<p>2.所有的变量都要先声明；</p>
<p>3.严格模式中，调用的函数中的一个this值是undefined，非严格模式中调用的函数中的this值总是全局对象；</p>
<p>4.严格模式中，通过call（）或者apply（）来调用函数时，其中的this值就是通过call（）或者apply()传入的第一个参数（非严格模式中，null和undefined值被全局对象和转换为对象的非对象所代替）；</p>
<p>5.严格模式中，给只读属性赋值和给不可扩展的对象创建新成员时，会抛出一个类型错误的异常，在非中仅仅是操作失败；</p>
<p>6.严格模式中，函数的arguments对象拥有传入函数值的静态副本，非中arguments的数组和函数都是指向同一个值的引用；</p>
<p>7.严格模式中，当delete运算符后跟随非法的标识符（变量、函数、函数参数）时，会抛出语法错误，非严格模式中，delete什么也没有做，返回false；</p>
<p>8.严格模式中，在一个函数直接量中定义两个或多个同名属性将产生一个语法错误；</p>
<p>9.严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误，非中不会报错；</p>
<p>10.严格模式中，标识符eval和arguments当作关键字，它们的值是不能更改的。不能赋值、声明为变量、用作函数名、用作函数参数或者用作catch块的标识符；</p>
<p>11.严格模式中限制了对调用栈的检测能力，arguments.caller和arguments.callee都会抛出一个类型错误异常。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="https://github.com/maHouse" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 兄弟姐妹们，你们好！ <br/>
			This is my blog,it will be better and better，welcome to come here！</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5309319763" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/https://github.com/maHouse" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:1037243021@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="小码哥">小码哥</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
