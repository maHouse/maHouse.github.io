<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮游Bar</title>
  <subtitle>道之所向，虽千万人吾往矣</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maHouse.github.io/"/>
  <updated>2017-06-23T14:40:59.836Z</updated>
  <id>http://maHouse.github.io/</id>
  
  <author>
    <name>小码哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组基础知识</title>
    <link href="http://maHouse.github.io/2017/06/23/Array/"/>
    <id>http://maHouse.github.io/2017/06/23/Array/</id>
    <published>2017-06-23T12:57:30.000Z</published>
    <updated>2017-06-23T14:40:59.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我们得知道这节的主题是什么："><a href="#我们得知道这节的主题是什么：" class="headerlink" title="我们得知道这节的主题是什么："></a>我们得知道这节的主题是什么：</h1><p><strong>**一是</strong>数组是什么，长什么样子，我们看到了就能一眼认出来这个是不是数组；**</p>
<p><strong>二我们怎么创建数组，讲解的是数组的声明方式；</strong></p>
<p><strong>三是我们须知数组的一些属性和方法，因为数组不是你想怎么来就怎么来的，你必须按一定的套路走才是可行的；</strong></p>
<p><strong>四是我们要知道数组与对象和字符串的关系，因为是近亲所以有更多有意思的事情。</strong></p>
<p><strong>好了接下来一一说。</strong></p>
<h3 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h3><p><strong>数组是一系列值（元素）的有序集合体。</strong>从这里我们来解读一下。</p>
<p>①数组既然是个集合体，那么就有一个范围，来表示这就是一个数组单元，数组的开始和结束标识符就是”[]”,双引号里面的中括号就是一个数组的最基本的构成；</p>
<p>for example1：</p>
<pre><code>var a = [];
var b = [,1,2,7,true,&apos;ww&apos;,{x:1},1];
</code></pre><p>②数组里面的元素是什么，可以使任意数据类型的值的杂合，当然有时候杂合的东西的不容易操作。比如例子1里面的b数组就是个各种数据类型都有的杂合体，JSON无疑就是个数组里面加对象；</p>
<p>③有序，数组里面的元素是有顺序的，顺序是从整数0开始排序的（也就是每个数组的元素都有个索引值，这个索引值就是从0开始的），因此数组b中的两个元素数字1，他们的索引是不一样的，明显的是第一个索引值小，第二个大。</p>
<p>现在我们知道了数组的长相，能辨认数组了，那么接下来我们就看看怎么声明一个数组：</p>
<h3 id="二、数组的声明"><a href="#二、数组的声明" class="headerlink" title="二、数组的声明"></a>二、数组的声明</h3><p>声明数组的方式总的来说有两种：</p>
<p>①仿照对象的声明，通过数组直接量的形式，例子就是例子1；</p>
<p>②就是用个关键字new 来声明：</p>
<p>for example2：</p>
<pre><code>var a = new Array(1,2,3,true,&apos;test&apos;);
</code></pre><p>综合老看推荐的是使用数组直接量的方式来声明一个数组。</p>
<p>这里我们在稍微的说点，稀松数组就是数组里存在一个空的元素，而多维数组就是几个数组的嵌套了，因为数组的元素不是固定的，所以可以有这效果。</p>
<h3 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h3><p>数组知识的重点，就是这个数组的属性和方法，再有个重点就是数组与对象和字符串的关系。这次我们就先谈谈这个，分增、删、改、查4个方面来说。</p>
<h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>增的意思是数组的元素增多了，这个增多可以是原来数组的值的增加，也可以是形成了一个新的数组，这就意味着数组的length是变大了。好！开始介绍方法。</p>
<p>①、先来个不改变原来数组的:concat(),他的意思是把两个数组的元素给拼接起来,或者就是把元素添加到数组的元素中去：<br>for example4：</p>
<pre><code>var d = [1,3];
var dd = d.concat(&apos;1&apos;,2,4);//不改变原来的数组[1,3,&apos;1&apos;,2,4]
var ddd = d.concat([1,3,5],[4,7]);//[1,3,1,3,5,4,7]
</code></pre><p>②、通过索引为数组增加值，变化的是原来的数组：</p>
<p>for example3：</p>
<pre><code>var c = [];
c[0] = 1;//c = [0]
c[1] = 2;//c = [0,2]
c[3] = &apos;test&apos;;//c = [0,2,&apos;test&apos;]
</code></pre><p>③、push(),改变了原来的数组，意思是往原来的数组的末尾加一个或多个元素,这个和pop()组成了类似于栈的先进后出的感觉：</p>
<p>for example4：</p>
<pre><code>var pushes = [&apos;hello&apos;,&apos;2&apos;,22];
    pushes.push(11,77);//这样既可[&apos;hello&apos;,&apos;2&apos;,22,11,77]
</code></pre><p>④、unshift(),类似于push()，不过unshift()是把元素添加到了原数组元素的第一个位置：</p>
<p>for example4：</p>
<pre><code>var unshifted = [&apos;hello&apos;,&apos;2&apos;,22];
    unshifted.unshift(11,77);//这样既可[11,77,&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>⑤、splice(),这个比较特殊，因为他能增加也能减少，同样的是他改变的也是原来的数组,splice()方法里有三个参数，第一个为必填的，后两个为可选的，第一个参数是数组的索引值，是个整数，第二个意思是从第一个索引值的位置开始要去掉几个元素,这个值可以为负值，最后一个参数意思是去掉了参数，我们用什么来填补，是我们要填补的元素,返回的值是删除元素组成的数组：</p>
<p>for example5：</p>
<pre><code>var s = [&apos;hello&apos;,&apos;2&apos;,22,11,77];
    s.splice(0,3);//返回[&apos;hello&apos;,&apos;2&apos;,22]
    s.splice(0,3，&apos;world&apos;,33);//返回[&apos;hello&apos;,&apos;2&apos;,22]
</code></pre><p>以上就是增，下面说说删。</p>
<h4 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h4><p>因为说过了增，删的部分大部分是对应的，所以我们就把那些不对应的讲解一下：</p>
<p>①、delete，这是个运算符，他删除的是元素的值，至于数组的length是不变的，去掉的是数组的元素值，去不掉的是数组的属性。</p>
<p>for example6：</p>
<pre><code>var del = [1,2,3];
delete del[2];//在原数组中就没有了元素3，但是数组的length仍旧是3
</code></pre><p>②、pop(),对比push()去吧！</p>
<p>③、shift(),对比unshift()去吧！</p>
<p>④、splice()</p>
<h4 id="3-改和查"><a href="#3-改和查" class="headerlink" title="3.改和查"></a>3.改和查</h4><p>把改和查放在一起，因为我们会感觉到他们是一体的。</p>
<p>①、slice(),能接收两个参数，第一个参数是必须的，为整数值，第二个参数为可选的，为整数值，都可为负值，不改变原有的数组,截取的值包前不包后：</p>
<p>for example7：</p>
<pre><code>var sl = [1,2,3];
sl.slice(0,1);//返回[1]
</code></pre><p>②、reverse(),把数组的元素值给倒过来排序，改变了原来的数组元素的排序：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3];
revers.reverse();//返回[3,2,1]
</code></pre><p>③、sort(),把数组的元素按英文字母的顺序进行排序，也就是ASC11的顺序，这个可以接受一个比较函数，进行更好运算：</p>
<p>for example7：</p>
<pre><code>var revers = [1,2,3,10];
revers.sort();//返回[1,10,2,3]
revers.sort(function(x,y) {
        return x-y;
    });//返回的就是按数字大小比较后的顺序的数组了
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我们得知道这节的主题是什么：&quot;&gt;&lt;a href=&quot;#我们得知道这节的主题是什么：&quot; class=&quot;headerlink&quot; title=&quot;我们得知道这节的主题是什么：&quot;&gt;&lt;/a&gt;我们得知道这节的主题是什么：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;**一是&lt;/strong&gt;数
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组基础知识</title>
    <link href="http://maHouse.github.io/2017/06/03/%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://maHouse.github.io/2017/06/03/数组基础知识/</id>
    <published>2017-06-03T08:26:21.000Z</published>
    <updated>2017-06-03T08:26:21.618Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>语句</title>
    <link href="http://maHouse.github.io/2017/05/26/%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://maHouse.github.io/2017/05/26/循环和严格模式/</id>
    <published>2017-05-26T01:57:14.000Z</published>
    <updated>2017-05-26T04:36:22.075Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、表达式语句</strong></p>
<p>表达式语句常见的就是两类：赋值语句和函数调用，声明语句有var声明和function声明。</p>
<p><strong>二、条件语句</strong></p>
<p>条件语句两种if语句和switch语句，这里就说说switch语句：</p>
<pre><code>switch(n){
case ①;
//代码块
break；
case ②；
//代码块
break;
default;
//代码块
break;
}
</code></pre><p>传进来参数与①、②、③进行匹配，如果n与某个值恒等时，就执行相应的代码块。</p>
<p><strong>三、use strict（严格模式）与非严格模式的比较</strong></p>
<p>use strict语句的目的是说明脚本或者函数体的后续代码将会解析为严格代码。如果放在顶层了，那么就是严格代码。</p>
<p>use strict和普通语句的区别：</p>
<p>1.不包含任何语言的关键字，对于JavaScript解释器来说，它只是一条没有副作用的表达式语句，什么也没有做。</p>
<p>2.use strict只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。并不一定是出现在首行。</p>
<p>严格模式与非严格模式的区别</p>
<p>1.严格模式中禁止使用with语句；</p>
<p>2.所有的变量都要先声明；</p>
<p>3.严格模式中，调用的函数中的一个this值是undefined，非严格模式中调用的函数中的this值总是全局对象；</p>
<p>4.严格模式中，通过call（）或者apply（）来调用函数时，其中的this值就是通过call（）或者apply()传入的第一个参数（非严格模式中，null和undefined值被全局对象和转换为对象的非对象所代替）；</p>
<p>5.严格模式中，给只读属性赋值和给不可扩展的对象创建新成员时，会抛出一个类型错误的异常，在非中仅仅是操作失败；</p>
<p>6.严格模式中，函数的arguments对象拥有传入函数值的静态副本，非中arguments的数组和函数都是指向同一个值的引用；</p>
<p>7.严格模式中，当delete运算符后跟随非法的标识符（变量、函数、函数参数）时，会抛出语法错误，非严格模式中，delete什么也没有做，返回false；</p>
<p>8.严格模式中，在一个函数直接量中定义两个或多个同名属性将产生一个语法错误；</p>
<p>9.严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误，非中不会报错；</p>
<p>10.严格模式中，标识符eval和arguments当作关键字，它们的值是不能更改的。不能赋值、声明为变量、用作函数名、用作函数参数或者用作catch块的标识符；</p>
<p>11.严格模式中限制了对调用栈的检测能力，arguments.caller和arguments.callee都会抛出一个类型错误异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一、表达式语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表达式语句常见的就是两类：赋值语句和函数调用，声明语句有var声明和function声明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、条件语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;条件语句两种if语句和switch语句，这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>部分运算符</title>
    <link href="http://maHouse.github.io/2017/05/25/%E9%83%A8%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://maHouse.github.io/2017/05/25/部分运算符/</id>
    <published>2017-05-25T15:48:22.000Z</published>
    <updated>2017-05-26T01:17:59.490Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.in运算符</strong></p>
<p>in运算符左右有两个位置，左边的位置放的是字符串或者可以转化为字符串的值，右边的是对象，如：数组、对象。<br><img src="/image/in.jpg" alt=""></p>
<p>一般情况是字符串匹配的是对象，字符串的内容是属性名；是数字的时候匹配的是数组，数字是索引。</p>
<p><strong>2.instanceof运算符</strong></p>
<p>这个运算符是区分对象的类的，这里多提一点，区分对象的类的方法还有通过class特性和constructor属性，这两种方式，instanceof和in运算符类似，有两个操作数，不同的是①的位置是个对象，②的位置是个对象的类。<br><img src="/image/instanceof.jpg" alt=""></p>
<p>这个操作的返回值是个布尔值，如果①是②的实例化对象，则返回值是true，不是的话则返回值是false。这个寻找过程是：在原型链中找到①这个对象，再在①的原型链中找②.prototype,如果有的话就返回true，否则的话返回false。</p>
<p><strong>3.typeof运算符</strong></p>
<p>typeof运算符是我们经常用到的，我们用它来区分原始值和对象，typeof后面跟的可以是任意值。typeof是个一元运算符，我们要注意到和instanceof的不同。</p>
<p>使用形式有两种方式：  </p>
<pre><code>typeof &apos;hello world&apos;;//这里用到的是字符串
</code></pre><p> OR </p>
<pre><code>typeof (&apos;hello world&apos;);
</code></pre><p><strong>注意：</strong>typeof将函数区别对待，返回值页特殊。</p>
<p><strong>4.三元运算符</strong></p>
<p><img src="/image/three.jpg" alt=""></p>
<p>三元运算符有3个操作数，①的返回值是个布尔值，如果返回的是true，则执行②，并得出返回值，如果是false则执行③，这个比用if语句更加简洁。</p>
<p>最后说eval(),里面放进去的是字符串，返回的是一个值，因为只有字符串才会被编译（parse），其他的值放进去只会被原封不动地返回来，它是动态的，实际中运用之处微乎极微，可以考虑不使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.in运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;in运算符左右有两个位置，左边的位置放的是字符串或者可以转化为字符串的值，右边的是对象，如：数组、对象。&lt;br&gt;&lt;img src=&quot;/image/in.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般情况是字符串匹
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>变量声明及作用域</title>
    <link href="http://maHouse.github.io/2017/05/22/variable-key/"/>
    <id>http://maHouse.github.io/2017/05/22/variable-key/</id>
    <published>2017-05-22T14:32:52.000Z</published>
    <updated>2017-05-25T15:44:42.224Z</updated>
    
    <content type="html"><![CDATA[<p>变量声明有两种方式一是用<strong>var</strong>关键词再有就是用<strong>function</strong>关键词，声明使代码具有了语义。</p>
<p>var关键词声明变量在函数体内是局部变量在函数体外是全局变量，不用var声明变量无论在函数体内还是函数体外都是全局变量，后种方式声明的变量是可以用运算符delete删除掉声明的变量的，var关键词声明的变量不能被删除掉。</p>
<p>作用域就是变量能发生作用的范围，JavaScript不像C那样：变量在声明它们的代码块之外是不可见的，C是块级作用域。而JavaScript的作用域是全局作用域和局部作用域，变量在声明他们的函数体内及函数体的嵌套函数体内都是可见的。</p>
<p>变量在未声明之前是可以使用的，变量的生命提前使得变量的声明提前到函数体的顶部。</p>
<p>下面说说作用域链，作用域链从把变量的声明当作对象的属性看待说起，作用域链就是个查找的过程了。在《JavaScript权威指南》里的原话放在这里，当定义一个函数时，它实际上保存一个<strong>作用域链</strong>，当调用这个函数时，他创建一个新的对象来存储他的<strong>局部变量</strong>，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用的“链”。对于嵌套函数来说，事情变得更加有趣，每次<strong>调用外部函数</strong>时，<strong>内部函数又会重新定义一遍</strong>。因为每次<strong>调用外部函数的时候，作用域链都是不同的</strong>。内部函数在每次定义的时候都有微妙差别—在每次调用外部函数，内部函数的代码都是相同的，而关联这段代码的作用域不相同。</p>
<p>调用外部函数的时候，内部函数重新定义，这是由于作用域链的不同。大致理解了它的原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;变量声明有两种方式一是用&lt;strong&gt;var&lt;/strong&gt;关键词再有就是用&lt;strong&gt;function&lt;/strong&gt;关键词，声明使代码具有了语义。&lt;/p&gt;
&lt;p&gt;var关键词声明变量在函数体内是局部变量在函数体外是全局变量，不用var声明变量无论在函数体内还是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对象</title>
    <link href="http://maHouse.github.io/2017/05/21/object/"/>
    <id>http://maHouse.github.io/2017/05/21/object/</id>
    <published>2017-05-21T15:21:36.000Z</published>
    <updated>2017-06-03T04:34:20.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、综合概述"><a href="#一、综合概述" class="headerlink" title="一、综合概述"></a><strong>一、综合概述</strong></h2><p><strong>1.全局对象：</strong></p>
<p>全局属性：undefined、NaN、infinity</p>
<p>全局函数：isNaN()、parseInt()、eval()</p>
<p>全局对象：Math、JSON</p>
<p>构造函数：Date（）、RegExp()、String（）、Object（）、Array（）</p>
<p><strong>2.包装对象</strong></p>
<p>JavaScript里有些原始值如：字符串、数字、布尔值，它们是有自己的属性和方法的，那么它们不是对象，属性和方法又从何而来呢？</p>
<p>那我们就先从说对象说起，对象是一系列属性名和属性值的集合体。对象要引用属性值就用”.”加上属性名来引用；对象里的方法是用函数表示的，引用的时候用o.m()来表示。</p>
<p>不同的是，原始值里的字符串、数字和布尔值的属性和方法是不能被定义新的值的，而对象里面是能改变的。</p>
<p>在例子中：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;
s.indexOf(&apos;t&apos;) = 0;
</code></pre><p>在上面的例子中s是字符串，但是具有自己的属性和方法，它的实现方式是在s引用自己的属性和方法时，就会通过new String(s)创建一个临时对象，这个对象会继承s的特点。这个临时对象在用到的时候会被创建出来，一旦不用就会被销毁。</p>
<p>例如：</p>
<pre><code>var s = &apos;test&apos;;
s.len = 4;//这里是设置的新的属性值
var t = s.len;
console.log(t);//undefined
</code></pre><p>在s.len = 4;使用完后，这个属性就被销毁了，不会在往下传递了，所以打印的结果是undefined；不是length哟！代码测试如果用下面的代码：</p>
<pre><code>var s = &apos;test&apos;;
s.length = 4;
var t = s.length;
console.log(t);//这个结果就是4了
</code></pre><p>可以运用构造函数来显示的创建包装对象，</p>
<pre><code>var s = &apos;test&apos;,n = 1,b = true;
var S = new String(s);
var N = new Number(n);
var B = new Boolean(b);
</code></pre><p>如果我们用’ == ‘来判断s与S、n与N、b与B的话，结果是true；如果用’ === ‘恒等式来判断的话，就不是这个结果了。</p>
<p>JavaScript中的值的类型会根据需要字型转变，无论进行什么运算，共同的值类型是每个单独的值都能转换过去的，转换的又隐式转换和显式转换</p>
<p>for example： </p>
<pre><code>&apos;5&apos; * &apos;6*;//30,//改变就是从字符串变化到了数字类型

 30 + &apos;object&apos;;//这里就只能转变为字符串了
</code></pre><p>parseInt() =&gt;意思是把值转换为16进制的，目前就是这么多了！不足的话就再加补充。</p>
<h2 id="二、对象的创建"><a href="#二、对象的创建" class="headerlink" title="二、对象的创建"></a>二、对象的创建</h2><p>ES5中创建对象有3中方式，对象直接量、new关键字和Object.create()，这3种方式。</p>
<p>for example：</p>
<p>①对象直接量，就是直接表示出对象里面的属性和方法：</p>
<pre><code>var o = {x:1,y:2,z:function (){alert(1);}
</code></pre><p>②new关键字，就是创建一个新的对象的意思：</p>
<pre><code>var o = new Object();
o.x = 1;
o.y = 2;
</code></pre><p>③第三种方式利用到了继承的性质，Object.create(<em>,</em>);这里面有两个参数，前面的是必须填写的，意思是某个对象继承了那个对象，当然也可以填写null，后面的第二个参数是个可选的参数：</p>
<pre><code>var o1 = Object.create({x:1,y:2});//o1继承了{x:1,y:2}的属性

var o2 = Object.create(null);
</code></pre><p>在o1的情况中涉及到了继承，一会说。</p>
<p>通过原型继承创建一个新对象</p>
<pre><code>//inherit()返回一个继承原型对象p的属性的新对象
function inherit(p){
    if (p == null) throw TypeError();
    if (Object.create) return Object.create(p);//如果存在就是用它
    var t = typeof p;
    if (t !== &apos;object&apos; &amp;&amp; t !== &apos;function&apos;) throw TypeError();
    function f(){};
    f.prototype = p;
    return new f();
}
</code></pre><h2 id="三、属性的查询和设置"><a href="#三、属性的查询和设置" class="headerlink" title="三、属性的查询和设置"></a>三、属性的查询和设置</h2><p>我们要查询对象的属性时有两种方式：</p>
<p>1.是通过”.”:例如，o.name或者o.m(),来寻找属性或者方法；</p>
<p>2.通过[]来寻找或者设置：例如，o.[‘name’]，这里就要知道对象有时候也称为关联数组、散列或者字典；</p>
<p><strong>注意：</strong>JavaScript里面我们是不能通过第一种方式来改变属性名字的，因为我们不能改变一个标识符，不过我们能改变数据类型里的数据，而后一种方式就是数据类型里的字符串，是可以改变的。</p>
<p>既然谈到了属性那么我们得知道JavaScript的对象里面属性有自有属性和继承属性两种，继承属性则意味着这个属性不是自己独有的，是属于另外一个对象的，自己不过是使用了而已。</p>
<p>这里就先捋清原型、原型链、继承、类、对象之间的关系，其中原型和类再加上可扩展性是对象的3个属性。</p>
<p>我们先把一类东西，比如人给抽象出来，把人所具有的一般特征用属性和方法表示出来，意思就是一类人，对象的类属性用toString()返回的是一个字符串，表示的意思对象的类型信息。</p>
<p>原型与继承相关，这里就有涉及到了原型链，我们在查询对象o的属性时首先是到<br>对象的自有属性里查询，如果没有的话就到对象的原型里查询，再没有的话就到对象原型的原型里查询，一直到null为止，这么看来就有了一个链条的感觉。</p>
<p>如果是给属性赋值的话，失败的话，可能是属性为可读的但不可写，成功的话，就会有不同的答案了，要么创建一个属性，要么在原始对象中设置属性，例外的是如果o的属性是继承于属性x，而x属性是一个具有setter方法的accessor属性的话，就会有o直接调用setter方法，不会创建创建属性了，这个不会改变原型链。</p>
<p><strong>再谈谈setter和getter方法。</strong></p>
<p>对象是由属性名、属性值和一组特性组成，ES5中，属性值可以由一个或两个方法来代替，这两个方法就是getter方法和setter方法，由getter方法和setter方法定义的属性就是存取器属性（accessor property），不同于数据属性，存取器属性不具有可写性，要么是可读性要么是读/写性，也就是说如果只有setter方法的话，会返回的值是undefined。</p>
<p><strong>注意：定义存取器最简单的方法是采用对象的直接量语法的一种扩展写法</strong></p>
<p>形式：</p>
<pre><code>var o = {
    data_prop = value,
    get accessor_prop(){},//返回，这里是以逗号结尾的 
    set accessor_prop(value){}//设置
}
</code></pre><p>可用的地方是，我们可以传入一个值，然后返回一个不同的新值，这里就是数据双向绑定的最根本的开始喽！</p>
<p>权威指南上有个例子，在这里展示一下：2D笛卡尔点坐标</p>
<pre><code>var p = {
    //x,y均为普通的可读写的数据属性
    x：1.0，
    y:1.0,
    //r为可读写的存储器属性，它有setter和getter
    //函数体结束后不要忘了带上逗号
    get r(){
        return Math.sqrt(this.x*this.x + this.y*this.y);},
    set r(newValue){
        var oldValue = Math.sqrt(this.x*this.x + this.y*this.y);
        this.x *= ratio;
        this.y *= ratio;
    },
    //theta是只读存取器属性，只有getter方法
    get theta() { return Math.atan2(this.y,this.x);}
}
</code></pre><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p><strong>1.属性访问错误</strong></p>
<p>同理既然是错误就是我们不想要的系统报错，两种方式：对象存在属性不在或者就是对象本身就不在</p>
<p><strong>2.删除属性</strong></p>
<p>只能删除自有属性，继承属性不能被删除，而delete运算符其实是断掉了属性与宿主的关系，对于属性中的属性则没有操作到，就是不是真正的删掉了属性，这个时候可能因为内存泄漏的原因，我们需要遍历属性中的属性，并删去</p>
<p>大家可以试试这个例子：</p>
<pre><code>var a = {p:{x:1}};
b = a.p;
delete a.p;
console.log(b.x);//结果依旧是1
//如果delete a.p.x来替代a.p的话，结果就是undefined了
</code></pre><p><strong>3.检测属性</strong></p>
<p>检测属性就用in运算符、hasOwnProperty()、propertyIsEnumerable(),这3种方式，in运算符返回的是布尔值，中间的大哥判断的是某个对象是否具有<strong>自有属性</strong>，最后的大哥是个加强版，自有属性还得可枚举性为真，这三者的返回值都是布尔值</p>
<p>for example：</p>
<pre><code>var o = { x:1 }
&apos;x&apos; in o;  //true
&apos;y&apos; in o;  //false
&apos;toString&apos; in o;//true,o继承toString属性
//看看用中间的大哥来检测的结果是什么
o.hasOwnProperty(&apos;x&apos;);//true,是自有属性
o.hasOwnProperty(&apos;y&apos;);//false,没有这个属性
o.hasOwnProperty(&apos;toString&apos;);//false,这个属性是继承得来的，不是自有的

//看看最后大哥的返回值及原因吧

var o = inherit({ y:2 });
o.x = 1;
o.propertyIsEnumerable(&apos;x&apos;);//true,o有一个可枚举的自有属性x
o.propertyIsEnumerable(&apos;y&apos;);//false,o的y属性是继承过来的
</code></pre><p>除此之外还可以通过非恒等式( !== )来判断一个属性值是不是undefined</p>
<pre><code>o.x !== undefined;//true
o.y !== undefined;//false
</code></pre><p>in运算符能区分不存在的属性和存在但值为undefined的属性</p>
<p><strong>4.可枚举性</strong></p>
<p>枚举属性，我们用到的是for/in，它可以枚举遍历对象中的自有属性和继承属性，但对象继承的内置方法不可枚举，添加的属性除非你转化为不可枚举，其他都是可枚举的。</p>
<p>for example:<br>    var o = {x:1,y:2,z:3};//3个可枚举的自有属性<br>    o.propertyIsEnumerable(‘toString’);//false,不可枚举<br>    for(p in o)<br>    console.log(p);</p>
<p>过滤的方法介绍：</p>
<pre><code>for(p in o) {
    if (!o.hasOwnProperty(p)) continue;//hasOwnProperty()是自有属性的检测，不是自有属性，那就是跳过继承的属性了
}

for(p in o) {
    if(typeof o[p] === &apos;function&apos;) continue;} //跳过方法，用的是数据类型的判断
</code></pre><p>用来枚举属性的对象的工具函数</p>
<p>for example：</p>
<p><strong>①.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，则覆盖o中的属性
 这个函数并不处理getter和setter以及复制属性*/

function extend(o,p) {
    for (prop in p) {   //遍历p中的所有属性
        o[prop] = p[prop]; //将属性添加到o中
    }
    return o;
}
</code></pre><p><strong>②.</strong></p>
<pre><code>/*把p中的可枚举的属性复制到o中，并返回o
 如果o和p中含有同名属性，o中的属性则不会受到影响
 这个函数并不处理getter和setter以及复制属性*/

function merge(o,p) {
    for(prop in p) {  //遍历p中的所有属性
        if (o.hasOwnProperty[prop]) continue;//筛选掉p中已经存在的属性
        o[prop] = p[prop];将属性添加至o中
    }
    return o;
}
</code></pre><p><strong>③.</strong></p>
<pre><code>/*如果o中的属性和p中的属性没有同名的，则从o中删除这个属性
返回o*/

function restrict(o,p) {
    for(prop in o) {//遍历o中的所有属性
        if(!(prop in p)) delete o[prop];//如果在p中不存在，则删除它，这个删除还是遍历性的删除
    }
    return o;
}
</code></pre><p><strong>④.</strong></p>
<pre><code>/*如果o中的属性和p中的属性有同名的，则从o中删除这个属性
返回o*/

function subtract(o,p) {
    for (prop in p) {//遍历p中的所有属性
        delete o[prop];//把它删掉
    }
    return o;
}
</code></pre><p><strong>⑤.</strong></p>
<pre><code>/*返回一个数组，这个数组包含的是o中可枚举的自有属性的名字*/

function keys(o) {
    if(typeof o !== &apos;object&apos;) throw TypeError();//参数必须是对象
    var result = [];//将要返回的数组
    for (var prop in o) {//遍历所有的可枚举的属性
        if(o.hasOwnProperty(prop))//判断是否是自有属性
        result.push(prop);//将属性名添加到数组中
    }
    return result;//返回这个数组
}
</code></pre><p><strong>5.属性的特性</strong></p>
<p>一个属性包括1个名字和4个特性，数据属性这四个特性是：值(value)、可写性(writable)、可枚举性(enumerable)和可配置性(configurable)。而存取器属性不具有值和可写性的属性，具备的是读取(get)、写入(set)、可枚举性和可配置性。</p>
<p><strong>6.对象的三个属性</strong></p>
<p>每一个对象都有与之相关的原型(property)、类(class)和可扩展性(extensible)。</p>
<p><strong>①原型属性</strong></p>
<p>原型是用来实现继承属性的，原型也是个对象，在实例创建之初就已经设置好了</p>
<p>for example:</p>
<pre><code>var p = {x:1};//定义一个原型对象
var o = Object.create(p);//使用这个原型创建一个对象
p.isPropertyOf(o);//true，o继承p
Object.prototype.isPropertyOf(o);//true，p继承Object.prototype
</code></pre><p><strong>②类属性</strong></p>
<p>对象的类属性是一个字符串，用以表示对象的类型信息，我们只能通过间接的方式来查询它，默认的就是toString()方法，并返回字符串值。</p>
<p>for example：</p>
<pre><code>function classof(o) {
    if (o === null) return &apos;Null&apos;;
    if (o === undefined) return &apos;Undefined&apos;;
    return Object.prototype.toString.call(0).slice(8,-1);
}
</code></pre><p>classof函数可以传入任何参数，数字、字符串乃至布尔值都可以直接调用toString()方法。内置构造函数创建的对象和宿主对象都具有有意义的类属性，通过对象直接量和Object.create创建的对象的类属性是‘Object’，自定义的构造函数创建的对象也是如此，对于自定义的类来说，没办法通过类属性来区分对象的类。</p>
<p>for example：</p>
<pre><code>classof(null);
classof(1);
classof(&quot;&quot;);
classof(true);
classof([]);
classof(new Date());
function f() {};
classof(new f());//Object,这个是一定了
</code></pre><p><strong>③可扩展性</strong></p>
<p><strong>7.序列化对象</strong></p>
<p>对象序列化是指将对象的状态转化为字符串，也可以将字符串还原为对象，ES5提供了内置函数JSON.stringfy()和JSON.parse()来实现。</p>
<p>for example：</p>
<pre><code>var o = {x：1，y:{z:[false,null,&apos;&apos;]}};
s = JSON.stringfy(o);//o就成为了字符串
p = JSON.parse(s);//p是o的深拷贝
</code></pre><p><strong>8.对象方法</strong></p>
<p><strong>①toString()方法</strong></p>
<p>Array.toString()、Date.toString()等等，</p>
<pre><code>var s = {x:1,y:2}.toString();
</code></pre><p><strong>②toLocalString()方法</strong></p>
<p><strong>③toJSON</strong></p>
<p><strong>④valueOf()方法</strong></p>
<p>与toString()方法类似，但往往当JavaScript需要将对象转化为某种原始值而非字符串时才会用它，尤其是转换为数字的时候。</p>
<p>这一部分的知识就先到这里了，下一组是数组</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、综合概述&quot;&gt;&lt;a href=&quot;#一、综合概述&quot; class=&quot;headerlink&quot; title=&quot;一、综合概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、综合概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.全局对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局属性：
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript的数据类型</title>
    <link href="http://maHouse.github.io/2017/05/18/JS-data-type/"/>
    <id>http://maHouse.github.io/2017/05/18/JS-data-type/</id>
    <published>2017-05-18T13:37:23.000Z</published>
    <updated>2017-05-21T15:16:29.480Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的数据是放在内存中的，而我们也知道数字、字符串等在内存中的存储方式、所占存储空间是不同的，分类就诞生了。JavaScript中的数据类型分为：基础数据类型（原始数据类型）、对象类型。</p>
<p>原始数据类型：<strong>数字（number）</strong>、<strong>字符串（string）</strong>、<strong>布尔值（Boolean）</strong>、<strong>null</strong>和<strong>undefined</strong>。</p>
<p>对象类型：<strong>Math（数字）</strong>、<strong>Date（日期）</strong>、<strong>Array（数组）</strong>、<strong>Function（函数）</strong>、<strong>RegExp（正则表达式）</strong>，这几种基础数据类型，先说第一个number吧！</p>
<h2 id="1-数字（number）"><a href="#1-数字（number）" class="headerlink" title="1.数字（number）"></a>1.数字（number）</h2><p>没啥意思，这个表示的就是数字，而数字中又分为整型和浮点型，就是整数和小数或分数。不好意思的是，JavaScript中没有具体的再区分它们两个，而是就用浮点型表示数字：1 == 1.0，这个是成立的。</p>
<p>运算符：+（加）、-（减）、*（乘）、/（除）、%（取余），运算也就是这个几个或者是几个的复合运算。</p>
<p>JavaScript数字的几个概念</p>
<p>无穷大（infinity），一个忒大的数字，出现了溢出（overflow），上溢出；</p>
<p>负无穷（-infinity），一个忒小的数字，出现了下溢出（underflow）；</p>
<p>除此之外，还有个中特别的存在就是非数字（not-a-number既NaN)，NaN是非数字的意思，情况有几种：无穷大除以无穷大、负数开平方、非数字或者不能获得数字的运算符进行了运算，这几种情况都是出现NaN。</p>
<p>NaN是个孤独的游魂，他没有伙伴，我们只能证明一个值不是NaN，而不能证明一个值是NaN，表达式是：</p>
<p> x != NaN,不能写作 x == NaN(后者是个错误的存在)。</p>
<p>上面的仅仅是数字的相关知识，还有Math对象对于数字的操作运算，这个下次再做分析。</p>
<h2 id="2-字符串（string）"><a href="#2-字符串（string）" class="headerlink" title="2.字符串（string）"></a>2.字符串（string）</h2><p>字符串就是个有次数的不可改变的16位值的序列，字符串的表现形式就是把值放到单引号’’或者双引号””里面，或者是个空值也可以。</p>
<p>因为JavaScript是用UTF-16编码的Unicode字符集，所以JavaScript的所有字符都是16位的。次序就是在字符串中相同字符也是有不同的索引的，不可改变就从字符串的所有方法看吧！</p>
<p>方法一是获取相关值</p>
<p>s.charAt();//用数字获取相关位置的值，因此里面填的是数字</p>
<p>s.substring(a,b);//两个数字，包前不包后</p>
<p>s.slice(a,b)；//同上</p>
<p>s.indexOf();//里面的字符串值，出现的就是这个字符的首次出现的位置的索引</p>
<p>s.lastIndexOf();//方法类似于上面</p>
<p>s.split();//以什么作为分割点</p>
<p>s.replace();//两个字符，前面的用后面的值来代替</p>
<p>s.toUpperCase();//变为大写</p>
<p>下面就用代码来实现一下，证实一下原字符串是不是不可改变的：</p>
<pre><code>var s = &quot;hello world&quot;;

console.log(s.indexOf(&apos;o&apos;));
console.log(s.lastIndexOf(&apos;o&apos;));
console.log(s.charAt(2));
console.log(s.toUpperCase());
console.log(s.substring(0,3));//同样是包前不包后
console.log(s.slice(2));//包前不包后，因为2后面没有结尾意思就是到最后
console.log(s.replace(&apos;w&apos;,&apos;W&apos;));
console.log(s.split(&apos;v&apos;));//这个就是字符串里没有的话，可以说是没有用的
console.log(s.split(&apos; &apos;));
</code></pre><h2 id="3-布尔值（boolean）"><a href="#3-布尔值（boolean）" class="headerlink" title="3.布尔值（boolean）"></a>3.布尔值（boolean）</h2><p>布尔值代表的意思是真或假、开或关、是或否，多用于控制结构的比较语句中，这个类型只有两个值：true、false。</p>
<p>JavaScript中的任意值都能转换成布尔值，下面的这些值能转换成false：undefined、null、0、-0、””(空字符串)、NaN，所有其他值包括对象（数组）则被转换成true。</p>
<p>用个例子：声明个变量o,<strong>if(o ！== null)</strong>再有一个<strong>if(o)</strong>,前个例子是证明变量o是不是null值，不是的话会执行下去，后一个变量是意思是为真（o不是false、null和undefined）的时候会执行下去。</p>
<p>关于布尔值的在有的话就是运算符的运用了！AND（&amp;&amp;）、OR（||）、非（NOT既！）。</p>
<h2 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a>4.null和undefined</h2><p>null就是程序级别的，不是系统报错报出来的，是我们可以写出来的，我们可以写作参数的；undefined是系统报错的，我们不期望遇到，遇到的原因大概有三：</p>
<p>①我们声明了变量，但是没有给变量赋值</p>
<p>如：    </p>
<pre><code>var a;

console.log(a);//这里打印出来的就是undefined
</code></pre><p>②参数的形式参数的引用了却没有实参</p>
<p>如：</p>
<pre><code> function a (b,c,d){

    console.log(b + c);

    console.log(d);//这里打印出来的就是undefined
  }

a(1,0);
</code></pre><p>好玩的是如果console.log(b + c + d);这里打印出来的值是NaN，你想想一个数字加undefined，结果就是NaN。</p>
<p>③再有一个现象就是对象里，我们有3个值，你非要找第四个值，那是没有了，只会报出undefined。</p>
<p>为了避免出现undefined的现象，我们一定要注意几个原因，声明变量的时候，</p>
<p>如：newHtml = “”;//不要只声明了不初始化值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript的数据是放在内存中的，而我们也知道数字、字符串等在内存中的存储方式、所占存储空间是不同的，分类就诞生了。JavaScript中的数据类型分为：基础数据类型（原始数据类型）、对象类型。&lt;/p&gt;
&lt;p&gt;原始数据类型：&lt;strong&gt;数字（number）&lt;/s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo中域名的配置</title>
    <link href="http://maHouse.github.io/2017/05/16/my-domain/"/>
    <id>http://maHouse.github.io/2017/05/16/my-domain/</id>
    <published>2017-05-16T13:06:34.000Z</published>
    <updated>2017-05-16T14:00:24.977Z</updated>
    
    <content type="html"><![CDATA[<p>这个时候，你的.io的github网站是可以使用的了，接下来就是怎么使用自己的域名去搞定一切了！OK,我们开始吧！</p>
<p><a href="http://www.szhot.com/" target="_blank" rel="external">http://www.szhot.com/</a>我的是在万维网申请的，在万维网你要做几件事：</p>
<p>1.申请一个域名，花多少钱，就看你自己个了！这一步就是给自己的网站起了个名字。</p>
<p>2.购买一个虚拟主机，花多少钱看你自己，有了名字但没有IP地址，就是服务器端没有你的空间，这一步就是在服务器端有个你的位置。</p>
<p>3.OK！为了顺利完成工作，你还要做：</p>
<p>①</p>
<p><img src="/image/www.png" alt=""></p>
<p>切记这三部分是必须完成的，光标点亮后才能进行下一步的工作；</p>
<p>②身份证正反面复印件，必须在一面上，还要有你的签名，按要求做吧；</p>
<p>③</p>
<p><img src="/image/kwww2.jpg" alt=""></p>
<p>这里还有一步关键，在你的E:\blog\source里，就是你的文件路径里配置个CNAME文件，没有后缀，在里面写上你的域名（不加www的域名）。这个下面就要用到了。</p>
<p><strong>按这个步骤进行操作</strong>圈子里的我们改成这个样子的，不要会错了意！！！</p>
<p>把这个搞好后就开始进行在dnspod上的修改，选择dnspod的原因是稳定！<a href="https://www.dnspod.cn/" target="_blank" rel="external">https://www.dnspod.cn/</a></p>
<p>修改的地方在哪里呢？请看：</p>
<p><img src="/image/www3.png" alt=""></p>
<p>在域名解析里，这个域名是我添加进来了，你要添加进来，点击进来</p>
<p><img src="/image/www4.png" alt=""></p>
<p>圈子里的是你照搬的，这个是github的IP地址，不用的话是找不到你的网页的。<br>而最下面的主机记录:www,记录类型:CNAME,记录值是你的github网址，OK了！<br>一切准备就绪！千万记得，hexo g和hexo d命令，把你的修改给布置到页面上来！</p>
<p>欢迎大家来践踏我的博文<a href="mashuaiqi.com">mashuaiqi.com</a>，，，，欢迎！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个时候，你的.io的github网站是可以使用的了，接下来就是怎么使用自己的域名去搞定一切了！OK,我们开始吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.szhot.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ww
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>markdownpad快捷键分享</title>
    <link href="http://maHouse.github.io/2017/05/15/markdownpad/"/>
    <id>http://maHouse.github.io/2017/05/15/markdownpad/</id>
    <published>2017-05-14T16:09:20.000Z</published>
    <updated>2017-05-15T12:54:33.278Z</updated>
    
    <content type="html"><![CDATA[<p>Markdownpad是你编写博客的利器，使用的时候你可以用鼠标去为句子或者词语加粗、加链接、加图片等，但是快捷键的魅力之处就是一个词—快，快的不要不要的。</p>
<p><strong>Ctrl + I ： 斜体</strong></p>
<p><strong>Ctrl + B ： 粗体</strong></p>
<p><strong>Ctrl + G ： 图片</strong></p>
<p><strong>Ctrl + Q ： 引用</strong></p>
<p><strong>Ctrl + 1 ： 标题 1</strong></p>
<p><strong>Ctrl + 2 ： 标题 2</strong></p>
<p><strong>Ctrl + 3 ： 标题 3</strong></p>
<p><strong>Ctrl + K ： 代码块</strong></p>
<p><strong>Ctrl + L ： 超链接</strong></p>
<p><strong>Ctrl + T ： 时间戳</strong></p>
<p><strong>Ctrl + U ： 无序列表</strong></p>
<p><strong>Ctrl + R ： 水平标尺</strong></p>
<p><strong>F4 ： 启用水平布局</strong></p>
<p><strong>F5 ： 启用实时预览</strong></p>
<p><strong>F6 ： 在浏览器中预览</strong></p>
<p><strong>Ctrl + Shift + O ： 有序列表</strong></p>
<p>Ok！大家如果有更好的好玩的工具，分享给我哟！谢谢你们了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdownpad是你编写博客的利器，使用的时候你可以用鼠标去为句子或者词语加粗、加链接、加图片等，但是快捷键的魅力之处就是一个词—快，快的不要不要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ctrl + I ： 斜体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ctrl 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript 诞生记</title>
    <link href="http://maHouse.github.io/2017/05/13/javascript-txt/"/>
    <id>http://maHouse.github.io/2017/05/13/javascript-txt/</id>
    <published>2017-05-13T14:54:48.000Z</published>
    <updated>2017-05-14T16:05:45.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong>十八世纪英国文学家约翰逊博士对JavaScript说过一句很好的话，它的优秀之处并非原创，它的原创之处并不优秀。</strong></p>
<p>多么牛叉的一句话啊！那为什么这么说呢？我们看看JavaScript是怎么诞生的。</p>
<p>1994年，网景公司发布了第一个比较成熟的网络浏览器，但它仅仅支持浏览文件，就是你只能看，不能进行页面之间的互动，多么尴尬啊！Netscape需要一种网页脚本语言，使得网页之间通过浏览器进行互动。</p>
<p>那到底选择哪种语言呢？公司众说纷纭，选择现有的语言，如：Scheme、Python等，有现有的代码和程序员；不然的话，就发明一种更好的新语言。</p>
<p>这个时候公司招聘进来一个哥们–Brendan  Eich，他对函数式编程很感兴趣，公司招聘他的目的就是研究将Scheme作为网页脚本语言的可能性。这个时候Java是很火爆的，网景管理层也煞是迷恋。后来，网景公司有个决定，这个将要诞生的网页脚本语言必须与Java足够相似，使得非专业者也能很快上手。</p>
<p>既然有了要求就开始做个筛选吧！Java是面向对象编程的，而已经存在的语言，如：Perl、Python、Tcl、Scheme，它们是非面向对象的，因此他们自然就被排除在外了。作为简化版的Java语言的设计师—Brendan  Eich反而对Java不感冒。</p>
<p>这兄弟就开始一顿乱搞了，七拼八凑的，10天就把JavaScript给造出来了。</p>
<p>他的设计思路是：</p>
<ol>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Java的数据类型和内存管理；</strong></li>
<li><strong>借鉴C语言的基本语法；</strong></li>
<li><strong>借鉴Self语言，使用基于原型（prototype）的继承机制，对象就随之出现；</strong></li>
</ol>
<p>综上知：<strong>JavaScript = 简化的函数式编程 + 面向对象编程</strong>，这是多么愉快的决定啊！把Java作为JavaScript的设计原型，这是公司的决定，在既圆了公司管理层的决定，又有自己的决定在里面，这个东西本来就是一种迎合公司和自己的杂合物。</p>
<p>在结束的时候回味一下约翰逊博士的话，应该能有所体悟吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;十八世纪英国文学家约翰逊博士对JavaScript说过一句很好的话，它的优秀之处并非原创，它的原创之处并不优秀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多么牛叉的一句话啊！那为什么这么说呢？我们看看JavaScript是怎么诞生的。&lt;/p&gt;
&lt;p&gt;1994年，网景
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象方法</title>
    <link href="http://maHouse.github.io/2017/04/27/oop/"/>
    <id>http://maHouse.github.io/2017/04/27/oop/</id>
    <published>2017-04-27T13:54:45.000Z</published>
    <updated>2017-05-09T15:51:56.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-面向对象方法出现的原因"><a href="#一、-面向对象方法出现的原因" class="headerlink" title="一、 面向对象方法出现的原因"></a>一、 面向对象方法出现的原因</h2><p>传统软件工程方法的确给软件产业带来了巨大进步，但它仅在中小规模软件开发中获得了好成绩，在大型的软件开发中很少取得成功。因此，后来面向对象技术得到了开发者的青睐。</p>
<h2 id="二、-面向对象方法的4个要点"><a href="#二、-面向对象方法的4个要点" class="headerlink" title="二、 面向对象方法的4个要点"></a>二、 面向对象方法的4个要点</h2><p><strong>1.</strong>树立对象意识，客观世界是有各种对象组成的，复杂的对象由简单的对象组成。因此，面向对象的软件系统是由对象组成的，软件中的任何元素都是对象，复杂的对象由简单的对象组成。与传统方法的区别是用对象分解代替了其功能分解。</p>
<p><strong>2.</strong>把所有对象划分为各种对象类，每个类都定义了一组数据和方法。数据用于表示数据的静态属性，乃对象的静态属性，每当建立一个对象类的实例时，就按照对象类中对数据的定义，生成一组专用的数据。例如，荧光屏上不同位置显示的半径各不相同的圆，虽然都是Circle类的对象，但都有自己的专属数据，以便记录各自的圆心位置、半径等。</p>
<p>类中定义的方法，是允许施加于该类对象上的操作，是该类所有对象共享的，并不需要为每个对象都复制操作的代码。因为过程是一样的或是类似的，我们把操作的流程（操作）给定义下来，就是一条流水线生产多种产品了。</p>
<p><strong>3.</strong>按照子类与父类的关系，把若干对象类组成一个系统，下层的类与上层类的特性相同，这就是一种继承现象。同时也得晓得底层的类能屏蔽高层类的同名特性。</p>
<p><strong>4.</strong>对象彼此之间仅能通过传递信息相互联系。这里也与传统方法的数据有本质的区别，它不是被动的等待外界世界对它施加操作，相反的是，它是进行操作的主体，不能直接从外部世界修改它的私有数据，所有的私有数据都是封装在对象类中，这就是封装性。</p>
<h2 id="三、-面向对象方法的优点"><a href="#三、-面向对象方法的优点" class="headerlink" title="三、 面向对象方法的优点"></a>三、 面向对象方法的优点</h2><p><strong>1.</strong>符合人类的思维特点</p>
<p>抽象为一般的特点，然后再说一个个个例的不同之处。例如，我们说动物，我们会把具有某些相似特征的生物划分为动物，ok！有了动物，那么我们还要更加细化，则在根据某些特征抽象出来，比如把人从动物里就可以抽象出来。</p>
<p><strong>2.</strong>稳定性好</p>
<p>功能发生改变，在传统方法里，因为功能分析和功能分解，如果功能需求发生改变，改变的是整个软件结构，这个量很大的。相反，在面向对象方法里，仅仅通过修改局部方法就可以，不必修改全部。</p>
<p><strong>3.</strong>可重用性好</p>
<p>可以用旧的零件做新的产品，重复使用一个对象类，创建新的实例或者在对象类里增加数据和方法，都是不影响原来的使用。</p>
<p><strong>4.</strong>容易开发大型的软件</p>
<p>原因就是，把大的软件产品分解为许多相互独立的小个体，技术难度降低、开发管理更容易。</p>
<p><strong>5.</strong>可维护性好</p>
<p>面向对象方法开发的软件稳定性好、易于修改、容易理解更加易于测试，总体就突出了它的可维护性好的特点。</p>
<h2 id="四、-面向对象的概念介绍"><a href="#四、-面向对象的概念介绍" class="headerlink" title="四、 面向对象的概念介绍"></a>四、 面向对象的概念介绍</h2><p><strong>1.</strong>说说对象的特点</p>
<p>①以数据为中心。因为数据是对象数据结构的一部分，是它的状态。</p>
<p>②本质上具有并行性。不同对象各自独立处理自身数据，彼此通过发送消息传递信息完成通信。因此，具有并行工作的属性。</p>
<p>③模块独立性好。模块与对象的关系，对象本身就是面向对象的软件的基本模块，模块讲究的内聚性和耦合性在对象上能充分体现出来。因为对象的数据和属性是在一个对象类里面的，操作也是在这里面的，作为一个基本的模块单元，它的内聚性很高。也因为这个原因，对象之间的关联很小，它们之间的耦合性很宽松。</p>
<p><strong>2.</strong>其他的相关概念</p>
<p>①类（class）</p>
<p>古语讲，物以类聚，这个“类”说的也是某些特点的在一起，抽象出来了一群人。类是支持继承的抽象数据类型，而对象是类的实例。</p>
<p>②实例（instance）</p>
<p>实例就是类的个体化</p>
<p>③消息（message）</p>
<p>把消息传递进去就有个不同的实例</p>
<p>④方法（method）</p>
<p>对象所能执行的操作，能做什么事情</p>
<p>⑤属性（attribute）</p>
<p>类中定义圆的大小、半径、颜色就是对象的属性，就是对象的特点</p>
<p>⑥封装（encapsulation）</p>
<p>字面上说就是把一个事物包起来，使外界不知道该事物的具体内容，面向对象方法中，把表示对象状态的数据和对数据的操作放到对象内部，只把接口提供出来。因此，它有个清晰的边界，外界是看不到内部的；再有就是有确定的接口，这些接口就是对象能接受的消息，只能向对象发送消息使用它；受保护的内部实现。</p>
<p>⑦继承（inheritance）</p>
<p>广义地说，继承就是直接使用已有的性质和特征，而不必重复定义他们。一个类可以有自己的父类和子类，这就一定具有继承的特性，一个类直接继承其父类的全部描述（数据和操作）。</p>
<p>OK！基本知识就到此了，不充足的会再补充。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-面向对象方法出现的原因&quot;&gt;&lt;a href=&quot;#一、-面向对象方法出现的原因&quot; class=&quot;headerlink&quot; title=&quot;一、 面向对象方法出现的原因&quot;&gt;&lt;/a&gt;一、 面向对象方法出现的原因&lt;/h2&gt;&lt;p&gt;传统软件工程方法的确给软件产业带来了巨大进步
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模块</title>
    <link href="http://maHouse.github.io/2017/04/27/module-1/"/>
    <id>http://maHouse.github.io/2017/04/27/module-1/</id>
    <published>2017-04-27T13:54:06.000Z</published>
    <updated>2017-04-28T15:59:03.165Z</updated>
    
    <content type="html"><![CDATA[<p>在开发阶段里总体设计的过程中，我们必须明确系统是“怎么做事情”的了。在软件的设计过程中有些原理和概念是我们必须遵循的，这就是与<strong>模块</strong>有关的知识了！</p>
<h1 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1.模块化"></a>1.模块化</h1><p>先说个有意思的规律：C(x) 定义问题X的复杂程度，函数E(x)定义解决X问题所需要的工作量。对于问题P1和P2，如果</p>
<pre><code>C(P1) &gt; C(P2)
</code></pre><p> 显然       </p>
<pre><code>E(P1) &gt; E(P2)
</code></pre><p>根据人类解决问题的一般经验，一个有意思的规律就是</p>
<pre><code>C(P1+P2) &gt; C(P1)+C(P2)
</code></pre><p>因此也就有了</p>
<pre><code>E(P1+P2) &gt; E(P1)+E(P2)
</code></pre><p>结论是什么呢？就是把复杂的问题给分解成容易解决的小问题，那么大问题就迎刃而解，这是模块化的根据。</p>
<p>这就有个有意思的问题了，无限的分割软件，最后开发软件的工作量确实小的很多了。但模块间的接口的设计就在增多，你去脑洞吧，一个在减少工作量，一个在增加工作量，那模块量多少才是合适？（既是设计模块和模块接口的工作量合适，成本也合适），这个问题再说了！</p>
<h1 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2.抽象"></a>2.抽象</h1><p>抽象是现实世界的事物、状态、过程等相似方面的集中和概括，暂时忽略他们之间的差异，模块就是把抽象出来的某个层次用一定的方式描述出来。因为抽象是一层一层的，因此模块也是有其特点的。</p>
<h1 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3.逐步求精"></a>3.逐步求精</h1><p>人类认知过程中遵循个Miller法则：一个人在任何时候都只能把注意力集中到[5 9]个知识块上。</p>
<p>因此，在抽象的过程中，有了不同的层次，不同的模块，那么就有了模块的不断地精化。</p>
<h1 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4.信息隐藏和局部化"></a>4.信息隐藏和局部化</h1><p>这里隐藏的不是有关模块的所有信息，而是模块之间还要交换那些为了完成系统功能而必须交换的信息，当然是仅仅交换这些信息。模块本身就体现了这一特质。</p>
<h1 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5.模块独立"></a>5.模块独立</h1><p>模块的独立是模块化、抽象、信息隐藏和局部化的直接结果。既容易开发又容易测试是模块独立的好处，然而模块之间还是要通信的，那评价模块独立的标准又是是什么呢？<strong>内聚</strong> 和<strong>耦合</strong>。</p>
<p><strong>内聚</strong></p>
<p>内聚说的是一个模块内的事情，从一个最底层的模块说会更容易理解，既然“大家伙”（模块内的各个元素）都是一个“团队”（模块）了，那么我们就要力向一处使（做好一件事情），也就是说模块里的兄弟姐妹们都是与这件事情极其相关的。所以说内聚就是说模块内的元素关系密切，不然放一块干嘛！同理就是模块的设计时，尽量做到模块内的元素关系密切，这才符合模块间的信息隐藏和局部化。</p>
<p><strong>耦合</strong></p>
<p>有了内聚做参考就知道了既然能做同一件事或者相关事情的元素都放到一块去了（成为了一个模块），那么模块之间的关系就是松散的耦合关系喽！因为模块之间不可能做到一点关系都没有，是吧？做到松散耦合就OK了！</p>
<p>好了！以上就是关于模块的理论知识，以后在碰到关于模块的问题时不至于会一脸懵逼吧，，，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发阶段里总体设计的过程中，我们必须明确系统是“怎么做事情”的了。在软件的设计过程中有些原理和概念是我们必须遵循的，这就是与&lt;strong&gt;模块&lt;/strong&gt;有关的知识了！&lt;/p&gt;
&lt;h1 id=&quot;1-模块化&quot;&gt;&lt;a href=&quot;#1-模块化&quot; class=&quot;head
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件工程方法学（番外篇）</title>
    <link href="http://maHouse.github.io/2017/04/27/module-knowlage1/"/>
    <id>http://maHouse.github.io/2017/04/27/module-knowlage1/</id>
    <published>2017-04-27T13:17:31.000Z</published>
    <updated>2017-04-28T14:38:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>本篇的主题讲述的是<a href="module-1.md"><strong>模块</strong></a>和<a href="oop.md"><strong>面向对象方法学</strong></a>，这篇番外篇讲的就是“主人公”的生活大环境，内容是下面3方面，“主人公”出现在软件工程的哪个位置、出现的原因、解决了什么问题，主要是这几个方面。</p>
<p>在计算机系统发展历史中，开发软件的错误方法和观念导致了软件危机的出现。为了计算机系统的进一步发展，就逐步发展和完善了软件工程学科。</p>
<p>软件工程方法是软件工程的技术方面的内容，软件工程使用的最广泛的是：<strong>传统方法</strong>和<strong>面向对象方法</strong>。</p>
<p><strong>一、传统方法</strong></p>
<p>又叫做生命周期方法学或者结构化范型，它是把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务。OK！你看到了生命周期，它的意思是一个软件从定义、开发、使用和维护，直到被废弃，经历的漫长时期，就类似于一个人的出生、婴儿、童年、青年、中年和老年，直到死亡的漫长期限。</p>
<p>它的阶段有哪些呢？</p>
<p><img src="/image/tra.jpg" alt=""></p>
<p>看到了<a href="module-1.md"><strong>模块</strong></a>思想开始应用的阶段（开发阶段里的总体设计）了吧！当然既然是思想，可以用到的地方必然很多了，在模块化专章里我们具体的讲讲关于它的知识。</p>
<p><strong>二、面向对象方法</strong></p>
<p>对于面向对象方法学，这次就说一个方程就行了：</p>
<h1 id="OO-objects-classes-inheritance-communication-with-messages"><a href="#OO-objects-classes-inheritance-communication-with-messages" class="headerlink" title="OO = objects + classes + inheritance + communication with messages"></a>OO = objects + classes + inheritance + communication with messages</h1><p>意思就是：面向对象就是既使用对象又使用类和继承等机制，而且对象之间仅能通过传递消息实现彼此通信。</p>
<p>OK！下次细细讲解模块化和面向对象方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇的主题讲述的是&lt;a href=&quot;module-1.md&quot;&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;oop.md&quot;&gt;&lt;strong&gt;面向对象方法学&lt;/strong&gt;&lt;/a&gt;，这篇番外篇讲的就是“主人公”的生活大环境，内容是下面3方面，“主人公”出
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://maHouse.github.io/2017/04/26/resume/"/>
    <id>http://maHouse.github.io/2017/04/26/resume/</id>
    <published>2017-04-26T10:10:13.000Z</published>
    <updated>2017-04-26T10:11:36.011Z</updated>
    
    <content type="html"><![CDATA[<p><strong>姓名：</strong>马帅旗       </p>
<p><strong>籍贯：</strong>河南商丘 </p>
<p><strong>职业：</strong>人生工程师</p>
<p><strong>技能：</strong>精通HTML、CSS、JS 等</p>
<p><strong>座右铭：</strong>爱计算机的工商管理专业兄弟！没事咱们也可以一起聊聊马刺或者一起来个长途骑行！  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;姓名：&lt;/strong&gt;马帅旗       &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;籍贯：&lt;/strong&gt;河南商丘 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;职业：&lt;/strong&gt;人生工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技能：&lt;/strong&gt;精通HTML、CSS、JS
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sublime设置自己的浏览器方法</title>
    <link href="http://maHouse.github.io/2017/04/26/sublime/"/>
    <id>http://maHouse.github.io/2017/04/26/sublime/</id>
    <published>2017-04-26T10:04:00.000Z</published>
    <updated>2017-04-26T10:44:59.175Z</updated>
    
    <content type="html"><![CDATA[<p>sublime 中，有个默认的浏览器，就是你鼠标右键点击后出现的，我的是sublime Text 3 </p>
<p><img src="/image/s.png" alt=""></p>
<p>这里的红色部分的Open in brower 就是你的默认浏览器，我的事默认浏览器是IE，当然我想在Chrome里看看效果，并调试一下，怎么设置呢？</p>
<p>点击深绿色的Preferences栏</p>
<p><img src="/image/s2.png" alt=""></p>
<p>看到了Key Bindings 点进去进到如下界面：</p>
<p><img src="/image/s3.png" alt=""></p>
<p>你的是没有红色部分及下面的内容的，这里就是我自己设置的了，你就直接把我的代码放进去就可以了，你能 <strong>随意改</strong> 的是 keys这里的快捷键，再有就是application里的内容，你是要必须改的，换成你的浏览器位置的路径</p>
<p><img src="/image/s4.png" alt=""></p>
<p><strong>注意：</strong>这里的斜杠是怎么写的一定要注意</p>
<p>你要用的代码：<br>//chorme</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f6&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Users\\asus\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>},<br>//Firefox</p>
<p>{</p>
<pre><code>&quot;keys&quot;:[&quot;f7&quot;],

&quot;command&quot;:&quot;side_bar_files_open_with&quot;,

&quot;args&quot;:{

    &quot;paths&quot;:[],

    &quot;application&quot;:&quot;C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe&quot;,

    &quot;extensions&quot;:&quot;.*&quot;
</code></pre><p>}</p>
<p>}</p>
<p>到了这一步了，你可能会说，我怎么获得我的浏览器的位置呢，ok！在你的桌面上<strong>把鼠标悬浮到你要设置的浏览器上，并点击右键</strong>，会有# <strong>打开文件所在的位置</strong> #这个命令，点击进去，会到这个页面</p>
<p><img src="/image/s5.png" alt=""></p>
<p>找到了，点击上面红色的路径，粘贴到application里去，记得加上后面的chrome.exe，这样就设置好了，以后用的时候直接用快捷键就行了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sublime 中，有个默认的浏览器，就是你鼠标右键点击后出现的，我的是sublime Text 3 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/s.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的红色部分的Open in brower 就是你的默认浏览器，我的事默认浏
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客（二）</title>
    <link href="http://maHouse.github.io/2017/04/26/hexo2/"/>
    <id>http://maHouse.github.io/2017/04/26/hexo2/</id>
    <published>2017-04-26T07:54:43.000Z</published>
    <updated>2017-04-26T09:37:00.198Z</updated>
    
    <content type="html"><![CDATA[<p>上次说到会用网址访问页面，细想了一下，你只要能按我发的那个链接走的话就能很好的出现效果，下面就说说一些必要的注意事项。</p>
<p>1.下载Markdownpad,<a href="http://markdownpad.com/" target="_blank" rel="external">http://markdownpad.com/</a>，这里在windows10里会有个小问题，需要配置个什么小玩意，你自己去搞定啦！</p>
<p>再有就是下载个Notepad++，<a href="https://notepad-plus-plus.org/" target="_blank" rel="external">https://notepad-plus-plus.org/</a>，目的是避免以后你编辑的东西会因为字符集的问题而不能正常使用</p>
<p>2.下载完成后，就按链接里前辈的路子走吧！以下几个命令是常用的，它们执行后的样子是啥样的</p>
<p><strong>hexo g</strong> ##目的是把你修改的东西变成静态文件，每次修改后都要在Git里执行一次这个命令，成功的样子是</p>
<p><img src="/image/12.png" alt=""></p>
<p><strong>hexo s</strong> ##启动服务器，当你想在把东西放到网页上前检查一下的时候用</p>
<p><img src="/image/13.png" alt=""></p>
<p>localhost:4000在这个时候使用，要执行其他的命令就要用Ctrl+C快捷键停止这一步</p>
<p><strong>hexo d</strong> ##把文件部署到github,这一步有意思的东西多，部署成功的标志是，命令执行完后，成功标志</p>
<p><img src="/image/14.png" alt=""></p>
<p>其他的均属未成功，解决方案：重新登录github网站，能进去的话，就把你所遇到的问题粘贴到网上搜索答案，不能进去的话，一个方法就是等到能进去的时候在执行这个命令。</p>
<p>3.主题的配置，当你把Hexo下载完后，是一个默认的主题，后面的主题，你就可以自己去选择了，你可以选择和前辈一样的主题，也可以自己寻找实验，找到更适合你的，安装方法就是去看主题制作者的Readme里面有详细的步骤</p>
<p><strong>注：</strong>有什么不会的我们可以共同讨论，这个主题就先到这里了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次说到会用网址访问页面，细想了一下，你只要能按我发的那个链接走的话就能很好的出现效果，下面就说说一些必要的注意事项。&lt;/p&gt;
&lt;p&gt;1.下载Markdownpad,&lt;a href=&quot;http://markdownpad.com/&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建博客（一）</title>
    <link href="http://maHouse.github.io/2017/04/23/myblog/"/>
    <id>http://maHouse.github.io/2017/04/23/myblog/</id>
    <published>2017-04-23T12:40:05.000Z</published>
    <updated>2017-04-26T07:51:22.405Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你目前看到的这个博客就是我才搭建好的属于我自己的简易窝棚，搭建过程中虽然是看着前辈的流程走的，但不得不说我还是踩了很多坑的，好了接下来我向大家说说我的踩坑经历吧！</strong>你也可以参考其他前辈的过程，不过，记住一定要以一个的过程为主，我参考的是<a href="http://tengj.top/2016/02/22/hexo1/" target="_blank" rel="external">http://tengj.top/2016/02/22/hexo1/</a></p>
<ol>
<li>先下载必备的东西Git，通过它把文件托管到本地和github上，必须下载，<a href="https://git-scm.com" title="下载地址" target="_blank" rel="external">https://git-scm.com</a>。<br><img src="/image/g.png" alt="">,右下角的这个位置，注意：电脑系统版本</li>
<li>下载Nodejs去，同样是官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>，<img src="/image/g2.png" alt="最好是最新版本的"></li>
<li>工具已经准备完成，下面就开始操刀吧！</li>
</ol>
<p><strong>首先</strong>，安装Hexo，这里安装的时候可以在nodejs里安装，也可以在Git里安装：</p>
<p>nodejs里：<strong>npm install -g hexo</strong> 或者<strong>npm install hexo-cli -g</strong></p>
<p><img src="/image/nodejs.png" alt=""><br>检测安装成功与否，用<strong>hexo -v</strong> ,出现版本号说明成功</p>
<p>Git里的执行命令是一样的，注意：应该在Git Bash Here里执行同样命令</p>
<p><strong>第二步</strong>，在你建立的blog文件夹下，点击右键出现如下<img src="/image/git.png" alt=""> </p>
<p>执行命令 <strong>hexo init</strong> 自动在目标文件夹建立网站所需要的所有文件。</p>
<p>然后执行<strong>npm install</strong> 安装依赖包<br><strong>第三步</strong>，这一步就是验证以上的操作效果如何了，先执行<strong>hexo g</strong>,这是用于生成静态文件，再执行<strong>hexo s</strong>，这是启动服务器，<img src="img/dis.png" alt="">,执行之后就按图片去看看默认的效果吧！<img src="/image/re.png" alt="">,出现这个效果就完成了初步目的</p>
<p>最后，我们应该知道我们访问的东西是用localhost:4000访问得到的，下一步我们就用域名来获得这个页面，明天见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;你目前看到的这个博客就是我才搭建好的属于我自己的简易窝棚，搭建过程中虽然是看着前辈的流程走的，但不得不说我还是踩了很多坑的，好了接下来我向大家说说我的踩坑经历吧！&lt;/strong&gt;你也可以参考其他前辈的过程，不过，记住一定要以一个的过程为主，我参考的是&lt;a 
    
    </summary>
    
    
  </entry>
  
</feed>
